{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"file":"stream.js","sources":["file:///E:/Project%20That%20I%20Can%20Done%20nd%20Git%20Upl/summarized-app/node_modules/effect/src/internal/stream.ts"],"sourcesContent":["import * as Cause from \"../Cause.js\"\nimport type * as Channel from \"../Channel.js\"\nimport * as Chunk from \"../Chunk.js\"\nimport * as Clock from \"../Clock.js\"\nimport * as Context from \"../Context.js\"\nimport * as Deferred from \"../Deferred.js\"\nimport * as Duration from \"../Duration.js\"\nimport * as Effect from \"../Effect.js\"\nimport * as Either from \"../Either.js\"\nimport * as Equal from \"../Equal.js\"\nimport type { ExecutionPlan } from \"../ExecutionPlan.js\"\nimport * as Exit from \"../Exit.js\"\nimport * as Fiber from \"../Fiber.js\"\nimport * as FiberRef from \"../FiberRef.js\"\nimport type { LazyArg } from \"../Function.js\"\nimport { constTrue, dual, identity, pipe } from \"../Function.js\"\nimport * as internalExecutionPlan from \"../internal/executionPlan.js\"\nimport * as Layer from \"../Layer.js\"\nimport * as MergeDecision from \"../MergeDecision.js\"\nimport * as Option from \"../Option.js\"\nimport type * as Order from \"../Order.js\"\nimport { pipeArguments } from \"../Pipeable.js\"\nimport { hasProperty, type Predicate, type Refinement } from \"../Predicate.js\"\nimport * as PubSub from \"../PubSub.js\"\nimport * as Queue from \"../Queue.js\"\nimport * as RcRef from \"../RcRef.js\"\nimport * as Ref from \"../Ref.js\"\nimport * as Runtime from \"../Runtime.js\"\nimport * as Schedule from \"../Schedule.js\"\nimport type * as Scope from \"../Scope.js\"\nimport type * as Sink from \"../Sink.js\"\nimport type * as Stream from \"../Stream.js\"\nimport type * as Emit from \"../StreamEmit.js\"\nimport * as HaltStrategy from \"../StreamHaltStrategy.js\"\nimport type * as Take from \"../Take.js\"\nimport * as TPubSub from \"../TPubSub.js\"\nimport * as TQueue from \"../TQueue.js\"\nimport type * as Tracer from \"../Tracer.js\"\nimport * as Tuple from \"../Tuple.js\"\nimport type * as Types from \"../Types.js\"\nimport * as channel from \"./channel.js\"\nimport * as channelExecutor from \"./channel/channelExecutor.js\"\nimport * as MergeStrategy from \"./channel/mergeStrategy.js\"\nimport * as core from \"./core-stream.js\"\nimport * as doNotation from \"./doNotation.js\"\nimport { RingBuffer } from \"./ringBuffer.js\"\nimport * as InternalSchedule from \"./schedule.js\"\nimport * as sink_ from \"./sink.js\"\nimport * as DebounceState from \"./stream/debounceState.js\"\nimport * as emit from \"./stream/emit.js\"\nimport * as haltStrategy from \"./stream/haltStrategy.js\"\nimport * as Handoff from \"./stream/handoff.js\"\nimport * as HandoffSignal from \"./stream/handoffSignal.js\"\nimport * as pull from \"./stream/pull.js\"\nimport * as SinkEndReason from \"./stream/sinkEndReason.js\"\nimport * as ZipAllState from \"./stream/zipAllState.js\"\nimport * as ZipChunksState from \"./stream/zipChunksState.js\"\nimport * as InternalTake from \"./take.js\"\nimport * as InternalTracer from \"./tracer.js\"\n\n/** @internal */\nconst StreamSymbolKey = \"effect/Stream\"\n\n/** @internal */\nexport const StreamTypeId: Stream.StreamTypeId = Symbol.for(\n  StreamSymbolKey\n) as Stream.StreamTypeId\n\n/** @internal */\nconst streamVariance = {\n  _R: (_: never) => _,\n  _E: (_: never) => _,\n  _A: (_: never) => _\n}\n\n/** @internal */\nexport class StreamImpl<out A, out E = never, out R = never> implements Stream.Stream<A, E, R> {\n  readonly [StreamTypeId] = streamVariance\n  constructor(\n    readonly channel: Channel.Channel<Chunk.Chunk<A>, unknown, E, unknown, unknown, unknown, R>\n  ) {\n  }\n\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\n/** @internal */\nexport const isStream = (u: unknown): u is Stream.Stream<unknown, unknown, unknown> =>\n  hasProperty(u, StreamTypeId) || Effect.isEffect(u)\n\n/** @internal */\nexport const DefaultChunkSize = 4096\n\n/** @internal */\nexport const accumulate = <A, E, R>(self: Stream.Stream<A, E, R>): Stream.Stream<Chunk.Chunk<A>, E, R> =>\n  chunks(accumulateChunks(self))\n\n/** @internal */\nexport const accumulateChunks = <A, E, R>(self: Stream.Stream<A, E, R>): Stream.Stream<A, E, R> => {\n  const accumulator = (\n    s: Chunk.Chunk<A>\n  ): Channel.Channel<Chunk.Chunk<A>, Chunk.Chunk<A>, E, E, void, unknown> =>\n    core.readWith({\n      onInput: (input: Chunk.Chunk<A>) => {\n        const next = Chunk.appendAll(s, input)\n        return core.flatMap(\n          core.write(next),\n          () => accumulator(next)\n        )\n      },\n      onFailure: core.fail,\n      onDone: () => core.void\n    })\n  return new StreamImpl(core.pipeTo(toChannel(self), accumulator(Chunk.empty())))\n}\n\n/** @internal */\nexport const acquireRelease = <A, E, R, R2, X>(\n  acquire: Effect.Effect<A, E, R>,\n  release: (resource: A, exit: Exit.Exit<unknown, unknown>) => Effect.Effect<X, never, R2>\n): Stream.Stream<A, E, R | R2> => scoped(Effect.acquireRelease(acquire, release))\n\n/** @internal */\nexport const aggregate = dual<\n  <B, A, A2, E2, R2>(\n    sink: Sink.Sink<B, A | A2, A2, E2, R2>\n  ) => <E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<B, E2 | E, R2 | R>,\n  <A, E, R, B, A2, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    sink: Sink.Sink<B, A | A2, A2, E2, R2>\n  ) => Stream.Stream<B, E2 | E, R2 | R>\n>(\n  2,\n  <A, E, R, B, A2, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    sink: Sink.Sink<B, A | A2, A2, E2, R2>\n  ): Stream.Stream<B, E2 | E, R2 | R> => aggregateWithin(self, sink, Schedule.forever)\n)\n\n/** @internal */\nexport const aggregateWithin = dual<\n  <B, A, A2, E2, R2, C, R3>(\n    sink: Sink.Sink<B, A | A2, A2, E2, R2>,\n    schedule: Schedule.Schedule<C, Option.Option<B>, R3>\n  ) => <E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<B, E2 | E, R2 | R3 | R>,\n  <A, E, R, B, A2, E2, R2, C, R3>(\n    self: Stream.Stream<A, E, R>,\n    sink: Sink.Sink<B, A | A2, A2, E2, R2>,\n    schedule: Schedule.Schedule<C, Option.Option<B>, R3>\n  ) => Stream.Stream<B, E2 | E, R2 | R3 | R>\n>(\n  3,\n  <A, E, R, B, A2, E2, R2, C, R3>(\n    self: Stream.Stream<A, E, R>,\n    sink: Sink.Sink<B, A | A2, A2, E2, R2>,\n    schedule: Schedule.Schedule<C, Option.Option<B>, R3>\n  ): Stream.Stream<B, E2 | E, R2 | R3 | R> =>\n    filterMap(\n      aggregateWithinEither(self, sink, schedule),\n      (_) =>\n        Either.match(_, {\n          onLeft: Option.none,\n          onRight: Option.some\n        })\n    )\n)\n\n/** @internal */\nexport const aggregateWithinEither = dual<\n  <B, A, A2, E2, R2, C, R3>(\n    sink: Sink.Sink<B, A | A2, A2, E2, R2>,\n    schedule: Schedule.Schedule<C, Option.Option<B>, R3>\n  ) => <E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<Either.Either<B, C>, E2 | E, R2 | R3 | R>,\n  <A, E, R, B, A2, E2, R2, C, R3>(\n    self: Stream.Stream<A, E, R>,\n    sink: Sink.Sink<B, A | A2, A2, E2, R2>,\n    schedule: Schedule.Schedule<C, Option.Option<B>, R3>\n  ) => Stream.Stream<Either.Either<B, C>, E2 | E, R2 | R3 | R>\n>(\n  3,\n  <A, E, R, B, A2, E2, R2, C, R3>(\n    self: Stream.Stream<A, E, R>,\n    sink: Sink.Sink<B, A | A2, A2, E2, R2>,\n    schedule: Schedule.Schedule<C, Option.Option<B>, R3>\n  ): Stream.Stream<Either.Either<B, C>, E2 | E, R2 | R3 | R> => {\n    const layer = Effect.all([\n      Handoff.make<HandoffSignal.HandoffSignal<A, E | E2>>(),\n      Ref.make<SinkEndReason.SinkEndReason>(SinkEndReason.ScheduleEnd),\n      Ref.make(Chunk.empty<A | A2>()),\n      Schedule.driver(schedule),\n      Ref.make(false),\n      Ref.make(false)\n    ])\n    return fromEffect(layer).pipe(\n      flatMap(([handoff, sinkEndReason, sinkLeftovers, scheduleDriver, consumed, endAfterEmit]) => {\n        const handoffProducer: Channel.Channel<never, Chunk.Chunk<A>, never, E | E2, unknown, unknown> = core\n          .readWithCause({\n            onInput: (input: Chunk.Chunk<A>) =>\n              core.flatMap(\n                core.fromEffect(pipe(\n                  handoff,\n                  Handoff.offer<HandoffSignal.HandoffSignal<A, E | E2>>(HandoffSignal.emit(input)),\n                  Effect.when(() => Chunk.isNonEmpty(input))\n                )),\n                () => handoffProducer\n              ),\n            onFailure: (cause) =>\n              core.fromEffect(\n                Handoff.offer<HandoffSignal.HandoffSignal<A, E | E2>>(\n                  handoff,\n                  HandoffSignal.halt(cause)\n                )\n              ),\n            onDone: () =>\n              core.fromEffect(\n                Handoff.offer<HandoffSignal.HandoffSignal<A, E | E2>>(\n                  handoff,\n                  HandoffSignal.end(SinkEndReason.UpstreamEnd)\n                )\n              )\n          })\n        const handoffConsumer: Channel.Channel<Chunk.Chunk<A | A2>, unknown, E | E2, unknown, void, unknown> = pipe(\n          Ref.getAndSet(sinkLeftovers, Chunk.empty()),\n          Effect.flatMap((leftovers) => {\n            if (Chunk.isNonEmpty(leftovers)) {\n              return pipe(\n                Ref.set(consumed, true),\n                Effect.zipRight(Effect.succeed(pipe(\n                  core.write(leftovers),\n                  core.flatMap(() => handoffConsumer)\n                )))\n              )\n            }\n            return pipe(\n              Handoff.take(handoff),\n              Effect.map((signal) => {\n                switch (signal._tag) {\n                  case HandoffSignal.OP_EMIT: {\n                    return pipe(\n                      core.fromEffect(Ref.set(consumed, true)),\n                      channel.zipRight(core.write(signal.elements)),\n                      channel.zipRight(core.fromEffect(Ref.get(endAfterEmit))),\n                      core.flatMap((bool) => bool ? core.void : handoffConsumer)\n                    )\n                  }\n                  case HandoffSignal.OP_HALT: {\n                    return core.failCause(signal.cause)\n                  }\n                  case HandoffSignal.OP_END: {\n                    if (signal.reason._tag === SinkEndReason.OP_SCHEDULE_END) {\n                      return pipe(\n                        Ref.get(consumed),\n                        Effect.map((bool) =>\n                          bool ?\n                            core.fromEffect(\n                              pipe(\n                                Ref.set(sinkEndReason, SinkEndReason.ScheduleEnd),\n                                Effect.zipRight(Ref.set(endAfterEmit, true))\n                              )\n                            ) :\n                            pipe(\n                              core.fromEffect(\n                                pipe(\n                                  Ref.set(sinkEndReason, SinkEndReason.ScheduleEnd),\n                                  Effect.zipRight(Ref.set(endAfterEmit, true))\n                                )\n                              ),\n                              core.flatMap(() => handoffConsumer)\n                            )\n                        ),\n                        channel.unwrap\n                      )\n                    }\n                    return pipe(\n                      Ref.set<SinkEndReason.SinkEndReason>(sinkEndReason, signal.reason),\n                      Effect.zipRight(Ref.set(endAfterEmit, true)),\n                      core.fromEffect\n                    )\n                  }\n                }\n              })\n            )\n          }),\n          channel.unwrap\n        )\n        const timeout = (lastB: Option.Option<B>): Effect.Effect<C, Option.Option<never>, R2 | R3> =>\n          scheduleDriver.next(lastB)\n        const scheduledAggregator = (\n          sinkFiber: Fiber.RuntimeFiber<readonly [Chunk.Chunk<Chunk.Chunk<A | A2>>, B], E | E2>,\n          scheduleFiber: Fiber.RuntimeFiber<C, Option.Option<never>>,\n          scope: Scope.Scope\n        ): Channel.Channel<Chunk.Chunk<Either.Either<B, C>>, unknown, E | E2, unknown, unknown, unknown, R2 | R3> => {\n          const forkSink = pipe(\n            Ref.set(consumed, false),\n            Effect.zipRight(Ref.set(endAfterEmit, false)),\n            Effect.zipRight(\n              pipe(\n                handoffConsumer,\n                channel.pipeToOrFail(sink_.toChannel(sink)),\n                core.collectElements,\n                channel.run,\n                Effect.forkIn(scope)\n              )\n            )\n          )\n          const handleSide = (\n            leftovers: Chunk.Chunk<Chunk.Chunk<A | A2>>,\n            b: B,\n            c: Option.Option<C>\n          ): Channel.Channel<Chunk.Chunk<Either.Either<B, C>>, unknown, E | E2, unknown, unknown, unknown, R2 | R3> =>\n            pipe(\n              Ref.set(sinkLeftovers, Chunk.flatten(leftovers)),\n              Effect.zipRight(\n                Effect.map(Ref.get(sinkEndReason), (reason) => {\n                  switch (reason._tag) {\n                    case SinkEndReason.OP_SCHEDULE_END: {\n                      return pipe(\n                        Effect.all([\n                          Ref.get(consumed),\n                          forkSink,\n                          pipe(timeout(Option.some(b)), Effect.forkIn(scope))\n                        ]),\n                        Effect.map(([wasConsumed, sinkFiber, scheduleFiber]) => {\n                          const toWrite = pipe(\n                            c,\n                            Option.match({\n                              onNone: (): Chunk.Chunk<Either.Either<B, C>> => Chunk.of(Either.right(b)),\n                              onSome: (c): Chunk.Chunk<Either.Either<B, C>> =>\n                                Chunk.make(Either.right(b), Either.left(c))\n                            })\n                          )\n                          if (wasConsumed) {\n                            return pipe(\n                              core.write(toWrite),\n                              core.flatMap(() => scheduledAggregator(sinkFiber, scheduleFiber, scope))\n                            )\n                          }\n                          return scheduledAggregator(sinkFiber, scheduleFiber, scope)\n                        }),\n                        channel.unwrap\n                      )\n                    }\n                    case SinkEndReason.OP_UPSTREAM_END: {\n                      return pipe(\n                        Ref.get(consumed),\n                        Effect.map((wasConsumed) =>\n                          wasConsumed ?\n                            core.write(Chunk.of<Either.Either<B, C>>(Either.right(b))) :\n                            core.void\n                        ),\n                        channel.unwrap\n                      )\n                    }\n                  }\n                })\n              ),\n              channel.unwrap\n            )\n          return channel.unwrap(\n            Effect.raceWith(Fiber.join(sinkFiber), Fiber.join(scheduleFiber), {\n              onSelfDone: (sinkExit, _) =>\n                pipe(\n                  Fiber.interrupt(scheduleFiber),\n                  Effect.zipRight(pipe(\n                    Effect.suspend(() => sinkExit),\n                    Effect.map(([leftovers, b]) => handleSide(leftovers, b, Option.none()))\n                  ))\n                ),\n              onOtherDone: (scheduleExit, _) =>\n                Effect.matchCauseEffect(Effect.suspend(() => scheduleExit), {\n                  onFailure: (cause) =>\n                    Either.match(\n                      Cause.failureOrCause(cause),\n                      {\n                        onLeft: () =>\n                          pipe(\n                            handoff,\n                            Handoff.offer<HandoffSignal.HandoffSignal<A, E | E2>>(\n                              HandoffSignal.end(SinkEndReason.ScheduleEnd)\n                            ),\n                            Effect.forkDaemon,\n                            Effect.zipRight(\n                              pipe(\n                                Fiber.join(sinkFiber),\n                                Effect.map(([leftovers, b]) => handleSide(leftovers, b, Option.none()))\n                              )\n                            )\n                          ),\n                        onRight: (cause) =>\n                          pipe(\n                            handoff,\n                            Handoff.offer<HandoffSignal.HandoffSignal<A, E | E2>>(\n                              HandoffSignal.halt(cause)\n                            ),\n                            Effect.forkDaemon,\n                            Effect.zipRight(\n                              pipe(\n                                Fiber.join(sinkFiber),\n                                Effect.map(([leftovers, b]) => handleSide(leftovers, b, Option.none()))\n                              )\n                            )\n                          )\n                      }\n                    ),\n                  onSuccess: (c) =>\n                    pipe(\n                      handoff,\n                      Handoff.offer<HandoffSignal.HandoffSignal<A, E | E2>>(\n                        HandoffSignal.end(SinkEndReason.ScheduleEnd)\n                      ),\n                      Effect.forkDaemon,\n                      Effect.zipRight(\n                        pipe(\n                          Fiber.join(sinkFiber),\n                          Effect.map(([leftovers, b]) => handleSide(leftovers, b, Option.some(c)))\n                        )\n                      )\n                    )\n                })\n            })\n          )\n        }\n        return unwrapScopedWith((scope) =>\n          core.pipeTo(toChannel(self), handoffProducer).pipe(\n            channel.run,\n            Effect.forkIn(scope),\n            Effect.zipRight(\n              channel.pipeToOrFail(handoffConsumer, sink_.toChannel(sink)).pipe(\n                core.collectElements,\n                channel.run,\n                Effect.forkIn(scope),\n                Effect.flatMap((sinkFiber) =>\n                  timeout(Option.none()).pipe(\n                    Effect.forkIn(scope),\n                    Effect.map((scheduleFiber) =>\n                      new StreamImpl(\n                        scheduledAggregator(sinkFiber, scheduleFiber, scope)\n                      )\n                    )\n                  )\n                )\n              )\n            )\n          )\n        )\n      })\n    )\n  }\n)\n\n/** @internal */\nexport const as = dual<\n  <B>(value: B) => <A, E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<B, E, R>,\n  <A, E, R, B>(self: Stream.Stream<A, E, R>, value: B) => Stream.Stream<B, E, R>\n>(2, <A, E, R, B>(self: Stream.Stream<A, E, R>, value: B): Stream.Stream<B, E, R> => map(self, () => value))\n\nconst queueFromBufferOptions = <A, E>(\n  bufferSize?: number | \"unbounded\" | {\n    readonly bufferSize?: number | undefined\n    readonly strategy?: \"dropping\" | \"sliding\" | \"suspend\" | undefined\n  } | undefined\n): Effect.Effect<Queue.Queue<Take.Take<A, E>>> => {\n  if (bufferSize === \"unbounded\") {\n    return Queue.unbounded()\n  } else if (typeof bufferSize === \"number\" || bufferSize === undefined) {\n    return Queue.bounded(bufferSize ?? 16)\n  }\n  switch (bufferSize.strategy) {\n    case \"dropping\":\n      return Queue.dropping(bufferSize.bufferSize ?? 16)\n    case \"sliding\":\n      return Queue.sliding(bufferSize.bufferSize ?? 16)\n    default:\n      return Queue.bounded(bufferSize.bufferSize ?? 16)\n  }\n}\n\n/** @internal */\nexport const _async = <A, E = never, R = never>(\n  register: (\n    emit: Emit.Emit<R, E, A, void>\n  ) => Effect.Effect<void, never, R> | void,\n  bufferSize?: number | \"unbounded\" | {\n    readonly bufferSize?: number | undefined\n    readonly strategy?: \"dropping\" | \"sliding\" | \"suspend\" | undefined\n  } | undefined\n): Stream.Stream<A, E, R> =>\n  Effect.acquireRelease(\n    queueFromBufferOptions<A, E>(bufferSize),\n    (queue) => Queue.shutdown(queue)\n  ).pipe(\n    Effect.flatMap((output) =>\n      Effect.runtime<R>().pipe(\n        Effect.flatMap((runtime) =>\n          Effect.sync(() => {\n            const runPromiseExit = Runtime.runPromiseExit(runtime)\n            const canceler = register(emit.make<R, E, A, void>((resume) =>\n              InternalTake.fromPull(resume).pipe(\n                Effect.flatMap((take) => Queue.offer(output, take)),\n                Effect.asVoid,\n                runPromiseExit\n              ).then((exit) => {\n                if (Exit.isFailure(exit)) {\n                  if (!Cause.isInterrupted(exit.cause)) {\n                    throw Cause.squash(exit.cause)\n                  }\n                }\n              })\n            ))\n            return canceler\n          })\n        ),\n        Effect.map((value) => {\n          const loop: Channel.Channel<Chunk.Chunk<A>, unknown, E, unknown, void, unknown> = Queue.take(output).pipe(\n            Effect.flatMap((take) => InternalTake.done(take)),\n            Effect.match({\n              onFailure: (maybeError) =>\n                core.fromEffect(Queue.shutdown(output)).pipe(\n                  channel.zipRight(Option.match(maybeError, {\n                    onNone: () => core.void,\n                    onSome: (error) => core.fail(error)\n                  }))\n                ),\n              onSuccess: (chunk) => core.write(chunk).pipe(core.flatMap(() => loop))\n            }),\n            channel.unwrap\n          )\n          return fromChannel(loop).pipe(ensuring(value ?? Effect.void))\n        })\n      )\n    ),\n    unwrapScoped\n  )\n\n/** @internal */\nexport const asyncEffect = <A, E = never, R = never>(\n  register: (emit: Emit.Emit<R, E, A, void>) => Effect.Effect<unknown, E, R>,\n  bufferSize?: number | \"unbounded\" | {\n    readonly bufferSize?: number | undefined\n    readonly strategy?: \"dropping\" | \"sliding\" | \"suspend\" | undefined\n  } | undefined\n): Stream.Stream<A, E, R> =>\n  pipe(\n    Effect.acquireRelease(\n      queueFromBufferOptions<A, E>(bufferSize),\n      (queue) => Queue.shutdown(queue)\n    ),\n    Effect.flatMap((output) =>\n      pipe(\n        Effect.runtime<R>(),\n        Effect.flatMap((runtime) =>\n          pipe(\n            register(\n              emit.make((k) =>\n                pipe(\n                  InternalTake.fromPull(k),\n                  Effect.flatMap((take) => Queue.offer(output, take)),\n                  Effect.asVoid,\n                  Runtime.runPromiseExit(runtime)\n                ).then((exit) => {\n                  if (Exit.isFailure(exit)) {\n                    if (!Cause.isInterrupted(exit.cause)) {\n                      throw Cause.squash(exit.cause)\n                    }\n                  }\n                })\n              )\n            ),\n            Effect.map(() => {\n              const loop: Channel.Channel<Chunk.Chunk<A>, unknown, E, unknown, void, unknown> = pipe(\n                Queue.take(output),\n                Effect.flatMap(InternalTake.done),\n                Effect.match({\n                  onFailure: (maybeError) =>\n                    pipe(\n                      core.fromEffect(Queue.shutdown(output)),\n                      channel.zipRight(Option.match(maybeError, { onNone: () => core.void, onSome: core.fail }))\n                    ),\n                  onSuccess: (chunk) => pipe(core.write(chunk), core.flatMap(() => loop))\n                }),\n                channel.unwrap\n              )\n              return loop\n            })\n          )\n        )\n      )\n    ),\n    channel.unwrapScoped,\n    fromChannel\n  )\n\nconst queueFromBufferOptionsPush = <A, E>(\n  options?: { readonly bufferSize: \"unbounded\" } | {\n    readonly bufferSize?: number | undefined\n    readonly strategy?: \"dropping\" | \"sliding\" | undefined\n  } | undefined\n): Effect.Effect<Queue.Queue<Array<A> | Exit.Exit<void, E>>> => {\n  if (options?.bufferSize === \"unbounded\" || (options?.bufferSize === undefined && options?.strategy === undefined)) {\n    return Queue.unbounded()\n  }\n  switch (options?.strategy) {\n    case \"sliding\":\n      return Queue.sliding(options.bufferSize ?? 16)\n    default:\n      return Queue.dropping(options?.bufferSize ?? 16)\n  }\n}\n\n/** @internal */\nexport const asyncPush = <A, E = never, R = never>(\n  register: (emit: Emit.EmitOpsPush<E, A>) => Effect.Effect<unknown, E, R | Scope.Scope>,\n  options?: {\n    readonly bufferSize: \"unbounded\"\n  } | {\n    readonly bufferSize?: number | undefined\n    readonly strategy?: \"dropping\" | \"sliding\" | undefined\n  } | undefined\n): Stream.Stream<A, E, Exclude<R, Scope.Scope>> =>\n  Effect.acquireRelease(\n    queueFromBufferOptionsPush<A, E>(options),\n    Queue.shutdown\n  ).pipe(\n    Effect.tap((queue) =>\n      FiberRef.getWith(FiberRef.currentScheduler, (scheduler) => register(emit.makePush(queue, scheduler)))\n    ),\n    Effect.map((queue) => {\n      const loop: Channel.Channel<Chunk.Chunk<A>, unknown, E> = core.flatMap(Queue.take(queue), (item) =>\n        Exit.isExit(item)\n          ? Exit.isSuccess(item) ? core.void : core.failCause(item.cause)\n          : channel.zipRight(core.write(Chunk.unsafeFromArray(item)), loop))\n      return loop\n    }),\n    channel.unwrapScoped,\n    fromChannel\n  )\n\n/** @internal */\nexport const asyncScoped = <A, E = never, R = never>(\n  register: (emit: Emit.Emit<R, E, A, void>) => Effect.Effect<unknown, E, R | Scope.Scope>,\n  bufferSize?: number | \"unbounded\" | {\n    readonly bufferSize?: number | undefined\n    readonly strategy?: \"dropping\" | \"sliding\" | \"suspend\" | undefined\n  } | undefined\n): Stream.Stream<A, E, Exclude<R, Scope.Scope>> =>\n  pipe(\n    Effect.acquireRelease(\n      queueFromBufferOptions<A, E>(bufferSize),\n      (queue) => Queue.shutdown(queue)\n    ),\n    Effect.flatMap((output) =>\n      pipe(\n        Effect.runtime<R>(),\n        Effect.flatMap((runtime) =>\n          pipe(\n            register(\n              emit.make((k) =>\n                pipe(\n                  InternalTake.fromPull(k),\n                  Effect.flatMap((take) => Queue.offer(output, take)),\n                  Effect.asVoid,\n                  Runtime.runPromiseExit(runtime)\n                ).then((exit) => {\n                  if (Exit.isFailure(exit)) {\n                    if (!Cause.isInterrupted(exit.cause)) {\n                      throw Cause.squash(exit.cause)\n                    }\n                  }\n                })\n              )\n            ),\n            Effect.zipRight(Ref.make(false)),\n            Effect.flatMap((ref) =>\n              pipe(\n                Ref.get(ref),\n                Effect.map((isDone) =>\n                  isDone ?\n                    pull.end() :\n                    pipe(\n                      Queue.take(output),\n                      Effect.flatMap(InternalTake.done),\n                      Effect.onError(() =>\n                        pipe(\n                          Ref.set(ref, true),\n                          Effect.zipRight(Queue.shutdown(output))\n                        )\n                      )\n                    )\n                )\n              )\n            )\n          )\n        )\n      )\n    ),\n    scoped,\n    flatMap(repeatEffectChunkOption)\n  )\n\n/** @internal */\nexport const branchAfter = dual<\n  <A, A2, E2, R2>(\n    n: number,\n    f: (input: Chunk.Chunk<A>) => Stream.Stream<A2, E2, R2>\n  ) => <E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A2, E2 | E, R2 | R>,\n  <A, E, R, A2, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    n: number,\n    f: (input: Chunk.Chunk<A>) => Stream.Stream<A2, E2, R2>\n  ) => Stream.Stream<A2, E2 | E, R2 | R>\n>(\n  3,\n  <A, E, R, A2, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    n: number,\n    f: (input: Chunk.Chunk<A>) => Stream.Stream<A2, E2, R2>\n  ) =>\n    suspend(() => {\n      const buffering = (\n        acc: Chunk.Chunk<A>\n      ): Channel.Channel<Chunk.Chunk<A2>, Chunk.Chunk<A>, E2, never, unknown, unknown, R | R2> =>\n        core.readWith({\n          onInput: (input) => {\n            const nextSize = acc.length + input.length\n            if (nextSize >= n) {\n              const [b1, b2] = pipe(input, Chunk.splitAt(n - acc.length))\n              return running(pipe(acc, Chunk.appendAll(b1)), b2)\n            }\n            return buffering(pipe(acc, Chunk.appendAll(input)))\n          },\n          onFailure: core.fail,\n          onDone: () => running(acc, Chunk.empty())\n        })\n      const running = (\n        prefix: Chunk.Chunk<A>,\n        leftover: Chunk.Chunk<A>\n      ): Channel.Channel<Chunk.Chunk<A2>, Chunk.Chunk<A>, E2, never, unknown, unknown, R | R2> =>\n        core.pipeTo(\n          channel.zipRight(\n            core.write(leftover),\n            channel.identityChannel()\n          ),\n          toChannel(f(prefix))\n        )\n      return new StreamImpl(pipe(toChannel(self), channel.pipeToOrFail(buffering(Chunk.empty<A>()))))\n    })\n)\n\n/** @internal */\nexport const broadcast = dual<\n  <N extends number>(\n    n: N,\n    maximumLag: number | {\n      readonly capacity: \"unbounded\"\n      readonly replay?: number | undefined\n    } | {\n      readonly capacity: number\n      readonly strategy?: \"sliding\" | \"dropping\" | \"suspend\" | undefined\n      readonly replay?: number | undefined\n    }\n  ) => <A, E, R>(\n    self: Stream.Stream<A, E, R>\n  ) => Effect.Effect<Types.TupleOf<N, Stream.Stream<A, E>>, never, Scope.Scope | R>,\n  <A, E, R, N extends number>(\n    self: Stream.Stream<A, E, R>,\n    n: N,\n    maximumLag: number | {\n      readonly capacity: \"unbounded\"\n      readonly replay?: number | undefined\n    } | {\n      readonly capacity: number\n      readonly strategy?: \"sliding\" | \"dropping\" | \"suspend\" | undefined\n      readonly replay?: number | undefined\n    }\n  ) => Effect.Effect<Types.TupleOf<N, Stream.Stream<A, E>>, never, Scope.Scope | R>\n>(3, <A, E, R, N extends number>(\n  self: Stream.Stream<A, E, R>,\n  n: N,\n  maximumLag: number | {\n    readonly capacity: \"unbounded\"\n    readonly replay?: number | undefined\n  } | {\n    readonly capacity: number\n    readonly strategy?: \"sliding\" | \"dropping\" | \"suspend\" | undefined\n    readonly replay?: number | undefined\n  }\n): Effect.Effect<Types.TupleOf<N, Stream.Stream<A, E>>, never, Scope.Scope | R> =>\n  pipe(\n    self,\n    broadcastedQueues(n, maximumLag),\n    Effect.map((tuple) =>\n      tuple.map((queue) => flattenTake(fromQueue(queue, { shutdown: true }))) as Types.TupleOf<N, Stream.Stream<A, E>>\n    )\n  ))\n\n/** @internal */\nexport const broadcastDynamic = dual<\n  (\n    maximumLag: number | {\n      readonly capacity: \"unbounded\"\n      readonly replay?: number | undefined\n    } | {\n      readonly capacity: number\n      readonly strategy?: \"sliding\" | \"dropping\" | \"suspend\" | undefined\n      readonly replay?: number | undefined\n    }\n  ) => <A, E, R>(self: Stream.Stream<A, E, R>) => Effect.Effect<Stream.Stream<A, E>, never, Scope.Scope | R>,\n  <A, E, R>(\n    self: Stream.Stream<A, E, R>,\n    maximumLag: number | {\n      readonly capacity: \"unbounded\"\n      readonly replay?: number | undefined\n    } | {\n      readonly capacity: number\n      readonly strategy?: \"sliding\" | \"dropping\" | \"suspend\" | undefined\n      readonly replay?: number | undefined\n    }\n  ) => Effect.Effect<Stream.Stream<A, E>, never, Scope.Scope | R>\n>(2, <A, E, R>(\n  self: Stream.Stream<A, E, R>,\n  maximumLag: number | {\n    readonly capacity: \"unbounded\"\n    readonly replay?: number | undefined\n  } | {\n    readonly capacity: number\n    readonly strategy?: \"sliding\" | \"dropping\" | \"suspend\" | undefined\n    readonly replay?: number | undefined\n  }\n): Effect.Effect<Stream.Stream<A, E>, never, Scope.Scope | R> =>\n  Effect.map(toPubSub(self, maximumLag), (pubsub) => flattenTake(fromPubSub(pubsub))))\n\nexport const share = dual<\n  <A, E>(\n    config: {\n      readonly capacity: \"unbounded\"\n      readonly replay?: number | undefined\n      readonly idleTimeToLive?: Duration.DurationInput | undefined\n    } | {\n      readonly capacity: number\n      readonly strategy?: \"sliding\" | \"dropping\" | \"suspend\" | undefined\n      readonly replay?: number | undefined\n      readonly idleTimeToLive?: Duration.DurationInput | undefined\n    }\n  ) => <R>(\n    self: Stream.Stream<A, E, R>\n  ) => Effect.Effect<Stream.Stream<A, E>, never, R | Scope.Scope>,\n  <A, E, R>(\n    self: Stream.Stream<A, E, R>,\n    config: {\n      readonly capacity: \"unbounded\"\n      readonly replay?: number | undefined\n      readonly idleTimeToLive?: Duration.DurationInput | undefined\n    } | {\n      readonly capacity: number\n      readonly strategy?: \"sliding\" | \"dropping\" | \"suspend\" | undefined\n      readonly replay?: number | undefined\n      readonly idleTimeToLive?: Duration.DurationInput | undefined\n    }\n  ) => Effect.Effect<Stream.Stream<A, E>, never, R | Scope.Scope>\n>(\n  2,\n  <A, E, R>(\n    self: Stream.Stream<A, E, R>,\n    options: {\n      readonly capacity: \"unbounded\"\n      readonly replay?: number | undefined\n      readonly idleTimeToLive?: Duration.DurationInput | undefined\n    } | {\n      readonly capacity: number\n      readonly strategy?: \"sliding\" | \"dropping\" | \"suspend\" | undefined\n      readonly replay?: number | undefined\n      readonly idleTimeToLive?: Duration.DurationInput | undefined\n    }\n  ): Effect.Effect<Stream.Stream<A, E>, never, R | Scope.Scope> =>\n    Effect.map(\n      RcRef.make({\n        acquire: broadcastDynamic(self, options),\n        idleTimeToLive: options.idleTimeToLive\n      }),\n      (rcRef) => unwrapScoped(RcRef.get(rcRef))\n    )\n)\n\n/** @internal */\nexport const broadcastedQueues = dual<\n  <N extends number>(\n    n: N,\n    maximumLag: number | {\n      readonly capacity: \"unbounded\"\n      readonly replay?: number | undefined\n    } | {\n      readonly capacity: number\n      readonly strategy?: \"sliding\" | \"dropping\" | \"suspend\" | undefined\n      readonly replay?: number | undefined\n    }\n  ) => <A, E, R>(\n    self: Stream.Stream<A, E, R>\n  ) => Effect.Effect<Types.TupleOf<N, Queue.Dequeue<Take.Take<A, E>>>, never, Scope.Scope | R>,\n  <A, E, R, N extends number>(\n    self: Stream.Stream<A, E, R>,\n    n: N,\n    maximumLag: number | {\n      readonly capacity: \"unbounded\"\n      readonly replay?: number | undefined\n    } | {\n      readonly capacity: number\n      readonly strategy?: \"sliding\" | \"dropping\" | \"suspend\" | undefined\n      readonly replay?: number | undefined\n    }\n  ) => Effect.Effect<Types.TupleOf<N, Queue.Dequeue<Take.Take<A, E>>>, never, Scope.Scope | R>\n>(3, <A, E, R, N extends number>(\n  self: Stream.Stream<A, E, R>,\n  n: N,\n  maximumLag: number | {\n    readonly capacity: \"unbounded\"\n    readonly replay?: number | undefined\n  } | {\n    readonly capacity: number\n    readonly strategy?: \"sliding\" | \"dropping\" | \"suspend\" | undefined\n    readonly replay?: number | undefined\n  }\n): Effect.Effect<Types.TupleOf<N, Queue.Dequeue<Take.Take<A, E>>>, never, Scope.Scope | R> =>\n  Effect.flatMap(pubsubFromOptions(maximumLag), (pubsub) =>\n    pipe(\n      Effect.all(Array.from({ length: n }, () => PubSub.subscribe(pubsub))) as Effect.Effect<\n        Types.TupleOf<N, Queue.Dequeue<Take.Take<A, E>>>,\n        never,\n        R\n      >,\n      Effect.tap(() => Effect.forkScoped(runIntoPubSubScoped(self, pubsub)))\n    )))\n\n/** @internal */\nexport const broadcastedQueuesDynamic = dual<\n  (\n    maximumLag: number | {\n      readonly capacity: \"unbounded\"\n      readonly replay?: number | undefined\n    } | {\n      readonly capacity: number\n      readonly strategy?: \"sliding\" | \"dropping\" | \"suspend\" | undefined\n      readonly replay?: number | undefined\n    }\n  ) => <A, E, R>(\n    self: Stream.Stream<A, E, R>\n  ) => Effect.Effect<Effect.Effect<Queue.Dequeue<Take.Take<A, E>>, never, Scope.Scope>, never, Scope.Scope | R>,\n  <A, E, R>(\n    self: Stream.Stream<A, E, R>,\n    maximumLag: number | {\n      readonly capacity: \"unbounded\"\n      readonly replay?: number | undefined\n    } | {\n      readonly capacity: number\n      readonly strategy?: \"sliding\" | \"dropping\" | \"suspend\" | undefined\n      readonly replay?: number | undefined\n    }\n  ) => Effect.Effect<Effect.Effect<Queue.Dequeue<Take.Take<A, E>>, never, Scope.Scope>, never, Scope.Scope | R>\n>(2, <A, E, R>(\n  self: Stream.Stream<A, E, R>,\n  maximumLag: number | {\n    readonly capacity: \"unbounded\"\n    readonly replay?: number | undefined\n  } | {\n    readonly capacity: number\n    readonly strategy?: \"sliding\" | \"dropping\" | \"suspend\" | undefined\n    readonly replay?: number | undefined\n  }\n): Effect.Effect<Effect.Effect<Queue.Dequeue<Take.Take<A, E>>, never, Scope.Scope>, never, Scope.Scope | R> =>\n  Effect.map(toPubSub(self, maximumLag), PubSub.subscribe))\n\n/** @internal */\nexport const buffer = dual<\n  (\n    options: {\n      readonly capacity: \"unbounded\"\n    } | {\n      readonly capacity: number\n      readonly strategy?: \"dropping\" | \"sliding\" | \"suspend\" | undefined\n    }\n  ) => <A, E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A, E, R>,\n  <A, E, R>(\n    self: Stream.Stream<A, E, R>,\n    options: {\n      readonly capacity: \"unbounded\"\n    } | {\n      readonly capacity: number\n      readonly strategy?: \"dropping\" | \"sliding\" | \"suspend\" | undefined\n    }\n  ) => Stream.Stream<A, E, R>\n>(2, <A, E, R>(\n  self: Stream.Stream<A, E, R>,\n  options: {\n    readonly capacity: \"unbounded\"\n  } | {\n    readonly capacity: number\n    readonly strategy?: \"dropping\" | \"sliding\" | \"suspend\" | undefined\n  }\n): Stream.Stream<A, E, R> => {\n  if (options.capacity === \"unbounded\") {\n    return bufferUnbounded(self)\n  } else if (options.strategy === \"dropping\") {\n    return bufferDropping(self, options.capacity)\n  } else if (options.strategy === \"sliding\") {\n    return bufferSliding(self, options.capacity)\n  }\n  const queue = toQueueOfElements(self, options)\n  return new StreamImpl(\n    channel.unwrapScoped(\n      Effect.map(queue, (queue) => {\n        const process: Channel.Channel<Chunk.Chunk<A>, unknown, E, unknown, void, unknown> = pipe(\n          core.fromEffect(Queue.take(queue)),\n          core.flatMap(Exit.match({\n            onFailure: (cause) =>\n              pipe(\n                Cause.flipCauseOption(cause),\n                Option.match({ onNone: () => core.void, onSome: core.failCause })\n              ),\n            onSuccess: (value) => core.flatMap(core.write(Chunk.of(value)), () => process)\n          }))\n        )\n        return process\n      })\n    )\n  )\n})\n\n/** @internal */\nexport const bufferChunks = dual<\n  (options: {\n    readonly capacity: number\n    readonly strategy?: \"dropping\" | \"sliding\" | \"suspend\" | undefined\n  }) => <A, E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A, E, R>,\n  <A, E, R>(self: Stream.Stream<A, E, R>, options: {\n    readonly capacity: number\n    readonly strategy?: \"dropping\" | \"sliding\" | \"suspend\" | undefined\n  }) => Stream.Stream<A, E, R>\n>(2, <A, E, R>(self: Stream.Stream<A, E, R>, options: {\n  readonly capacity: number\n  readonly strategy?: \"dropping\" | \"sliding\" | \"suspend\" | undefined\n}): Stream.Stream<A, E, R> => {\n  if (options.strategy === \"dropping\") {\n    return bufferChunksDropping(self, options.capacity)\n  } else if (options.strategy === \"sliding\") {\n    return bufferChunksSliding(self, options.capacity)\n  }\n  const queue = toQueue(self, options)\n  return new StreamImpl(\n    channel.unwrapScoped(\n      Effect.map(queue, (queue) => {\n        const process: Channel.Channel<Chunk.Chunk<A>, unknown, E, unknown, void, unknown> = pipe(\n          core.fromEffect(Queue.take(queue)),\n          core.flatMap(InternalTake.match({\n            onEnd: () => core.void,\n            onFailure: core.failCause,\n            onSuccess: (value) => pipe(core.write(value), core.flatMap(() => process))\n          }))\n        )\n        return process\n      })\n    )\n  )\n})\n\nconst bufferChunksDropping = dual<\n  (capacity: number) => <A, E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A, E, R>,\n  <A, E, R>(self: Stream.Stream<A, E, R>, capacity: number) => Stream.Stream<A, E, R>\n>(2, <A, E, R>(self: Stream.Stream<A, E, R>, capacity: number): Stream.Stream<A, E, R> => {\n  const queue = Effect.acquireRelease(\n    Queue.dropping<readonly [Take.Take<A, E>, Deferred.Deferred<void>]>(capacity),\n    (queue) => Queue.shutdown(queue)\n  )\n  return new StreamImpl(bufferSignal(queue, toChannel(self)))\n})\n\nconst bufferChunksSliding = dual<\n  (capacity: number) => <A, E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A, E, R>,\n  <A, E, R>(self: Stream.Stream<A, E, R>, capacity: number) => Stream.Stream<A, E, R>\n>(2, <A, E, R>(self: Stream.Stream<A, E, R>, capacity: number): Stream.Stream<A, E, R> => {\n  const queue = Effect.acquireRelease(\n    Queue.sliding<readonly [Take.Take<A, E>, Deferred.Deferred<void>]>(capacity),\n    (queue) => Queue.shutdown(queue)\n  )\n  return new StreamImpl(bufferSignal(queue, toChannel(self)))\n})\n\nconst bufferDropping = dual<\n  (capacity: number) => <A, E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A, E, R>,\n  <A, E, R>(self: Stream.Stream<A, E, R>, capacity: number) => Stream.Stream<A, E, R>\n>(2, <A, E, R>(self: Stream.Stream<A, E, R>, capacity: number): Stream.Stream<A, E, R> => {\n  const queue = Effect.acquireRelease(\n    Queue.dropping<readonly [Take.Take<A, E>, Deferred.Deferred<void>]>(capacity),\n    (queue) => Queue.shutdown(queue)\n  )\n  return new StreamImpl(bufferSignal(queue, toChannel(rechunk(1)(self))))\n})\n\nconst bufferSliding = dual<\n  (capacity: number) => <A, E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A, E, R>,\n  <A, E, R>(self: Stream.Stream<A, E, R>, capacity: number) => Stream.Stream<A, E, R>\n>(2, <A, E, R>(self: Stream.Stream<A, E, R>, capacity: number): Stream.Stream<A, E, R> => {\n  const queue = Effect.acquireRelease(\n    Queue.sliding<readonly [Take.Take<A, E>, Deferred.Deferred<void>]>(capacity),\n    (queue) => Queue.shutdown(queue)\n  )\n  return new StreamImpl(bufferSignal(queue, toChannel(pipe(self, rechunk(1)))))\n})\n\nconst bufferUnbounded = <A, E, R>(self: Stream.Stream<A, E, R>): Stream.Stream<A, E, R> => {\n  const queue = toQueue(self, { strategy: \"unbounded\" })\n  return new StreamImpl(\n    channel.unwrapScoped(\n      Effect.map(queue, (queue) => {\n        const process: Channel.Channel<Chunk.Chunk<A>, unknown, E, unknown, void, unknown> = pipe(\n          core.fromEffect(Queue.take(queue)),\n          core.flatMap(InternalTake.match({\n            onEnd: () => core.void,\n            onFailure: core.failCause,\n            onSuccess: (value) => core.flatMap(core.write(value), () => process)\n          }))\n        )\n        return process\n      })\n    )\n  )\n}\n\nconst bufferSignal = <A, E, R>(\n  scoped: Effect.Effect<Queue.Queue<readonly [Take.Take<A, E>, Deferred.Deferred<void>]>, never, Scope.Scope>,\n  bufferChannel: Channel.Channel<Chunk.Chunk<A>, unknown, E, unknown, void, unknown, R>\n): Channel.Channel<Chunk.Chunk<A>, unknown, E, unknown, void, unknown, R> => {\n  const producer = (\n    queue: Queue.Queue<readonly [Take.Take<A, E>, Deferred.Deferred<void>]>,\n    ref: Ref.Ref<Deferred.Deferred<void>>\n  ): Channel.Channel<never, Chunk.Chunk<A>, never, E, unknown, unknown, R> => {\n    const terminate = (take: Take.Take<A, E>): Channel.Channel<never, Chunk.Chunk<A>, never, E, unknown, unknown, R> =>\n      pipe(\n        Ref.get(ref),\n        Effect.tap(Deferred.await),\n        Effect.zipRight(Deferred.make<void>()),\n        Effect.flatMap((deferred) =>\n          pipe(\n            Queue.offer(queue, [take, deferred] as const),\n            Effect.zipRight(Ref.set(ref, deferred)),\n            Effect.zipRight(Deferred.await(deferred))\n          )\n        ),\n        Effect.asVoid,\n        core.fromEffect\n      )\n    return core.readWithCause({\n      onInput: (input: Chunk.Chunk<A>) =>\n        pipe(\n          Deferred.make<void>(),\n          Effect.flatMap(\n            (deferred) =>\n              pipe(\n                Queue.offer(queue, [InternalTake.chunk(input), deferred] as const),\n                Effect.flatMap((added) => pipe(Ref.set(ref, deferred), Effect.when(() => added)))\n              )\n          ),\n          Effect.asVoid,\n          core.fromEffect,\n          core.flatMap(() => producer(queue, ref))\n        ),\n      onFailure: (error) => terminate(InternalTake.failCause(error)),\n      onDone: () => terminate(InternalTake.end)\n    })\n  }\n  const consumer = (\n    queue: Queue.Queue<readonly [Take.Take<A, E>, Deferred.Deferred<void>]>\n  ): Channel.Channel<Chunk.Chunk<A>, unknown, E, unknown, void, unknown, R> => {\n    const process: Channel.Channel<Chunk.Chunk<A>, unknown, E, unknown, void, unknown> = pipe(\n      core.fromEffect(Queue.take(queue)),\n      core.flatMap(([take, deferred]) =>\n        channel.zipRight(\n          core.fromEffect(Deferred.succeed(deferred, void 0)),\n          InternalTake.match(take, {\n            onEnd: () => core.void,\n            onFailure: core.failCause,\n            onSuccess: (value) => pipe(core.write(value), core.flatMap(() => process))\n          })\n        )\n      )\n    )\n    return process\n  }\n  return channel.unwrapScoped(\n    pipe(\n      scoped,\n      Effect.flatMap((queue) =>\n        pipe(\n          Deferred.make<void>(),\n          Effect.tap((start) => Deferred.succeed(start, void 0)),\n          Effect.flatMap((start) =>\n            pipe(\n              Ref.make(start),\n              Effect.flatMap((ref) =>\n                pipe(\n                  bufferChannel,\n                  core.pipeTo(producer(queue, ref)),\n                  channel.runScoped,\n                  Effect.forkScoped\n                )\n              ),\n              Effect.as(consumer(queue))\n            )\n          )\n        )\n      )\n    )\n  )\n}\n\n/** @internal */\nexport const catchAll = dual<\n  <E, A2, E2, R2>(\n    f: (error: E) => Stream.Stream<A2, E2, R2>\n  ) => <A, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A2 | A, E2, R2 | R>,\n  <A, E, R, A2, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    f: (error: E) => Stream.Stream<A2, E2, R2>\n  ) => Stream.Stream<A2 | A, E2, R2 | R>\n>(2, <A, E, R, A2, E2, R2>(\n  self: Stream.Stream<A, E, R>,\n  f: (error: E) => Stream.Stream<A2, E2, R2>\n): Stream.Stream<A2 | A, E2, R2 | R> =>\n  catchAllCause(self, (cause) =>\n    Either.match(Cause.failureOrCause(cause), {\n      onLeft: f,\n      onRight: failCause\n    })))\n\n/** @internal */\nexport const catchAllCause = dual<\n  <E, A2, E2, R2>(\n    f: (cause: Cause.Cause<E>) => Stream.Stream<A2, E2, R2>\n  ) => <A, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A2 | A, E2, R2 | R>,\n  <A, E, R, A2, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    f: (cause: Cause.Cause<E>) => Stream.Stream<A2, E2, R2>\n  ) => Stream.Stream<A2 | A, E2, R2 | R>\n>(\n  2,\n  <A, E, R, A2, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    f: (cause: Cause.Cause<E>) => Stream.Stream<A2, E2, R2>\n  ): Stream.Stream<A | A2, E2, R | R2> =>\n    new StreamImpl<A | A2, E2, R | R2>(pipe(toChannel(self), core.catchAllCause((cause) => toChannel(f(cause)))))\n)\n\n/** @internal */\nexport const catchSome = dual<\n  <E, A2, E2, R2>(\n    pf: (error: E) => Option.Option<Stream.Stream<A2, E2, R2>>\n  ) => <A, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A2 | A, E | E2, R2 | R>,\n  <A, E, R, A2, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    pf: (error: E) => Option.Option<Stream.Stream<A2, E2, R2>>\n  ) => Stream.Stream<A2 | A, E | E2, R2 | R>\n>(\n  2,\n  <A, E, R, A2, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    pf: (error: E) => Option.Option<Stream.Stream<A2, E2, R2>>\n  ): Stream.Stream<A2 | A, E | E2, R2 | R> =>\n    pipe(self, catchAll((error) => pipe(pf(error), Option.getOrElse(() => fail<E | E2>(error)))))\n)\n\n/** @internal */\nexport const catchSomeCause = dual<\n  <E, A2, E2, R2>(\n    pf: (cause: Cause.Cause<E>) => Option.Option<Stream.Stream<A2, E2, R2>>\n  ) => <A, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A2 | A, E | E2, R2 | R>,\n  <A, E, R, A2, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    pf: (cause: Cause.Cause<E>) => Option.Option<Stream.Stream<A2, E2, R2>>\n  ) => Stream.Stream<A2 | A, E | E2, R2 | R>\n>(\n  2,\n  <A, E, R, A2, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    pf: (cause: Cause.Cause<E>) => Option.Option<Stream.Stream<A2, E2, R2>>\n  ): Stream.Stream<A2 | A, E | E2, R2 | R> =>\n    pipe(self, catchAllCause((cause) => pipe(pf(cause), Option.getOrElse(() => failCause<E | E2>(cause)))))\n)\n\n/* @internal */\nexport const catchTag = dual<\n  <K extends E[\"_tag\"] & string, E extends { _tag: string }, A1, E1, R1>(\n    k: K,\n    f: (e: Extract<E, { _tag: K }>) => Stream.Stream<A1, E1, R1>\n  ) => <A, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A | A1, Exclude<E, { _tag: K }> | E1, R | R1>,\n  <A, E extends { _tag: string }, R, K extends E[\"_tag\"] & string, A1, E1, R1>(\n    self: Stream.Stream<A, E, R>,\n    k: K,\n    f: (e: Extract<E, { _tag: K }>) => Stream.Stream<A1, E1, R1>\n  ) => Stream.Stream<A | A1, Exclude<E, { _tag: K }> | E1, R | R1>\n>(3, (self, k, f) =>\n  catchAll(self, (e) => {\n    if (\"_tag\" in e && e[\"_tag\"] === k) {\n      return f(e as any)\n    }\n    return fail(e as any)\n  }))\n\n/** @internal */\nexport const catchTags: {\n  <\n    E extends { _tag: string },\n    Cases extends {\n      [K in E[\"_tag\"]]+?: (error: Extract<E, { _tag: K }>) => Stream.Stream<any, any, any>\n    }\n  >(\n    cases: Cases\n  ): <A, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<\n    | A\n    | {\n      [K in keyof Cases]: Cases[K] extends\n        ((...args: Array<any>) => Stream.Stream.Variance<infer A, infer _E, infer _R>) ? A\n        : never\n    }[keyof Cases],\n    | Exclude<E, { _tag: keyof Cases }>\n    | {\n      [K in keyof Cases]: Cases[K] extends\n        ((...args: Array<any>) => Stream.Stream.Variance<infer _A, infer E, infer _R>) ? E\n        : never\n    }[keyof Cases],\n    | R\n    | {\n      [K in keyof Cases]: Cases[K] extends\n        ((...args: Array<any>) => Stream.Stream.Variance<infer _A, infer _E, infer R>) ? R\n        : never\n    }[keyof Cases]\n  >\n  <\n    A,\n    E extends { _tag: string },\n    R,\n    Cases extends {\n      [K in E[\"_tag\"]]+?: (error: Extract<E, { _tag: K }>) => Stream.Stream<any, any, any>\n    }\n  >(\n    self: Stream.Stream<A, E, R>,\n    cases: Cases\n  ): Stream.Stream<\n    | A\n    | {\n      [K in keyof Cases]: Cases[K] extends\n        ((...args: Array<any>) => Stream.Stream.Variance<infer _R, infer _E, infer A>) ? A\n        : never\n    }[keyof Cases],\n    | Exclude<E, { _tag: keyof Cases }>\n    | {\n      [K in keyof Cases]: Cases[K] extends\n        ((...args: Array<any>) => Stream.Stream.Variance<infer _R, infer E, infer _A>) ? E\n        : never\n    }[keyof Cases],\n    | R\n    | {\n      [K in keyof Cases]: Cases[K] extends\n        ((...args: Array<any>) => Stream.Stream.Variance<infer R, infer _E, infer _A>) ? R\n        : never\n    }[keyof Cases]\n  >\n} = dual(2, (self, cases) =>\n  catchAll(self, (e: any) => {\n    const keys = Object.keys(cases)\n    if (\"_tag\" in e && keys.includes(e[\"_tag\"])) {\n      return cases[e[\"_tag\"]](e as any)\n    }\n    return fail(e as any)\n  }))\n\n/** @internal */\nexport const changes = <A, E, R>(self: Stream.Stream<A, E, R>): Stream.Stream<A, E, R> =>\n  pipe(self, changesWith((x, y) => Equal.equals(y)(x)))\n\n/** @internal */\nexport const changesWith = dual<\n  <A>(f: (x: A, y: A) => boolean) => <E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A, E, R>,\n  <A, E, R>(self: Stream.Stream<A, E, R>, f: (x: A, y: A) => boolean) => Stream.Stream<A, E, R>\n>(2, <A, E, R>(self: Stream.Stream<A, E, R>, f: (x: A, y: A) => boolean): Stream.Stream<A, E, R> => {\n  const writer = (\n    last: Option.Option<A>\n  ): Channel.Channel<Chunk.Chunk<A>, Chunk.Chunk<A>, E, E, void, unknown> =>\n    core.readWithCause({\n      onInput: (input: Chunk.Chunk<A>) => {\n        const [newLast, newChunk] = Chunk.reduce(\n          input,\n          [last, Chunk.empty<A>()] as const,\n          ([option, outputs], output) => {\n            if (Option.isSome(option) && f(option.value, output)) {\n              return [Option.some(output), outputs] as const\n            }\n            return [Option.some(output), pipe(outputs, Chunk.append(output))] as const\n          }\n        )\n        return core.flatMap(\n          core.write(newChunk),\n          () => writer(newLast)\n        )\n      },\n      onFailure: core.failCause,\n      onDone: () => core.void\n    })\n  return new StreamImpl(pipe(toChannel(self), core.pipeTo(writer(Option.none()))))\n})\n\n/** @internal */\nexport const changesWithEffect = dual<\n  <A, E2, R2>(\n    f: (x: A, y: A) => Effect.Effect<boolean, E2, R2>\n  ) => <E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A, E2 | E, R2 | R>,\n  <A, E, R, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    f: (x: A, y: A) => Effect.Effect<boolean, E2, R2>\n  ) => Stream.Stream<A, E2 | E, R2 | R>\n>(\n  2,\n  <A, E, R, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    f: (x: A, y: A) => Effect.Effect<boolean, E2, R2>\n  ): Stream.Stream<A, E2 | E, R2 | R> => {\n    const writer = (\n      last: Option.Option<A>\n    ): Channel.Channel<Chunk.Chunk<A>, Chunk.Chunk<A>, E | E2, E | E2, void, unknown, R | R2> =>\n      core.readWithCause({\n        onInput: (input: Chunk.Chunk<A>) =>\n          pipe(\n            input,\n            Effect.reduce([last, Chunk.empty<A>()] as const, ([option, outputs], output) => {\n              if (Option.isSome(option)) {\n                return pipe(\n                  f(option.value, output),\n                  Effect.map((bool) =>\n                    bool ?\n                      [Option.some(output), outputs] as const :\n                      [Option.some(output), pipe(outputs, Chunk.append(output))] as const\n                  )\n                )\n              }\n              return Effect.succeed(\n                [\n                  Option.some(output),\n                  pipe(outputs, Chunk.append(output))\n                ] as const\n              )\n            }),\n            core.fromEffect,\n            core.flatMap(([newLast, newChunk]) =>\n              pipe(\n                core.write(newChunk),\n                core.flatMap(() => writer(newLast))\n              )\n            )\n          ),\n        onFailure: core.failCause,\n        onDone: () => core.void\n      })\n    return new StreamImpl(pipe(toChannel(self), core.pipeTo(writer(Option.none()))))\n  }\n)\n\n/** @internal */\nexport const chunks = <A, E, R>(self: Stream.Stream<A, E, R>): Stream.Stream<Chunk.Chunk<A>, E, R> =>\n  pipe(self, mapChunks(Chunk.of))\n\n/** @internal */\nexport const chunksWith = dual<\n  <A, E, R, A2, E2, R2>(\n    f: (stream: Stream.Stream<Chunk.Chunk<A>, E, R>) => Stream.Stream<Chunk.Chunk<A2>, E2, R2>\n  ) => (self: Stream.Stream<A, E, R>) => Stream.Stream<A2, E | E2, R | R2>,\n  <A, E, R, A2, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    f: (stream: Stream.Stream<Chunk.Chunk<A>, E, R>) => Stream.Stream<Chunk.Chunk<A2>, E2, R2>\n  ) => Stream.Stream<A2, E | E2, R | R2>\n>(\n  2,\n  <A, E, R, A2, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    f: (stream: Stream.Stream<Chunk.Chunk<A>, E, R>) => Stream.Stream<Chunk.Chunk<A2>, E2, R2>\n  ): Stream.Stream<A2, E | E2, R | R2> => flattenChunks(f(chunks(self)))\n)\n\nconst unsome = <A, E, R>(effect: Effect.Effect<A, Option.Option<E>, R>): Effect.Effect<Option.Option<A>, E, R> =>\n  Effect.catchAll(\n    Effect.asSome(effect),\n    (o) => o._tag === \"None\" ? Effect.succeedNone : Effect.fail(o.value)\n  )\n\n/** @internal */\nexport const combine = dual<\n  <A2, E2, R2, S, R3, E, A, R4, R5, A3>(\n    that: Stream.Stream<A2, E2, R2>,\n    s: S,\n    f: (\n      s: S,\n      pullLeft: Effect.Effect<A, Option.Option<E>, R3>,\n      pullRight: Effect.Effect<A2, Option.Option<E2>, R4>\n    ) => Effect.Effect<Exit.Exit<readonly [A3, S], Option.Option<E2 | E>>, never, R5>\n  ) => <R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A3, E2 | E, R2 | R3 | R4 | R5 | R>,\n  <R, A2, E2, R2, S, R3, E, A, R4, R5, A3>(\n    self: Stream.Stream<A, E, R>,\n    that: Stream.Stream<A2, E2, R2>,\n    s: S,\n    f: (\n      s: S,\n      pullLeft: Effect.Effect<A, Option.Option<E>, R3>,\n      pullRight: Effect.Effect<A2, Option.Option<E2>, R4>\n    ) => Effect.Effect<Exit.Exit<readonly [A3, S], Option.Option<E2 | E>>, never, R5>\n  ) => Stream.Stream<A3, E2 | E, R2 | R3 | R4 | R5 | R>\n>(4, <R, A2, E2, R2, S, R3, E, A, R4, R5, A3>(\n  self: Stream.Stream<A, E, R>,\n  that: Stream.Stream<A2, E2, R2>,\n  s: S,\n  f: (\n    s: S,\n    pullLeft: Effect.Effect<A, Option.Option<E>, R3>,\n    pullRight: Effect.Effect<A2, Option.Option<E2>, R4>\n  ) => Effect.Effect<Exit.Exit<readonly [A3, S], Option.Option<E2 | E>>, never, R5>\n): Stream.Stream<A3, E2 | E, R2 | R3 | R4 | R5 | R> => {\n  function producer<Err, Elem>(\n    handoff: Handoff.Handoff<Exit.Exit<Elem, Option.Option<Err>>>,\n    latch: Handoff.Handoff<void>\n  ): Channel.Channel<never, Elem, never, Err, unknown, unknown, R> {\n    return core.fromEffect(Handoff.take(latch)).pipe(\n      channel.zipRight(core.readWithCause({\n        onInput: (input) =>\n          core.flatMap(\n            core.fromEffect(\n              Handoff.offer<Exit.Exit<Elem, Option.Option<Err>>>(\n                handoff,\n                Exit.succeed(input)\n              )\n            ),\n            () => producer(handoff, latch)\n          ),\n        onFailure: (cause) =>\n          core.fromEffect(\n            Handoff.offer<Exit.Exit<Elem, Option.Option<Err>>>(\n              handoff,\n              Exit.failCause(pipe(cause, Cause.map(Option.some)))\n            )\n          ),\n        onDone: () =>\n          core.flatMap(\n            core.fromEffect(\n              Handoff.offer<Exit.Exit<Elem, Option.Option<Err>>>(\n                handoff,\n                Exit.fail(Option.none())\n              )\n            ),\n            () => producer(handoff, latch)\n          )\n      }))\n    )\n  }\n  return new StreamImpl(\n    channel.unwrapScopedWith((scope) =>\n      Effect.all([\n        Handoff.make<Exit.Exit<A, Option.Option<E>>>(),\n        Handoff.make<Exit.Exit<A2, Option.Option<E2>>>(),\n        Handoff.make<void>(),\n        Handoff.make<void>()\n      ]).pipe(\n        Effect.tap(([left, _, latchL]) =>\n          toChannel(self).pipe(\n            channel.concatMap(channel.writeChunk),\n            core.pipeTo(producer(left, latchL)),\n            channelExecutor.runIn(scope),\n            Effect.forkIn(scope)\n          )\n        ),\n        Effect.tap(([, right, _, rightL]) =>\n          toChannel(that).pipe(\n            channel.concatMap(channel.writeChunk),\n            core.pipeTo(producer(right, rightL)),\n            channelExecutor.runIn(scope),\n            Effect.forkIn(scope)\n          )\n        ),\n        Effect.map(([left, right, latchL, latchR]) => {\n          const pullLeft = Handoff.offer<void>(latchL, void 0).pipe(\n            Effect.zipRight(Handoff.take(left).pipe(Effect.flatMap(identity)))\n          )\n          const pullRight = Handoff.offer<void>(latchR, void 0).pipe(\n            Effect.zipRight(Handoff.take(right).pipe(Effect.flatMap(identity)))\n          )\n          return toChannel(unfoldEffect(s, (s) => Effect.flatMap(f(s, pullLeft, pullRight), unsome)))\n        })\n      )\n    )\n  )\n})\n\n/** @internal */\nexport const combineChunks = dual<\n  <A2, E2, R2, S, R3, E, A, R4, R5, A3>(\n    that: Stream.Stream<A2, E2, R2>,\n    s: S,\n    f: (\n      s: S,\n      pullLeft: Effect.Effect<Chunk.Chunk<A>, Option.Option<E>, R3>,\n      pullRight: Effect.Effect<Chunk.Chunk<A2>, Option.Option<E2>, R4>\n    ) => Effect.Effect<Exit.Exit<readonly [Chunk.Chunk<A3>, S], Option.Option<E2 | E>>, never, R5>\n  ) => <R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A3, E2 | E, R2 | R3 | R4 | R5 | R>,\n  <R, A2, E2, R2, S, R3, E, A, R4, R5, A3>(\n    self: Stream.Stream<A, E, R>,\n    that: Stream.Stream<A2, E2, R2>,\n    s: S,\n    f: (\n      s: S,\n      pullLeft: Effect.Effect<Chunk.Chunk<A>, Option.Option<E>, R3>,\n      pullRight: Effect.Effect<Chunk.Chunk<A2>, Option.Option<E2>, R4>\n    ) => Effect.Effect<Exit.Exit<readonly [Chunk.Chunk<A3>, S], Option.Option<E2 | E>>, never, R5>\n  ) => Stream.Stream<A3, E2 | E, R2 | R3 | R4 | R5 | R>\n>(4, <R, A2, E2, R2, S, R3, E, A, R4, R5, A3>(\n  self: Stream.Stream<A, E, R>,\n  that: Stream.Stream<A2, E2, R2>,\n  s: S,\n  f: (\n    s: S,\n    pullLeft: Effect.Effect<Chunk.Chunk<A>, Option.Option<E>, R3>,\n    pullRight: Effect.Effect<Chunk.Chunk<A2>, Option.Option<E2>, R4>\n  ) => Effect.Effect<Exit.Exit<readonly [Chunk.Chunk<A3>, S], Option.Option<E2 | E>>, never, R5>\n): Stream.Stream<A3, E2 | E, R2 | R3 | R4 | R5 | R> => {\n  const producer = <Err, Elem>(\n    handoff: Handoff.Handoff<Take.Take<Elem, Err>>,\n    latch: Handoff.Handoff<void>\n  ): Channel.Channel<never, Chunk.Chunk<Elem>, never, Err, unknown, unknown, R> =>\n    channel.zipRight(\n      core.fromEffect(Handoff.take(latch)),\n      core.readWithCause({\n        onInput: (input) =>\n          core.flatMap(\n            core.fromEffect(pipe(\n              handoff,\n              Handoff.offer<Take.Take<Elem, Err>>(InternalTake.chunk(input))\n            )),\n            () => producer(handoff, latch)\n          ),\n        onFailure: (cause) =>\n          core.fromEffect(\n            Handoff.offer<Take.Take<Elem, Err>>(\n              handoff,\n              InternalTake.failCause(cause)\n            )\n          ),\n        onDone: (): Channel.Channel<never, Chunk.Chunk<Elem>, never, Err, unknown, unknown, R> =>\n          core.fromEffect(Handoff.offer<Take.Take<Elem, Err>>(handoff, InternalTake.end))\n      })\n    )\n  return new StreamImpl(\n    channel.unwrapScopedWith((scope) =>\n      Effect.all([\n        Handoff.make<Take.Take<A, E>>(),\n        Handoff.make<Take.Take<A2, E2>>(),\n        Handoff.make<void>(),\n        Handoff.make<void>()\n      ]).pipe(\n        Effect.tap(([left, _, latchL]) =>\n          core.pipeTo(toChannel(self), producer(left, latchL)).pipe(\n            channelExecutor.runIn(scope),\n            Effect.forkIn(scope)\n          )\n        ),\n        Effect.tap(([_, right, __, latchR]) =>\n          core.pipeTo(toChannel(that), producer(right, latchR)).pipe(\n            channelExecutor.runIn(scope),\n            Effect.forkIn(scope)\n          )\n        ),\n        Effect.map(([left, right, latchL, latchR]) => {\n          const pullLeft = Handoff.offer<void>(latchL, void 0).pipe(\n            Effect.zipRight(Handoff.take(left).pipe(Effect.flatMap(InternalTake.done)))\n          )\n          const pullRight = Handoff.offer<void>(latchR, void 0).pipe(\n            Effect.zipRight(Handoff.take(right).pipe(Effect.flatMap(InternalTake.done)))\n          )\n          return toChannel(unfoldChunkEffect(s, (s) => Effect.flatMap(f(s, pullLeft, pullRight), unsome)))\n        })\n      )\n    )\n  )\n})\n\n/** @internal */\nexport const concat = dual<\n  <A2, E2, R2>(\n    that: Stream.Stream<A2, E2, R2>\n  ) => <A, E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A2 | A, E2 | E, R2 | R>,\n  <A, E, R, A2, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    that: Stream.Stream<A2, E2, R2>\n  ) => Stream.Stream<A2 | A, E2 | E, R2 | R>\n>(\n  2,\n  <A, E, R, A2, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    that: Stream.Stream<A2, E2, R2>\n  ): Stream.Stream<A2 | A, E2 | E, R2 | R> =>\n    new StreamImpl<A2 | A, E2 | E, R2 | R>(pipe(toChannel(self), channel.zipRight(toChannel(that))))\n)\n\n/** @internal */\nexport const concatAll = <A, E, R>(streams: Chunk.Chunk<Stream.Stream<A, E, R>>): Stream.Stream<A, E, R> =>\n  suspend(() => pipe(streams, Chunk.reduce(empty as Stream.Stream<A, E, R>, (x, y) => concat(y)(x))))\n\n/** @internal */\nexport const cross: {\n  <AR, ER, RR>(\n    right: Stream.Stream<AR, ER, RR>\n  ): <AL, EL, RL>(left: Stream.Stream<AL, EL, RL>) => Stream.Stream<[AL, AR], EL | ER, RL | RR>\n  <AL, ER, RR, AR, EL, RL>(\n    left: Stream.Stream<AL, ER, RR>,\n    right: Stream.Stream<AR, EL, RL>\n  ): Stream.Stream<[AL, AR], EL | ER, RL | RR>\n} = dual(\n  2,\n  <AL, ER, RR, AR, EL, RL>(\n    left: Stream.Stream<AL, ER, RR>,\n    right: Stream.Stream<AR, EL, RL>\n  ): Stream.Stream<[AL, AR], EL | ER, RL | RR> => pipe(left, crossWith(right, (a, a2) => [a, a2]))\n)\n\n/** @internal */\nexport const crossLeft: {\n  <AR, ER, RR>(\n    right: Stream.Stream<AR, ER, RR>\n  ): <AL, EL, RL>(left: Stream.Stream<AL, EL, RL>) => Stream.Stream<AL, EL | ER, RL | RR>\n  <AL, EL, RL, AR, ER, RR>(\n    left: Stream.Stream<AL, EL, RL>,\n    right: Stream.Stream<AR, ER, RR>\n  ): Stream.Stream<AL, EL | ER, RL | RR>\n} = dual(\n  2,\n  <AL, EL, RL, AR, ER, RR>(\n    left: Stream.Stream<AL, EL, RL>,\n    right: Stream.Stream<AR, ER, RR>\n  ): Stream.Stream<AL, EL | ER, RL | RR> => pipe(left, crossWith(right, (a, _) => a))\n)\n\n/** @internal */\nexport const crossRight: {\n  <AR, ER, RR>(\n    right: Stream.Stream<AR, ER, RR>\n  ): <AL, EL, RL>(left: Stream.Stream<AL, EL, RL>) => Stream.Stream<AR, EL | ER, RL | RR>\n  <AL, EL, RL, AR, ER, RR>(\n    left: Stream.Stream<AL, EL, RL>,\n    right: Stream.Stream<AR, ER, RR>\n  ): Stream.Stream<AR, EL | ER, RL | RR>\n} = dual(\n  2,\n  <AL, EL, RL, AR, ER, RR>(\n    left: Stream.Stream<AL, EL, RL>,\n    right: Stream.Stream<AR, ER, RR>\n  ): Stream.Stream<AR, EL | ER, RL | RR> => flatMap(left, () => right)\n)\n\n/** @internal */\nexport const crossWith: {\n  <AR, ER, RR, AL, A>(\n    right: Stream.Stream<AR, ER, RR>,\n    f: (left: AL, right: AR) => A\n  ): <EL, RL>(left: Stream.Stream<AL, EL, RL>) => Stream.Stream<A, EL | ER, RL | RR>\n  <AL, EL, RL, AR, ER, RR, A>(\n    left: Stream.Stream<AL, EL, RL>,\n    right: Stream.Stream<AR, ER, RR>,\n    f: (left: AL, right: AR) => A\n  ): Stream.Stream<A, EL | ER, RL | RR>\n} = dual(\n  3,\n  <AL, EL, RL, AR, ER, RR, A>(\n    left: Stream.Stream<AL, EL, RL>,\n    right: Stream.Stream<AR, ER, RR>,\n    f: (left: AL, right: AR) => A\n  ): Stream.Stream<A, EL | ER, RL | RR> => pipe(left, flatMap((a) => pipe(right, map((b) => f(a, b)))))\n)\n\n/** @internal */\nexport const debounce = dual<\n  (duration: Duration.DurationInput) => <A, E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A, E, R>,\n  <A, E, R>(self: Stream.Stream<A, E, R>, duration: Duration.DurationInput) => Stream.Stream<A, E, R>\n>(\n  2,\n  <A, E, R>(self: Stream.Stream<A, E, R>, duration: Duration.DurationInput): Stream.Stream<A, E, R> =>\n    unwrapScopedWith((scope) =>\n      Effect.gen(function*() {\n        const handoff = yield* Handoff.make<HandoffSignal.HandoffSignal<A, E>>()\n\n        function enqueue(last: Chunk.Chunk<A>): Effect.Effect<\n          Channel.Channel<Chunk.Chunk<A>, unknown, E, unknown, unknown, unknown>\n        > {\n          return Clock.sleep(duration).pipe(\n            Effect.as(last),\n            Effect.forkIn(scope),\n            Effect.map((fiber) => consumer(DebounceState.previous(fiber)))\n          )\n        }\n\n        const producer: Channel.Channel<never, Chunk.Chunk<A>, E, E, unknown, unknown> = core.readWithCause({\n          onInput: (input: Chunk.Chunk<A>) =>\n            Option.match(Chunk.last(input), {\n              onNone: () => producer,\n              onSome: (elem) =>\n                core.fromEffect(Handoff.offer(handoff, HandoffSignal.emit(Chunk.of(elem)))).pipe(\n                  core.flatMap(() => producer)\n                )\n            }),\n          onFailure: (cause) =>\n            core.fromEffect(\n              Handoff.offer<HandoffSignal.HandoffSignal<A, E>>(handoff, HandoffSignal.halt(cause))\n            ),\n          onDone: () =>\n            core.fromEffect(\n              Handoff.offer<HandoffSignal.HandoffSignal<A, E>>(\n                handoff,\n                HandoffSignal.end(SinkEndReason.UpstreamEnd)\n              )\n            )\n        })\n\n        function consumer(\n          state: DebounceState.DebounceState<A, E>\n        ): Channel.Channel<Chunk.Chunk<A>, unknown, E, unknown, unknown, unknown> {\n          switch (state._tag) {\n            case DebounceState.OP_NOT_STARTED: {\n              return channel.unwrap(\n                Handoff.take(handoff).pipe(\n                  Effect.map((signal) => {\n                    switch (signal._tag) {\n                      case HandoffSignal.OP_EMIT: {\n                        return channel.unwrap(enqueue(signal.elements))\n                      }\n                      case HandoffSignal.OP_HALT: {\n                        return core.failCause(signal.cause)\n                      }\n                      case HandoffSignal.OP_END: {\n                        return core.void\n                      }\n                    }\n                  })\n                )\n              )\n            }\n            case DebounceState.OP_PREVIOUS: {\n              return channel.unwrap(\n                Handoff.take(handoff).pipe(\n                  Effect.forkIn(scope),\n                  Effect.flatMap((handoffFiber) =>\n                    Effect.raceWith(Fiber.join(state.fiber), Fiber.join(handoffFiber), {\n                      onSelfDone: (leftExit, current) =>\n                        Exit.match(leftExit, {\n                          onFailure: (cause) =>\n                            Fiber.interrupt(current).pipe(\n                              Effect.as(core.failCause(cause))\n                            ),\n                          onSuccess: (chunk) =>\n                            Fiber.interrupt(current).pipe(\n                              Effect.zipRight(Effect.succeed(\n                                core.write(chunk).pipe(\n                                  core.flatMap(() => consumer(DebounceState.current(handoffFiber)))\n                                )\n                              ))\n                            )\n                        }),\n                      onOtherDone: (rightExit, previous) =>\n                        Exit.match(rightExit, {\n                          onFailure: (cause) =>\n                            Fiber.interrupt(previous).pipe(\n                              Effect.as(core.failCause(cause))\n                            ),\n                          onSuccess: (signal) => {\n                            switch (signal._tag) {\n                              case HandoffSignal.OP_EMIT: {\n                                return Fiber.interrupt(previous).pipe(\n                                  Effect.zipRight(enqueue(signal.elements))\n                                )\n                              }\n                              case HandoffSignal.OP_HALT: {\n                                return Fiber.interrupt(previous).pipe(\n                                  Effect.as(core.failCause(signal.cause))\n                                )\n                              }\n                              case HandoffSignal.OP_END: {\n                                return Fiber.join(previous).pipe(\n                                  Effect.map((chunk) =>\n                                    core.write(chunk).pipe(\n                                      channel.zipRight(core.void)\n                                    )\n                                  )\n                                )\n                              }\n                            }\n                          }\n                        })\n                    })\n                  )\n                )\n              )\n            }\n            case DebounceState.OP_CURRENT: {\n              return channel.unwrap(\n                Fiber.join(state.fiber).pipe(\n                  Effect.map((signal) => {\n                    switch (signal._tag) {\n                      case HandoffSignal.OP_EMIT: {\n                        return channel.unwrap(enqueue(signal.elements))\n                      }\n                      case HandoffSignal.OP_HALT: {\n                        return core.failCause(signal.cause)\n                      }\n                      case HandoffSignal.OP_END: {\n                        return core.void\n                      }\n                    }\n                  })\n                )\n              )\n            }\n          }\n        }\n\n        return scopedWith((scope) =>\n          core.pipeTo(toChannel(self), producer).pipe(\n            channelExecutor.runIn(scope),\n            Effect.forkIn(scope)\n          )\n        ).pipe(crossRight(new StreamImpl(consumer(DebounceState.notStarted))))\n      })\n    )\n)\n\n/** @internal */\nexport const die = (defect: unknown): Stream.Stream<never> => fromEffect(Effect.die(defect))\n\n/** @internal */\nexport const dieSync = (evaluate: LazyArg<unknown>): Stream.Stream<never> => fromEffect(Effect.dieSync(evaluate))\n\n/** @internal */\nexport const dieMessage = (message: string): Stream.Stream<never> => fromEffect(Effect.dieMessage(message))\n\n/** @internal */\nexport const distributedWith = dual<\n  <N extends number, A>(\n    options: {\n      readonly size: N\n      readonly maximumLag: number\n      readonly decide: (a: A) => Effect.Effect<Predicate<number>>\n    }\n  ) => <E, R>(\n    self: Stream.Stream<A, E, R>\n  ) => Effect.Effect<\n    Types.TupleOf<N, Queue.Dequeue<Exit.Exit<A, Option.Option<E>>>>,\n    never,\n    Scope.Scope | R\n  >,\n  <A, E, R, N extends number>(\n    self: Stream.Stream<A, E, R>,\n    options: {\n      readonly size: N\n      readonly maximumLag: number\n      readonly decide: (a: A) => Effect.Effect<Predicate<number>>\n    }\n  ) => Effect.Effect<\n    Types.TupleOf<N, Queue.Dequeue<Exit.Exit<A, Option.Option<E>>>>,\n    never,\n    Scope.Scope | R\n  >\n>(\n  2,\n  <A, E, R, N extends number>(\n    self: Stream.Stream<A, E, R>,\n    options: {\n      readonly size: N\n      readonly maximumLag: number\n      readonly decide: (a: A) => Effect.Effect<Predicate<number>>\n    }\n  ): Effect.Effect<\n    Types.TupleOf<N, Queue.Dequeue<Exit.Exit<A, Option.Option<E>>>>,\n    never,\n    Scope.Scope | R\n  > =>\n    pipe(\n      Deferred.make<(a: A) => Effect.Effect<Predicate<number>>>(),\n      Effect.flatMap((deferred) =>\n        pipe(\n          self,\n          distributedWithDynamic({\n            maximumLag: options.maximumLag,\n            decide: (a) => Effect.flatMap(Deferred.await(deferred), (f) => f(a))\n          }),\n          Effect.flatMap((next) =>\n            pipe(\n              Effect.all(\n                Chunk.map(\n                  Chunk.range(0, options.size - 1),\n                  (id) => Effect.map(next, ([key, queue]) => [[key, id], queue] as const)\n                )\n              ),\n              Effect.map(Chunk.unsafeFromArray),\n              Effect.flatMap((entries) => {\n                const [mappings, queues] = Chunk.reduceRight(\n                  entries,\n                  [\n                    new Map<number, number>(),\n                    Chunk.empty<Queue.Dequeue<Exit.Exit<A, Option.Option<E>>>>()\n                  ] as const,\n                  ([mappings, queues], [mapping, queue]) =>\n                    [\n                      mappings.set(mapping[0], mapping[1]),\n                      pipe(queues, Chunk.prepend(queue))\n                    ] as const\n                )\n                return pipe(\n                  Deferred.succeed(deferred, (a: A) =>\n                    Effect.map(options.decide(a), (f) => (key: number) => pipe(f(mappings.get(key)!)))),\n                  Effect.as(\n                    Array.from(queues) as Types.TupleOf<N, Queue.Dequeue<Exit.Exit<A, Option.Option<E>>>>\n                  )\n                )\n              })\n            )\n          )\n        )\n      )\n    )\n)\n\n/** @internal */\nconst distributedWithDynamicId = { ref: 0 }\n\nconst newDistributedWithDynamicId = () => {\n  const current = distributedWithDynamicId.ref\n  distributedWithDynamicId.ref = current + 1\n  return current\n}\n\n/** @internal */\nexport const distributedWithDynamic = dual<\n  <A>(\n    options: {\n      readonly maximumLag: number\n      readonly decide: (a: A) => Effect.Effect<Predicate<number>>\n    }\n  ) => <E, R>(\n    self: Stream.Stream<A, E, R>\n  ) => Effect.Effect<\n    Effect.Effect<[number, Queue.Dequeue<Exit.Exit<A, Option.Option<E>>>]>,\n    never,\n    Scope.Scope | R\n  >,\n  <A, E, R>(\n    self: Stream.Stream<A, E, R>,\n    options: {\n      readonly maximumLag: number\n      readonly decide: (a: A) => Effect.Effect<Predicate<number>>\n    }\n  ) => Effect.Effect<\n    Effect.Effect<[number, Queue.Dequeue<Exit.Exit<A, Option.Option<E>>>]>,\n    never,\n    Scope.Scope | R\n  >\n>(2, <A, E, R>(\n  self: Stream.Stream<A, E, R>,\n  options: {\n    readonly maximumLag: number\n    readonly decide: (a: A) => Effect.Effect<Predicate<number>>\n  }\n): Effect.Effect<\n  Effect.Effect<[number, Queue.Dequeue<Exit.Exit<A, Option.Option<E>>>]>,\n  never,\n  Scope.Scope | R\n> => distributedWithDynamicCallback(self, options.maximumLag, options.decide, () => Effect.void))\n\n/** @internal */\nexport const distributedWithDynamicCallback = dual<\n  <A, E, X>(\n    maximumLag: number,\n    decide: (a: A) => Effect.Effect<Predicate<number>>,\n    done: (exit: Exit.Exit<never, Option.Option<E>>) => Effect.Effect<X>\n  ) => <R>(\n    self: Stream.Stream<A, E, R>\n  ) => Effect.Effect<\n    Effect.Effect<[number, Queue.Dequeue<Exit.Exit<A, Option.Option<E>>>]>,\n    never,\n    Scope.Scope | R\n  >,\n  <A, E, R, X>(\n    self: Stream.Stream<A, E, R>,\n    maximumLag: number,\n    decide: (a: A) => Effect.Effect<Predicate<number>>,\n    done: (exit: Exit.Exit<never, Option.Option<E>>) => Effect.Effect<X>\n  ) => Effect.Effect<\n    Effect.Effect<[number, Queue.Dequeue<Exit.Exit<A, Option.Option<E>>>]>,\n    never,\n    Scope.Scope | R\n  >\n>(4, <A, E, R, X>(\n  self: Stream.Stream<A, E, R>,\n  maximumLag: number,\n  decide: (a: A) => Effect.Effect<Predicate<number>>,\n  done: (exit: Exit.Exit<never, Option.Option<E>>) => Effect.Effect<X>\n): Effect.Effect<\n  Effect.Effect<[number, Queue.Dequeue<Exit.Exit<A, Option.Option<E>>>]>,\n  never,\n  Scope.Scope | R\n> =>\n  pipe(\n    Effect.acquireRelease(\n      Ref.make<Map<number, Queue.Queue<Exit.Exit<A, Option.Option<E>>>>>(new Map()),\n      (ref, _) => pipe(Ref.get(ref), Effect.flatMap((queues) => pipe(queues.values(), Effect.forEach(Queue.shutdown))))\n    ),\n    Effect.flatMap((queuesRef) =>\n      Effect.gen(function*() {\n        const offer = (a: A): Effect.Effect<void> =>\n          pipe(\n            decide(a),\n            Effect.flatMap((shouldProcess) =>\n              pipe(\n                Ref.get(queuesRef),\n                Effect.flatMap((queues) =>\n                  pipe(\n                    queues.entries(),\n                    Effect.reduce(Chunk.empty<number>(), (acc, [id, queue]) => {\n                      if (shouldProcess(id)) {\n                        return pipe(\n                          Queue.offer(queue, Exit.succeed(a)),\n                          Effect.matchCauseEffect({\n                            onFailure: (cause) =>\n                              // Ignore all downstream queues that were shut\n                              // down and remove them later\n                              Cause.isInterrupted(cause) ?\n                                Effect.succeed(pipe(acc, Chunk.prepend(id))) :\n                                Effect.failCause(cause),\n                            onSuccess: () => Effect.succeed(acc)\n                          })\n                        )\n                      }\n                      return Effect.succeed(acc)\n                    }),\n                    Effect.flatMap((ids) => {\n                      if (Chunk.isNonEmpty(ids)) {\n                        return pipe(\n                          Ref.update(queuesRef, (map) => {\n                            for (const id of ids) {\n                              map.delete(id)\n                            }\n                            return map\n                          })\n                        )\n                      }\n                      return Effect.void\n                    })\n                  )\n                )\n              )\n            ),\n            Effect.asVoid\n          )\n        const queuesLock = yield* Effect.makeSemaphore(1)\n        const newQueue = yield* Ref.make<Effect.Effect<[number, Queue.Queue<Exit.Exit<A, Option.Option<E>>>]>>(\n          pipe(\n            Queue.bounded<Exit.Exit<A, Option.Option<E>>>(maximumLag),\n            Effect.flatMap((queue) => {\n              const id = newDistributedWithDynamicId()\n              return pipe(\n                Ref.update(queuesRef, (map) => map.set(id, queue)),\n                Effect.as([id, queue])\n              )\n            })\n          )\n        )\n        const finalize = (endTake: Exit.Exit<never, Option.Option<E>>): Effect.Effect<void> =>\n          // Make sure that no queues are currently being added\n          queuesLock.withPermits(1)(\n            pipe(\n              Ref.set(\n                newQueue,\n                pipe(\n                  // All newly created queues should end immediately\n                  Queue.bounded<Exit.Exit<A, Option.Option<E>>>(1),\n                  Effect.tap((queue) => Queue.offer(queue, endTake)),\n                  Effect.flatMap((queue) => {\n                    const id = newDistributedWithDynamicId()\n                    return pipe(\n                      Ref.update(queuesRef, (map) => map.set(id, queue)),\n                      Effect.as(Tuple.make(id, queue))\n                    )\n                  })\n                )\n              ),\n              Effect.zipRight(\n                pipe(\n                  Ref.get(queuesRef),\n                  Effect.flatMap((map) =>\n                    pipe(\n                      Chunk.fromIterable(map.values()),\n                      Effect.forEach((queue) =>\n                        pipe(\n                          Queue.offer(queue, endTake),\n                          Effect.catchSomeCause((cause) =>\n                            Cause.isInterrupted(cause) ? Option.some(Effect.void) : Option.none()\n                          )\n                        )\n                      )\n                    )\n                  )\n                )\n              ),\n              Effect.zipRight(done(endTake)),\n              Effect.asVoid\n            )\n          )\n        yield* pipe(\n          self,\n          runForEachScoped(offer),\n          Effect.matchCauseEffect({\n            onFailure: (cause) => finalize(Exit.failCause(pipe(cause, Cause.map(Option.some)))),\n            onSuccess: () => finalize(Exit.fail(Option.none()))\n          }),\n          Effect.forkScoped\n        )\n        return queuesLock.withPermits(1)(\n          Effect.flatten(Ref.get(newQueue))\n        )\n      })\n    )\n  ))\n\n/** @internal */\nexport const drain = <A, E, R>(self: Stream.Stream<A, E, R>): Stream.Stream<never, E, R> =>\n  new StreamImpl(channel.drain(toChannel(self)))\n\n/** @internal */\nexport const drainFork = dual<\n  <A2, E2, R2>(\n    that: Stream.Stream<A2, E2, R2>\n  ) => <A, E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A, E2 | E, R2 | R>,\n  <A, E, R, A2, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    that: Stream.Stream<A2, E2, R2>\n  ) => Stream.Stream<A, E2 | E, R2 | R>\n>(\n  2,\n  <A, E, R, A2, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    that: Stream.Stream<A2, E2, R2>\n  ): Stream.Stream<A, E2 | E, R2 | R> =>\n    fromEffect(Deferred.make<never, E2>()).pipe(flatMap((backgroundDied) =>\n      scopedWith((scope) =>\n        toChannel(that).pipe(\n          channel.drain,\n          channelExecutor.runIn(scope),\n          Effect.catchAllCause((cause) => Deferred.failCause(backgroundDied, cause)),\n          Effect.forkIn(scope)\n        )\n      ).pipe(crossRight(interruptWhenDeferred(self, backgroundDied)))\n    ))\n)\n\n/** @internal */\nexport const drop = dual<\n  (n: number) => <A, E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A, E, R>,\n  <A, E, R>(self: Stream.Stream<A, E, R>, n: number) => Stream.Stream<A, E, R>\n>(2, <A, E, R>(self: Stream.Stream<A, E, R>, n: number): Stream.Stream<A, E, R> => {\n  const loop = (r: number): Channel.Channel<Chunk.Chunk<A>, Chunk.Chunk<A>, never, never, unknown, unknown> =>\n    core.readWith({\n      onInput: (input: Chunk.Chunk<A>) => {\n        const dropped = pipe(input, Chunk.drop(r))\n        const leftover = Math.max(0, r - input.length)\n        const more = Chunk.isEmpty(input) || leftover > 0\n        if (more) {\n          return loop(leftover)\n        }\n        return pipe(\n          core.write(dropped),\n          channel.zipRight(channel.identityChannel<Chunk.Chunk<A>, never, unknown>())\n        )\n      },\n      onFailure: core.fail,\n      onDone: () => core.void\n    })\n  return new StreamImpl(pipe(toChannel(self), channel.pipeToOrFail(loop(n))))\n})\n\n/** @internal */\nexport const dropRight = dual<\n  (n: number) => <A, E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A, E, R>,\n  <A, E, R>(self: Stream.Stream<A, E, R>, n: number) => Stream.Stream<A, E, R>\n>(2, <A, E, R>(self: Stream.Stream<A, E, R>, n: number): Stream.Stream<A, E, R> => {\n  if (n <= 0) {\n    return identityStream()\n  }\n  return suspend(() => {\n    const queue = new RingBuffer<A>(n)\n    const reader: Channel.Channel<Chunk.Chunk<A>, Chunk.Chunk<A>, E, E, void, unknown> = core.readWith({\n      onInput: (input: Chunk.Chunk<A>) => {\n        const outputs = pipe(\n          input,\n          Chunk.filterMap((elem) => {\n            const head = queue.head()\n            queue.put(elem)\n            return head\n          })\n        )\n        return pipe(core.write(outputs), core.flatMap(() => reader))\n      },\n      onFailure: core.fail,\n      onDone: () => core.void\n    })\n    return new StreamImpl(pipe(toChannel(self), channel.pipeToOrFail(reader)))\n  })\n})\n\n/** @internal */\nexport const dropUntil = dual<\n  <A>(predicate: Predicate<Types.NoInfer<A>>) => <E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A, E, R>,\n  <A, E, R>(self: Stream.Stream<A, E, R>, predicate: Predicate<A>) => Stream.Stream<A, E, R>\n>(\n  2,\n  <A, E, R>(self: Stream.Stream<A, E, R>, predicate: Predicate<A>): Stream.Stream<A, E, R> =>\n    drop(dropWhile(self, (a) => !predicate(a)), 1)\n)\n\n/** @internal */\nexport const dropUntilEffect = dual<\n  <A, E2, R2>(\n    predicate: (a: Types.NoInfer<A>) => Effect.Effect<boolean, E2, R2>\n  ) => <E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A, E2 | E, R2 | R>,\n  <A, E, R, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    predicate: (a: Types.NoInfer<A>) => Effect.Effect<boolean, E2, R2>\n  ) => Stream.Stream<A, E2 | E, R2 | R>\n>(\n  2,\n  <A, E, R, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    predicate: (a: Types.NoInfer<A>) => Effect.Effect<boolean, E2, R2>\n  ): Stream.Stream<A, E2 | E, R2 | R> => {\n    const loop: Channel.Channel<Chunk.Chunk<A>, Chunk.Chunk<A>, E | E2, E, unknown, unknown, R2> = core.readWith({\n      onInput: (input: Chunk.Chunk<A>) =>\n        pipe(\n          Effect.dropUntil(input, predicate),\n          Effect.map(Chunk.unsafeFromArray),\n          Effect.map((leftover) => {\n            const more = Chunk.isEmpty(leftover)\n            if (more) {\n              return core.suspend(() => loop)\n            }\n            return pipe(\n              core.write(leftover),\n              channel.zipRight(channel.identityChannel<Chunk.Chunk<A>, E | E2, unknown>())\n            )\n          }),\n          channel.unwrap\n        ),\n      onFailure: core.fail,\n      onDone: () => core.void\n    })\n    return new StreamImpl(pipe(toChannel(self), channel.pipeToOrFail(loop)))\n  }\n)\n\n/** @internal */\nexport const dropWhile = dual<\n  <A>(predicate: Predicate<Types.NoInfer<A>>) => <E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A, E, R>,\n  <A, E, R>(self: Stream.Stream<A, E, R>, predicate: Predicate<A>) => Stream.Stream<A, E, R>\n>(2, <A, E, R>(self: Stream.Stream<A, E, R>, predicate: Predicate<A>): Stream.Stream<A, E, R> => {\n  const loop: Channel.Channel<Chunk.Chunk<A>, Chunk.Chunk<A>, never, never, unknown, unknown> = core.readWith({\n    onInput: (input: Chunk.Chunk<A>) => {\n      const output = Chunk.dropWhile(input, predicate)\n      if (Chunk.isEmpty(output)) {\n        return core.suspend(() => loop)\n      }\n      return channel.zipRight(\n        core.write(output),\n        channel.identityChannel<Chunk.Chunk<A>, never, unknown>()\n      )\n    },\n    onFailure: core.fail,\n    onDone: core.succeedNow\n  })\n  return new StreamImpl(channel.pipeToOrFail(toChannel(self), loop))\n})\n\n/** @internal */\nexport const dropWhileEffect = dual<\n  <A, E2, R2>(\n    predicate: (a: Types.NoInfer<A>) => Effect.Effect<boolean, E2, R2>\n  ) => <E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A, E2 | E, R2 | R>,\n  <A, E, R, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    predicate: (a: A) => Effect.Effect<boolean, E2, R2>\n  ) => Stream.Stream<A, E2 | E, R2 | R>\n>(\n  2,\n  <A, E, R, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    predicate: (a: A) => Effect.Effect<boolean, E2, R2>\n  ): Stream.Stream<A, E2 | E, R2 | R> => {\n    const loop: Channel.Channel<Chunk.Chunk<A>, Chunk.Chunk<A>, E | E2, E, unknown, unknown, R2> = core.readWith({\n      onInput: (input: Chunk.Chunk<A>) =>\n        pipe(\n          Effect.dropWhile(input, predicate),\n          Effect.map(Chunk.unsafeFromArray),\n          Effect.map((leftover) => {\n            const more = Chunk.isEmpty(leftover)\n            if (more) {\n              return core.suspend(() => loop)\n            }\n            return channel.zipRight(\n              core.write(leftover),\n              channel.identityChannel<Chunk.Chunk<A>, E | E2, unknown>()\n            )\n          }),\n          channel.unwrap\n        ),\n      onFailure: core.fail,\n      onDone: () => core.void\n    })\n    return new StreamImpl(channel.pipeToOrFail(\n      toChannel(self),\n      loop\n    ))\n  }\n)\n\n/** @internal */\nexport const either = <A, E, R>(self: Stream.Stream<A, E, R>): Stream.Stream<Either.Either<A, E>, never, R> =>\n  pipe(self, map(Either.right), catchAll((error) => make(Either.left(error))))\n\n/** @internal */\nexport const empty: Stream.Stream<never> = new StreamImpl(core.void)\n\n/** @internal */\nexport const ensuring = dual<\n  <X, R2>(\n    finalizer: Effect.Effect<X, never, R2>\n  ) => <A, E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A, E, R2 | R>,\n  <A, E, R, X, R2>(self: Stream.Stream<A, E, R>, finalizer: Effect.Effect<X, never, R2>) => Stream.Stream<A, E, R2 | R>\n>(\n  2,\n  <A, E, R, X, R2>(self: Stream.Stream<A, E, R>, finalizer: Effect.Effect<X, never, R2>): Stream.Stream<A, E, R2 | R> =>\n    new StreamImpl(pipe(toChannel(self), channel.ensuring(finalizer)))\n)\n\n/** @internal */\nexport const ensuringWith = dual<\n  <E, R2>(\n    finalizer: (exit: Exit.Exit<unknown, E>) => Effect.Effect<unknown, never, R2>\n  ) => <A, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A, E, R | R2>,\n  <A, E, R, R2>(\n    self: Stream.Stream<A, E, R>,\n    finalizer: (exit: Exit.Exit<unknown, E>) => Effect.Effect<unknown, never, R2>\n  ) => Stream.Stream<A, E, R | R2>\n>(2, (self, finalizer) => new StreamImpl(core.ensuringWith(toChannel(self), finalizer)))\n\n/** @internal */\nexport const context = <R>(): Stream.Stream<Context.Context<R>, never, R> => fromEffect(Effect.context<R>())\n\n/** @internal */\nexport const contextWith = <R, A>(f: (env: Context.Context<R>) => A): Stream.Stream<A, never, R> =>\n  pipe(context<R>(), map(f))\n\n/** @internal */\nexport const contextWithEffect = <R0, A, E, R>(\n  f: (env: Context.Context<R0>) => Effect.Effect<A, E, R>\n): Stream.Stream<A, E, R0 | R> => pipe(context<R0>(), mapEffectSequential(f))\n\n/** @internal */\nexport const contextWithStream = <R0, A, E, R>(\n  f: (env: Context.Context<R0>) => Stream.Stream<A, E, R>\n): Stream.Stream<A, E, R0 | R> => pipe(context<R0>(), flatMap(f))\n\n/** @internal */\nexport const execute = <X, E, R>(effect: Effect.Effect<X, E, R>): Stream.Stream<never, E, R> =>\n  drain(fromEffect(effect))\n\n/** @internal */\nexport const fail = <E>(error: E): Stream.Stream<never, E> => fromEffectOption(Effect.fail(Option.some(error)))\n\n/** @internal */\nexport const failSync = <E>(evaluate: LazyArg<E>): Stream.Stream<never, E> =>\n  fromEffectOption(Effect.failSync(() => Option.some(evaluate())))\n\n/** @internal */\nexport const failCause = <E>(cause: Cause.Cause<E>): Stream.Stream<never, E> => fromEffect(Effect.failCause(cause))\n\n/** @internal */\nexport const failCauseSync = <E>(evaluate: LazyArg<Cause.Cause<E>>): Stream.Stream<never, E> =>\n  fromEffect(Effect.failCauseSync(evaluate))\n\n/** @internal */\nexport const filter: {\n  <A, B extends A>(\n    refinement: Refinement<Types.NoInfer<A>, B>\n  ): <E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<B, E, R>\n  <A, B extends A>(predicate: Predicate<B>): <E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A, E, R>\n  <A, E, R, B extends A>(self: Stream.Stream<A, E, R>, refinement: Refinement<A, B>): Stream.Stream<B, E, R>\n  <A, E, R>(self: Stream.Stream<A, E, R>, predicate: Predicate<A>): Stream.Stream<A, E, R>\n} = dual(\n  2,\n  <A, E, R>(self: Stream.Stream<A, E, R>, predicate: Predicate<A>) => mapChunks(self, Chunk.filter(predicate))\n)\n\n/** @internal */\nexport const filterEffect = dual<\n  <A, E2, R2>(\n    f: (a: Types.NoInfer<A>) => Effect.Effect<boolean, E2, R2>\n  ) => <E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A, E2 | E, R2 | R>,\n  <A, E, R, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    f: (a: A) => Effect.Effect<boolean, E2, R2>\n  ) => Stream.Stream<A, E2 | E, R2 | R>\n>(\n  2,\n  <A, E, R, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    f: (a: A) => Effect.Effect<boolean, E2, R2>\n  ): Stream.Stream<A, E2 | E, R2 | R> => {\n    const loop = (\n      iterator: Iterator<A>\n    ): Channel.Channel<Chunk.Chunk<A>, Chunk.Chunk<A>, E | E2, E, unknown, unknown, R2> => {\n      const next = iterator.next()\n      if (next.done) {\n        return core.readWithCause({\n          onInput: (input) => loop(input[Symbol.iterator]()),\n          onFailure: core.failCause,\n          onDone: core.succeed\n        })\n      } else {\n        return pipe(\n          f(next.value),\n          Effect.map((bool) =>\n            bool ?\n              pipe(core.write(Chunk.of(next.value)), core.flatMap(() => loop(iterator))) :\n              loop(iterator)\n          ),\n          channel.unwrap\n        )\n      }\n    }\n    return new StreamImpl(\n      core.suspend(() => pipe(toChannel(self), core.pipeTo(loop(Chunk.empty<A>()[Symbol.iterator]()))))\n    )\n  }\n)\n\n/** @internal */\nexport const filterMap = dual<\n  <A, B>(pf: (a: A) => Option.Option<B>) => <E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<B, E, R>,\n  <A, E, R, B>(self: Stream.Stream<A, E, R>, pf: (a: A) => Option.Option<B>) => Stream.Stream<B, E, R>\n>(\n  2,\n  <A, E, R, B>(self: Stream.Stream<A, E, R>, pf: (a: A) => Option.Option<B>): Stream.Stream<B, E, R> =>\n    mapChunks(self, Chunk.filterMap(pf))\n)\n\n/** @internal */\nexport const filterMapEffect = dual<\n  <A, A2, E2, R2>(\n    pf: (a: A) => Option.Option<Effect.Effect<A2, E2, R2>>\n  ) => <E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A2, E2 | E, R2 | R>,\n  <A, E, R, A2, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    pf: (a: A) => Option.Option<Effect.Effect<A2, E2, R2>>\n  ) => Stream.Stream<A2, E2 | E, R2 | R>\n>(\n  2,\n  <A, E, R, A2, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    pf: (a: A) => Option.Option<Effect.Effect<A2, E2, R2>>\n  ): Stream.Stream<A2, E | E2, R | R2> =>\n    suspend(() => {\n      const loop = (\n        iterator: Iterator<A>\n      ): Channel.Channel<Chunk.Chunk<A2>, Chunk.Chunk<A>, E | E2, E, unknown, unknown, R | R2> => {\n        const next = iterator.next()\n        if (next.done) {\n          return core.readWithCause({\n            onInput: (input) => loop(input[Symbol.iterator]()),\n            onFailure: core.failCause,\n            onDone: core.succeed\n          })\n        } else {\n          return pipe(\n            pf(next.value),\n            Option.match({\n              onNone: () => Effect.sync(() => loop(iterator)),\n              onSome: Effect.map((a2) => core.flatMap(core.write(Chunk.of(a2)), () => loop(iterator)))\n            }),\n            channel.unwrap\n          )\n        }\n      }\n      return new StreamImpl(pipe(toChannel(self), core.pipeTo(loop(Chunk.empty<A>()[Symbol.iterator]()))))\n    })\n)\n\n/** @internal */\nexport const filterMapWhile = dual<\n  <A, A2>(\n    pf: (a: A) => Option.Option<A2>\n  ) => <E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A2, E, R>,\n  <A, E, R, A2>(self: Stream.Stream<A, E, R>, pf: (a: A) => Option.Option<A2>) => Stream.Stream<A2, E, R>\n>(\n  2,\n  <A, E, R, A2>(self: Stream.Stream<A, E, R>, pf: (a: A) => Option.Option<A2>) => {\n    const loop: Channel.Channel<Chunk.Chunk<A2>, Chunk.Chunk<A>, E, E, unknown, unknown> = core.readWith({\n      onInput: (input: Chunk.Chunk<A>) => {\n        const mapped = Chunk.filterMapWhile(input, pf)\n        if (mapped.length === input.length) {\n          return pipe(core.write(mapped), core.flatMap(() => loop))\n        }\n        return core.write(mapped)\n      },\n      onFailure: core.fail,\n      onDone: core.succeed\n    })\n    return new StreamImpl(pipe(toChannel(self), channel.pipeToOrFail(loop)))\n  }\n)\n\n/** @internal */\nexport const filterMapWhileEffect = dual<\n  <A, A2, E2, R2>(\n    pf: (a: A) => Option.Option<Effect.Effect<A2, E2, R2>>\n  ) => <E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A2, E2 | E, R2 | R>,\n  <A, E, R, A2, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    pf: (a: A) => Option.Option<Effect.Effect<A2, E2, R2>>\n  ) => Stream.Stream<A2, E2 | E, R2 | R>\n>(\n  2,\n  <A, E, R, A2, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    pf: (a: A) => Option.Option<Effect.Effect<A2, E2, R2>>\n  ): Stream.Stream<A2, E | E2, R | R2> =>\n    suspend(() => {\n      const loop = (\n        iterator: Iterator<A>\n      ): Channel.Channel<Chunk.Chunk<A2>, Chunk.Chunk<A>, E | E2, E, unknown, unknown, R | R2> => {\n        const next = iterator.next()\n        if (next.done) {\n          return core.readWithCause({\n            onInput: (input) => loop(input[Symbol.iterator]()),\n            onFailure: core.failCause,\n            onDone: core.succeed\n          })\n        } else {\n          return channel.unwrap(\n            Option.match(pf(next.value), {\n              onNone: () => Effect.succeed(core.void),\n              onSome: Effect.map(\n                (a2) => core.flatMap(core.write(Chunk.of(a2)), () => loop(iterator))\n              )\n            })\n          )\n        }\n      }\n      return new StreamImpl(pipe(toChannel(self), channel.pipeToOrFail(loop(Chunk.empty<A>()[Symbol.iterator]()))))\n    })\n)\n\n/** @internal */\nexport const finalizer = <R, X>(finalizer: Effect.Effect<X, never, R>): Stream.Stream<void, never, R> =>\n  acquireRelease(Effect.void, () => finalizer)\n\n/** @internal */\nexport const find: {\n  <A, B extends A>(\n    refinement: Refinement<Types.NoInfer<A>, B>\n  ): <E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<B, E, R>\n  <A>(predicate: Predicate<Types.NoInfer<A>>): <E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A, E, R>\n  <A, E, R, B extends A>(self: Stream.Stream<A, E, R>, refinement: Refinement<A, B>): Stream.Stream<B, E, R>\n  <A, E, R>(self: Stream.Stream<A, E, R>, predicate: Predicate<A>): Stream.Stream<A, E, R>\n} = dual(2, <A, E, R>(self: Stream.Stream<A, E, R>, predicate: Predicate<A>): Stream.Stream<A, E, R> => {\n  const loop: Channel.Channel<Chunk.Chunk<A>, Chunk.Chunk<A>, E, E, unknown, unknown, R> = core.readWith({\n    onInput: (input: Chunk.Chunk<A>) =>\n      Option.match(Chunk.findFirst(input, predicate), {\n        onNone: () => loop,\n        onSome: (n) => core.write(Chunk.of(n))\n      }),\n    onFailure: core.fail,\n    onDone: () => core.void\n  })\n  return new StreamImpl(pipe(toChannel(self), core.pipeTo(loop)))\n})\n\n/** @internal */\nexport const findEffect: {\n  <A, E2, R2>(\n    predicate: (a: Types.NoInfer<A>) => Effect.Effect<boolean, E2, R2>\n  ): <E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A, E2 | E, R2 | R>\n  <A, E, R, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    predicate: (a: Types.NoInfer<A>) => Effect.Effect<boolean, E2, R2>\n  ): Stream.Stream<A, E | E2, R | R2>\n} = dual(\n  2,\n  <A, E, R, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    predicate: (a: Types.NoInfer<A>) => Effect.Effect<boolean, E2, R2>\n  ): Stream.Stream<A, E | E2, R | R2> => {\n    const loop: Channel.Channel<Chunk.Chunk<A>, Chunk.Chunk<A>, E | E2, E, unknown, unknown, R2> = core.readWith({\n      onInput: (input: Chunk.Chunk<A>) =>\n        pipe(\n          Effect.findFirst(input, predicate),\n          Effect.map(Option.match({\n            onNone: () => loop,\n            onSome: (n) => core.write(Chunk.of(n))\n          })),\n          channel.unwrap\n        ),\n      onFailure: core.fail,\n      onDone: () => core.void\n    })\n    return new StreamImpl(pipe(toChannel(self), core.pipeTo(loop)))\n  }\n)\n\n/** @internal */\nexport const flatMap = dual<\n  <A, A2, E2, R2>(\n    f: (a: A) => Stream.Stream<A2, E2, R2>,\n    options?: {\n      readonly concurrency?: number | \"unbounded\" | undefined\n      readonly bufferSize?: number | undefined\n      readonly switch?: boolean | undefined\n    }\n  ) => <E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A2, E2 | E, R2 | R>,\n  <A, E, R, A2, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    f: (a: A) => Stream.Stream<A2, E2, R2>,\n    options?: {\n      readonly concurrency?: number | \"unbounded\" | undefined\n      readonly bufferSize?: number | undefined\n      readonly switch?: boolean | undefined\n    }\n  ) => Stream.Stream<A2, E2 | E, R2 | R>\n>(\n  (args) => isStream(args[0]),\n  <A, E, R, A2, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    f: (a: A) => Stream.Stream<A2, E2, R2>,\n    options?: {\n      readonly concurrency?: number | \"unbounded\" | undefined\n      readonly bufferSize?: number | undefined\n      readonly switch?: boolean | undefined\n    }\n  ): Stream.Stream<A2, E | E2, R | R2> => {\n    const bufferSize = options?.bufferSize ?? 16\n\n    if (options?.switch) {\n      return matchConcurrency(\n        options?.concurrency,\n        () => flatMapParSwitchBuffer(self, 1, bufferSize, f),\n        (n) => flatMapParSwitchBuffer(self, n, bufferSize, f)\n      )\n    }\n\n    return matchConcurrency(\n      options?.concurrency,\n      () =>\n        new StreamImpl(\n          channel.concatMap(\n            toChannel(self),\n            (as) =>\n              pipe(\n                as,\n                Chunk.map((a) => toChannel(f(a))),\n                Chunk.reduce(\n                  core.void as Channel.Channel<Chunk.Chunk<A2>, unknown, E2, unknown, unknown, unknown, R2>,\n                  (left, right) => pipe(left, channel.zipRight(right))\n                )\n              )\n          )\n        ),\n      (_) =>\n        new StreamImpl(\n          pipe(\n            toChannel(self),\n            channel.concatMap(channel.writeChunk),\n            channel.mergeMap((out) => toChannel(f(out)), options as any)\n          )\n        )\n    )\n  }\n)\n\n/** @internal */\nexport const matchConcurrency = <A>(\n  concurrency: number | \"unbounded\" | undefined,\n  sequential: () => A,\n  bounded: (n: number) => A\n) => {\n  switch (concurrency) {\n    case undefined:\n      return sequential()\n    case \"unbounded\":\n      return bounded(Number.MAX_SAFE_INTEGER)\n    default:\n      return concurrency > 1 ? bounded(concurrency) : sequential()\n  }\n}\n\nconst flatMapParSwitchBuffer = dual<\n  <A, A2, E2, R2>(\n    n: number,\n    bufferSize: number,\n    f: (a: A) => Stream.Stream<A2, E2, R2>\n  ) => <E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A2, E2 | E, R2 | R>,\n  <A, E, R, A2, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    n: number,\n    bufferSize: number,\n    f: (a: A) => Stream.Stream<A2, E2, R2>\n  ) => Stream.Stream<A2, E2 | E, R2 | R>\n>(\n  4,\n  <A, E, R, A2, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    n: number,\n    bufferSize: number,\n    f: (a: A) => Stream.Stream<A2, E2, R2>\n  ): Stream.Stream<A2, E | E2, R | R2> =>\n    new StreamImpl(\n      pipe(\n        toChannel(self),\n        channel.concatMap(channel.writeChunk),\n        channel.mergeMap((out) => toChannel(f(out)), {\n          concurrency: n,\n          mergeStrategy: MergeStrategy.BufferSliding(),\n          bufferSize\n        })\n      )\n    )\n)\n\n/** @internal */\nexport const flatten = dual<\n  (options?: {\n    readonly concurrency?: number | \"unbounded\" | undefined\n    readonly bufferSize?: number | undefined\n  }) => <A, E2, R2, E, R>(\n    self: Stream.Stream<Stream.Stream<A, E2, R2>, E, R>\n  ) => Stream.Stream<A, E | E2, R | R2>,\n  <A, E2, R2, E, R>(\n    self: Stream.Stream<Stream.Stream<A, E2, R2>, E, R>,\n    options?: {\n      readonly concurrency?: number | \"unbounded\" | undefined\n      readonly bufferSize?: number | undefined\n    }\n  ) => Stream.Stream<A, E | E2, R | R2>\n>((args) => isStream(args[0]), (self, options) => flatMap(self, identity, options))\n\n/** @internal */\nexport const flattenChunks = <A, E, R>(self: Stream.Stream<Chunk.Chunk<A>, E, R>): Stream.Stream<A, E, R> => {\n  const flatten: Channel.Channel<Chunk.Chunk<A>, Chunk.Chunk<Chunk.Chunk<A>>, E, E, unknown, unknown> = core\n    .readWithCause({\n      onInput: (chunks: Chunk.Chunk<Chunk.Chunk<A>>) =>\n        core.flatMap(\n          channel.writeChunk(chunks),\n          () => flatten\n        ),\n      onFailure: core.failCause,\n      onDone: () => core.void\n    })\n  return new StreamImpl(pipe(toChannel(self), core.pipeTo(flatten)))\n}\n\n/** @internal */\nexport const flattenEffect = dual<\n  (\n    options?: {\n      readonly concurrency?: number | \"unbounded\" | undefined\n      readonly unordered?: boolean | undefined\n    }\n  ) => <A, E2, R2, E, R>(\n    self: Stream.Stream<Effect.Effect<A, E2, R2>, E, R>\n  ) => Stream.Stream<A, E | E2, R | R2>,\n  <A, E2, R2, E, R>(\n    self: Stream.Stream<Effect.Effect<A, E2, R2>, E, R>,\n    options?: {\n      readonly concurrency?: number | \"unbounded\" | undefined\n      readonly unordered?: boolean | undefined\n    }\n  ) => Stream.Stream<A, E | E2, R | R2>\n>(\n  (args) => isStream(args[0]),\n  (self, options) =>\n    options?.unordered ?\n      flatMap(self, (a) => fromEffect(a), { concurrency: options.concurrency }) :\n      matchConcurrency(\n        options?.concurrency,\n        () => mapEffectSequential(self, identity),\n        (n) =>\n          new StreamImpl(\n            pipe(\n              toChannel(self),\n              channel.concatMap(channel.writeChunk),\n              channel.mapOutEffectPar(identity, n),\n              channel.mapOut(Chunk.of)\n            )\n          )\n      )\n)\n\n/** @internal */\nexport const flattenExitOption = <A, E2, E, R>(\n  self: Stream.Stream<Exit.Exit<A, Option.Option<E2>>, E, R>\n): Stream.Stream<A, E | E2, R> => {\n  const processChunk = (\n    chunk: Chunk.Chunk<Exit.Exit<A, Option.Option<E2>>>,\n    cont: Channel.Channel<Chunk.Chunk<A>, Chunk.Chunk<Exit.Exit<A, Option.Option<E2>>>, E | E2, E, unknown, unknown, R>\n  ) => {\n    const [toEmit, rest] = pipe(chunk, Chunk.splitWhere((exit) => !Exit.isSuccess(exit)))\n    const next = pipe(\n      Chunk.head(rest),\n      Option.match({\n        onNone: () => cont,\n        onSome: Exit.match({\n          onFailure: (cause) =>\n            Option.match(Cause.flipCauseOption(cause), {\n              onNone: () => core.void,\n              onSome: core.failCause\n            }),\n          onSuccess: () => core.void\n        })\n      })\n    )\n    return pipe(\n      core.write(pipe(\n        toEmit,\n        Chunk.filterMap((exit) =>\n          Exit.isSuccess(exit) ?\n            Option.some(exit.value) :\n            Option.none()\n        )\n      )),\n      core.flatMap(() => next)\n    )\n  }\n  const process: Channel.Channel<\n    Chunk.Chunk<A>,\n    Chunk.Chunk<Exit.Exit<A, Option.Option<E2>>>,\n    E | E2,\n    E,\n    unknown,\n    unknown,\n    R\n  > = core.readWithCause({\n    onInput: (chunk: Chunk.Chunk<Exit.Exit<A, Option.Option<E2>>>) => processChunk(chunk, process),\n    onFailure: (cause) => core.failCause<E | E2>(cause),\n    onDone: () => core.void\n  })\n  return new StreamImpl(pipe(toChannel(self), core.pipeTo(process)))\n}\n\n/** @internal */\nexport const flattenIterables = <A, E, R>(self: Stream.Stream<Iterable<A>, E, R>): Stream.Stream<A, E, R> =>\n  pipe(self, map(Chunk.fromIterable), flattenChunks)\n\n/** @internal */\nexport const flattenTake = <A, E2, E, R>(self: Stream.Stream<Take.Take<A, E2>, E, R>): Stream.Stream<A, E | E2, R> =>\n  flattenChunks(flattenExitOption(pipe(self, map((take) => take.exit))))\n\n/** @internal */\nexport const forever = <A, E, R>(self: Stream.Stream<A, E, R>): Stream.Stream<A, E, R> =>\n  new StreamImpl(channel.repeated(toChannel(self)))\n\n/** @internal */\nexport const fromAsyncIterable = <A, E>(\n  iterable: AsyncIterable<A>,\n  onError: (e: unknown) => E\n) =>\n  pipe(\n    Effect.acquireRelease(\n      Effect.sync(() => iterable[Symbol.asyncIterator]()),\n      (iterator) => iterator.return ? Effect.promise(async () => iterator.return!()) : Effect.void\n    ),\n    Effect.map((iterator) =>\n      repeatEffectOption(pipe(\n        Effect.tryPromise({\n          try: async () => iterator.next(),\n          catch: (reason) => Option.some(onError(reason))\n        }),\n        Effect.flatMap((result) => result.done ? Effect.fail(Option.none()) : Effect.succeed(result.value))\n      ))\n    ),\n    unwrapScoped\n  )\n\n/** @internal */\nexport const fromChannel = <A, E, R>(\n  channel: Channel.Channel<Chunk.Chunk<A>, unknown, E, unknown, unknown, unknown, R>\n): Stream.Stream<A, E, R> => new StreamImpl(channel)\n\n/** @internal */\nexport const toChannel = <A, E, R>(\n  stream: Stream.Stream<A, E, R>\n): Channel.Channel<Chunk.Chunk<A>, unknown, E, unknown, unknown, unknown, R> => {\n  if (\"channel\" in stream) {\n    return (stream as StreamImpl<A, E, R>).channel\n  } else if (Effect.isEffect(stream)) {\n    return toChannel(fromEffect(stream)) as any\n  } else {\n    throw new TypeError(`Expected a Stream.`)\n  }\n}\n\n/** @internal */\nexport const fromChunk = <A>(chunk: Chunk.Chunk<A>): Stream.Stream<A> =>\n  new StreamImpl(Chunk.isEmpty(chunk) ? core.void : core.write(chunk))\n\n/** @internal */\nexport const fromChunkPubSub: {\n  <A>(pubsub: PubSub.PubSub<Chunk.Chunk<A>>, options: {\n    readonly scoped: true\n    readonly shutdown?: boolean | undefined\n  }): Effect.Effect<Stream.Stream<A>, never, Scope.Scope>\n  <A>(pubsub: PubSub.PubSub<Chunk.Chunk<A>>, options?: {\n    readonly scoped?: false | undefined\n    readonly shutdown?: boolean | undefined\n  }): Stream.Stream<A>\n} = (pubsub, options): any => {\n  if (options?.scoped) {\n    const effect = Effect.map(PubSub.subscribe(pubsub), fromChunkQueue)\n    return options.shutdown ? Effect.map(effect, ensuring(PubSub.shutdown(pubsub))) : effect\n  }\n  const stream = flatMap(scoped(PubSub.subscribe(pubsub)), fromChunkQueue)\n  return options?.shutdown ? ensuring(stream, PubSub.shutdown(pubsub)) : stream\n}\n\n/** @internal */\nexport const fromChunkQueue = <A>(queue: Queue.Dequeue<Chunk.Chunk<A>>, options?: {\n  readonly shutdown?: boolean | undefined\n}): Stream.Stream<A> =>\n  pipe(\n    Queue.take(queue),\n    Effect.catchAllCause((cause) =>\n      pipe(\n        Queue.isShutdown(queue),\n        Effect.flatMap((isShutdown) =>\n          isShutdown && Cause.isInterrupted(cause) ?\n            pull.end() :\n            pull.failCause(cause)\n        )\n      )\n    ),\n    repeatEffectChunkOption,\n    options?.shutdown ? ensuring(Queue.shutdown(queue)) : identity\n  )\n\n/** @internal */\nexport const fromChunks = <A>(\n  ...chunks: Array<Chunk.Chunk<A>>\n): Stream.Stream<A> => pipe(fromIterable(chunks), flatMap(fromChunk))\n\n/** @internal */\nexport const fromEffect = <A, E, R>(effect: Effect.Effect<A, E, R>): Stream.Stream<A, E, R> =>\n  pipe(effect, Effect.mapError(Option.some), fromEffectOption)\n\n/** @internal */\nexport const fromEffectOption = <A, E, R>(effect: Effect.Effect<A, Option.Option<E>, R>): Stream.Stream<A, E, R> =>\n  new StreamImpl(\n    channel.unwrap(\n      Effect.match(effect, {\n        onFailure: Option.match({\n          onNone: () => core.void,\n          onSome: core.fail\n        }),\n        onSuccess: (a) => core.write(Chunk.of(a))\n      })\n    )\n  )\n\n/** @internal */\nexport const fromPubSub: {\n  <A>(pubsub: PubSub.PubSub<A>, options: {\n    readonly scoped: true\n    readonly maxChunkSize?: number | undefined\n    readonly shutdown?: boolean | undefined\n  }): Effect.Effect<Stream.Stream<A>, never, Scope.Scope>\n  <A>(pubsub: PubSub.PubSub<A>, options?: {\n    readonly scoped?: false | undefined\n    readonly maxChunkSize?: number | undefined\n    readonly shutdown?: boolean | undefined\n  }): Stream.Stream<A>\n} = (pubsub, options): any => {\n  const maxChunkSize = options?.maxChunkSize ?? DefaultChunkSize\n\n  if (options?.scoped) {\n    const effect = Effect.map(\n      PubSub.subscribe(pubsub),\n      (queue) => fromQueue(queue, { maxChunkSize, shutdown: true })\n    )\n\n    return options.shutdown ? Effect.map(effect, ensuring(PubSub.shutdown(pubsub))) : effect\n  }\n  const stream = flatMap(\n    scoped(PubSub.subscribe(pubsub)),\n    (queue) => fromQueue(queue, { maxChunkSize })\n  )\n  return options?.shutdown ? ensuring(stream, PubSub.shutdown(pubsub)) : stream\n}\n\n/** @internal */\nexport const fromTPubSub = <A>(pubsub: TPubSub.TPubSub<A>): Stream.Stream<A> => {\n  return unwrapScoped(Effect.map(\n    TPubSub.subscribeScoped(pubsub),\n    (queue) => fromTQueue(queue)\n  ))\n}\n\n/** @internal */\nexport const fromIterable = <A>(iterable: Iterable<A>): Stream.Stream<A> =>\n  suspend(() =>\n    Chunk.isChunk(iterable) ?\n      fromChunk(iterable) :\n      fromIteratorSucceed(iterable[Symbol.iterator]())\n  )\n\n/** @internal */\nexport const fromIterableEffect = <A, E, R>(\n  effect: Effect.Effect<Iterable<A>, E, R>\n): Stream.Stream<A, E, R> => pipe(effect, Effect.map(fromIterable), unwrap)\n\n/** @internal */\nexport const fromIteratorSucceed = <A>(\n  iterator: Iterator<A>,\n  maxChunkSize = DefaultChunkSize\n): Stream.Stream<A> => {\n  return pipe(\n    Effect.sync(() => {\n      let builder: Array<A> = []\n      const loop = (\n        iterator: Iterator<A>\n      ): Channel.Channel<Chunk.Chunk<A>, unknown, never, unknown, unknown, unknown> =>\n        pipe(\n          Effect.sync(() => {\n            let next: IteratorResult<A, any> = iterator.next()\n            if (maxChunkSize === 1) {\n              if (next.done) {\n                return core.void\n              }\n              return pipe(\n                core.write(Chunk.of(next.value)),\n                core.flatMap(() => loop(iterator))\n              )\n            }\n            builder = []\n            let count = 0\n            while (next.done === false) {\n              builder.push(next.value)\n              count = count + 1\n              if (count >= maxChunkSize) {\n                break\n              }\n              next = iterator.next()\n            }\n            if (count > 0) {\n              return pipe(\n                core.write(Chunk.unsafeFromArray(builder)),\n                core.flatMap(() => loop(iterator))\n              )\n            }\n            return core.void\n          }),\n          channel.unwrap\n        )\n      return new StreamImpl(loop(iterator))\n    }),\n    unwrap\n  )\n}\n\n/** @internal */\nexport const fromPull = <R, R2, E, A>(\n  effect: Effect.Effect<Effect.Effect<Chunk.Chunk<A>, Option.Option<E>, R2>, never, R | Scope.Scope>\n): Stream.Stream<A, E, Exclude<R, Scope.Scope> | R2> => pipe(effect, Effect.map(repeatEffectChunkOption), unwrapScoped)\n\n/** @internal */\nexport const fromQueue = <A>(\n  queue: Queue.Dequeue<A>,\n  options?: {\n    readonly maxChunkSize?: number | undefined\n    readonly shutdown?: boolean | undefined\n  }\n): Stream.Stream<A> =>\n  pipe(\n    Queue.takeBetween(queue, 1, options?.maxChunkSize ?? DefaultChunkSize),\n    Effect.catchAllCause((cause) =>\n      pipe(\n        Queue.isShutdown(queue),\n        Effect.flatMap((isShutdown) =>\n          isShutdown && Cause.isInterrupted(cause) ?\n            pull.end() :\n            pull.failCause(cause)\n        )\n      )\n    ),\n    repeatEffectChunkOption,\n    options?.shutdown ? ensuring(Queue.shutdown(queue)) : identity\n  )\n\n/** @internal */\nexport const fromTQueue = <A>(queue: TQueue.TDequeue<A>): Stream.Stream<A> =>\n  pipe(\n    TQueue.take(queue),\n    Effect.map(Chunk.of),\n    Effect.catchAllCause((cause) =>\n      pipe(\n        TQueue.isShutdown(queue),\n        Effect.flatMap((isShutdown) =>\n          isShutdown && Cause.isInterrupted(cause) ?\n            pull.end() :\n            pull.failCause(cause)\n        )\n      )\n    ),\n    repeatEffectChunkOption\n  )\n\n/** @internal */\nexport const fromSchedule = <A, R>(schedule: Schedule.Schedule<A, unknown, R>): Stream.Stream<A, never, R> =>\n  pipe(\n    Schedule.driver(schedule),\n    Effect.map((driver) => repeatEffectOption(driver.next(void 0))),\n    unwrap\n  )\n\n/** @internal */\nexport const fromReadableStream: {\n  <A, E>(\n    options: {\n      readonly evaluate: LazyArg<ReadableStream<A>>\n      readonly onError: (error: unknown) => E\n      readonly releaseLockOnEnd?: boolean | undefined\n    }\n  ): Stream.Stream<A, E>\n  <A, E>(\n    evaluate: LazyArg<ReadableStream<A>>,\n    onError: (error: unknown) => E\n  ): Stream.Stream<A, E>\n} = <A, E>(\n  ...args: [options: {\n    readonly evaluate: LazyArg<ReadableStream<A>>\n    readonly onError: (error: unknown) => E\n    readonly releaseLockOnEnd?: boolean | undefined\n  }] | [\n    evaluate: LazyArg<ReadableStream<A>>,\n    onError: (error: unknown) => E\n  ]\n): Stream.Stream<A, E> => {\n  const evaluate = args.length === 1 ? args[0].evaluate : args[0]\n  const onError = args.length === 1 ? args[0].onError : args[1]\n  const releaseLockOnEnd = args.length === 1 ? args[0].releaseLockOnEnd === true : false\n  return unwrapScoped(Effect.map(\n    Effect.acquireRelease(\n      Effect.sync(() => evaluate().getReader()),\n      (reader) =>\n        releaseLockOnEnd\n          ? Effect.sync(() => reader.releaseLock())\n          : Effect.promise(() => reader.cancel())\n    ),\n    (reader) =>\n      repeatEffectOption(\n        Effect.flatMap(\n          Effect.tryPromise({\n            try: () => reader.read(),\n            catch: (reason) => Option.some(onError(reason))\n          }),\n          ({ done, value }) => done ? Effect.fail(Option.none()) : Effect.succeed(value)\n        )\n      )\n  ))\n}\n\n/** @internal */\nexport const fromReadableStreamByob: {\n  <E>(\n    options: {\n      readonly evaluate: LazyArg<ReadableStream<Uint8Array>>\n      readonly onError: (error: unknown) => E\n      readonly bufferSize?: number | undefined\n      readonly releaseLockOnEnd?: boolean | undefined\n    }\n  ): Stream.Stream<Uint8Array, E>\n  <E>(\n    evaluate: LazyArg<ReadableStream<Uint8Array>>,\n    onError: (error: unknown) => E,\n    allocSize?: number\n  ): Stream.Stream<Uint8Array, E>\n} = <E>(\n  ...args: [options: {\n    readonly evaluate: LazyArg<ReadableStream<Uint8Array>>\n    readonly onError: (error: unknown) => E\n    readonly bufferSize?: number | undefined\n    readonly releaseLockOnEnd?: boolean | undefined\n  }] | [\n    evaluate: LazyArg<ReadableStream<Uint8Array>>,\n    onError: (error: unknown) => E,\n    allocSize?: number | undefined\n  ]\n): Stream.Stream<Uint8Array, E> => {\n  const evaluate = args.length === 1 ? args[0].evaluate : args[0]\n  const onError = args.length === 1 ? args[0].onError : args[1]\n  const allocSize = (args.length === 1 ? args[0].bufferSize : args[2]) ?? 4096\n  const releaseLockOnEnd = args.length === 1 ? args[0].releaseLockOnEnd === true : false\n  return unwrapScoped(Effect.map(\n    Effect.acquireRelease(\n      Effect.sync(() => evaluate().getReader({ mode: \"byob\" })),\n      (reader) => releaseLockOnEnd ? Effect.sync(() => reader.releaseLock()) : Effect.promise(() => reader.cancel())\n    ),\n    (reader) =>\n      catchAll(\n        forever(readChunkStreamByobReader(reader, onError, allocSize)),\n        (error) => error === EOF ? empty : fail(error)\n      )\n  ))\n}\n\nconst EOF = Symbol.for(\"effect/Stream/EOF\")\n\nconst readChunkStreamByobReader = <E>(\n  reader: ReadableStreamBYOBReader,\n  onError: (error: unknown) => E,\n  size: number\n): Stream.Stream<Uint8Array, E | typeof EOF> => {\n  const buffer = new ArrayBuffer(size)\n  return paginateEffect(0, (offset) =>\n    Effect.flatMap(\n      Effect.tryPromise({\n        try: () => reader.read(new Uint8Array(buffer, offset, buffer.byteLength - offset)),\n        catch: (reason) => onError(reason)\n      }),\n      ({ done, value }) => {\n        if (done) {\n          return Effect.fail(EOF)\n        }\n        const newOffset = offset + value.byteLength\n        return Effect.succeed([\n          value,\n          newOffset >= buffer.byteLength\n            ? Option.none<number>()\n            : Option.some(newOffset)\n        ])\n      }\n    ))\n}\n\n/** @internal */\nexport const groupAdjacentBy = dual<\n  <A, K>(\n    f: (a: A) => K\n  ) => <E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<[K, Chunk.NonEmptyChunk<A>], E, R>,\n  <A, E, R, K>(\n    self: Stream.Stream<A, E, R>,\n    f: (a: A) => K\n  ) => Stream.Stream<[K, Chunk.NonEmptyChunk<A>], E, R>\n>(\n  2,\n  <A, E, R, K>(\n    self: Stream.Stream<A, E, R>,\n    f: (a: A) => K\n  ): Stream.Stream<[K, Chunk.NonEmptyChunk<A>], E, R> => {\n    type Output = [K, Chunk.NonEmptyChunk<A>]\n    const groupAdjacentByChunk = (\n      state: Option.Option<Output>,\n      chunk: Chunk.Chunk<A>\n    ): [Option.Option<Output>, Chunk.Chunk<Output>] => {\n      if (Chunk.isEmpty(chunk)) {\n        return [state, Chunk.empty()]\n      }\n      const builder: Array<Output> = []\n      let from = 0\n      let until = 0\n      let key: K | undefined = undefined\n      let previousChunk = Chunk.empty<A>()\n      switch (state._tag) {\n        case \"Some\": {\n          const tuple = state.value\n          key = tuple[0]\n          let loop = true\n          while (loop && until < chunk.length) {\n            const input = Chunk.unsafeGet(chunk, until)\n            const updatedKey = f(input)\n            if (!Equal.equals(key, updatedKey)) {\n              const previousChunk = tuple[1]\n              const additionalChunk = Chunk.unsafeFromArray(Array.from(chunk).slice(from, until))\n              const group = Chunk.appendAll(previousChunk, additionalChunk)\n              builder.push([key, group])\n              key = updatedKey\n              from = until\n              loop = false\n            }\n            until = until + 1\n          }\n          if (loop) {\n            previousChunk = tuple[1]\n          }\n          break\n        }\n        case \"None\": {\n          key = f(Chunk.unsafeGet(chunk, until))\n          until = until + 1\n          break\n        }\n      }\n      while (until < chunk.length) {\n        const input = Chunk.unsafeGet(chunk, until)\n        const updatedKey = f(input)\n        if (!Equal.equals(key, updatedKey)) {\n          builder.push([key, Chunk.unsafeFromArray(Array.from(chunk).slice(from, until)) as Chunk.NonEmptyChunk<A>])\n          key = updatedKey\n          from = until\n        }\n        until = until + 1\n      }\n      const nonEmptyChunk = Chunk.appendAll(previousChunk, Chunk.unsafeFromArray(Array.from(chunk).slice(from, until)))\n      const output = Chunk.unsafeFromArray(builder)\n      return [Option.some([key, nonEmptyChunk as Chunk.NonEmptyChunk<A>]), output]\n    }\n\n    const groupAdjacent = (\n      state: Option.Option<Output>\n    ): Channel.Channel<Chunk.Chunk<Output>, Chunk.Chunk<A>, never, never, unknown, unknown> =>\n      core.readWithCause({\n        onInput: (input: Chunk.Chunk<A>) => {\n          const [updatedState, output] = groupAdjacentByChunk(state, input)\n          return Chunk.isEmpty(output)\n            ? groupAdjacent(updatedState)\n            : core.flatMap(core.write(output), () => groupAdjacent(updatedState))\n        },\n        onFailure: (cause) =>\n          Option.match(state, {\n            onNone: () => core.failCause(cause),\n            onSome: (output) => core.flatMap(core.write(Chunk.of(output)), () => core.failCause(cause))\n          }),\n        onDone: (done) =>\n          Option.match(state, {\n            onNone: () => core.succeedNow(done),\n            onSome: (output) => core.flatMap(core.write(Chunk.of(output)), () => core.succeedNow(done))\n          })\n      })\n    return new StreamImpl(channel.pipeToOrFail(toChannel(self), groupAdjacent(Option.none())))\n  }\n)\n\n/** @internal */\nexport const grouped = dual<\n  (chunkSize: number) => <A, E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<Chunk.Chunk<A>, E, R>,\n  <A, E, R>(self: Stream.Stream<A, E, R>, chunkSize: number) => Stream.Stream<Chunk.Chunk<A>, E, R>\n>(\n  2,\n  <A, E, R>(self: Stream.Stream<A, E, R>, chunkSize: number): Stream.Stream<Chunk.Chunk<A>, E, R> =>\n    pipe(self, rechunk(chunkSize), chunks)\n)\n\n/** @internal */\nexport const groupedWithin = dual<\n  (\n    chunkSize: number,\n    duration: Duration.DurationInput\n  ) => <A, E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<Chunk.Chunk<A>, E, R>,\n  <A, E, R>(\n    self: Stream.Stream<A, E, R>,\n    chunkSize: number,\n    duration: Duration.DurationInput\n  ) => Stream.Stream<Chunk.Chunk<A>, E, R>\n>(\n  3,\n  <A, E, R>(\n    self: Stream.Stream<A, E, R>,\n    chunkSize: number,\n    duration: Duration.DurationInput\n  ): Stream.Stream<Chunk.Chunk<A>, E, R> =>\n    aggregateWithin(self, sink_.collectAllN(chunkSize), Schedule.spaced(duration))\n)\n\n/** @internal */\nexport const haltWhen = dual<\n  <X, E2, R2>(\n    effect: Effect.Effect<X, E2, R2>\n  ) => <A, E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A, E2 | E, R2 | R>,\n  <A, E, R, X, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    effect: Effect.Effect<X, E2, R2>\n  ) => Stream.Stream<A, E2 | E, R2 | R>\n>(\n  2,\n  <A, E, R, X, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    effect: Effect.Effect<X, E2, R2>\n  ): Stream.Stream<A, E | E2, R | R2> => {\n    const writer = (\n      fiber: Fiber.Fiber<X, E2>\n    ): Channel.Channel<Chunk.Chunk<A>, Chunk.Chunk<A>, E | E2, E | E2, void, unknown, R2> =>\n      pipe(\n        Fiber.poll(fiber),\n        Effect.map(Option.match({\n          onNone: () =>\n            core.readWith({\n              onInput: (input: Chunk.Chunk<A>) => core.flatMap(core.write(input), () => writer(fiber)),\n              onFailure: core.fail,\n              onDone: () => core.void\n            }),\n          onSome: Exit.match({\n            onFailure: core.failCause,\n            onSuccess: () => core.void\n          })\n        })),\n        channel.unwrap\n      )\n    return new StreamImpl(\n      channel.unwrapScopedWith((scope) =>\n        effect.pipe(\n          Effect.forkIn(scope),\n          Effect.map((fiber) => toChannel(self).pipe(core.pipeTo(writer(fiber))))\n        )\n      )\n    )\n  }\n)\n\n/** @internal */\nexport const haltAfter = dual<\n  (duration: Duration.DurationInput) => <A, E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A, E, R>,\n  <A, E, R>(self: Stream.Stream<A, E, R>, duration: Duration.DurationInput) => Stream.Stream<A, E, R>\n>(\n  2,\n  <A, E, R>(self: Stream.Stream<A, E, R>, duration: Duration.DurationInput): Stream.Stream<A, E, R> =>\n    pipe(self, haltWhen(Clock.sleep(duration)))\n)\n\n/** @internal */\nexport const haltWhenDeferred = dual<\n  <X, E2>(deferred: Deferred.Deferred<X, E2>) => <A, E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A, E2 | E, R>,\n  <A, E, R, X, E2>(self: Stream.Stream<A, E, R>, deferred: Deferred.Deferred<X, E2>) => Stream.Stream<A, E2 | E, R>\n>(\n  2,\n  <A, E, R, X, E2>(self: Stream.Stream<A, E, R>, deferred: Deferred.Deferred<X, E2>): Stream.Stream<A, E | E2, R> => {\n    const writer: Channel.Channel<Chunk.Chunk<A>, Chunk.Chunk<A>, E | E2, E | E2, void, unknown, R> = pipe(\n      Deferred.poll(deferred),\n      Effect.map(Option.match({\n        onNone: () =>\n          core.readWith({\n            onInput: (input: Chunk.Chunk<A>) => pipe(core.write(input), core.flatMap(() => writer)),\n            onFailure: core.fail,\n            onDone: () => core.void\n          }),\n        onSome: (effect) =>\n          channel.unwrap(Effect.match(effect, {\n            onFailure: core.fail,\n            onSuccess: () => core.void\n          }))\n      })),\n      channel.unwrap\n    )\n    return new StreamImpl(pipe(toChannel(self), core.pipeTo(writer)))\n  }\n)\n\n/** @internal */\nexport const identityStream = <A, E = never, R = never>(): Stream.Stream<A, E, R> =>\n  new StreamImpl(\n    channel.identityChannel() as Channel.Channel<Chunk.Chunk<A>, unknown, E, unknown, unknown, unknown>\n  )\n\n/** @internal */\nexport const interleave = dual<\n  <A2, E2, R2>(\n    that: Stream.Stream<A2, E2, R2>\n  ) => <A, E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A2 | A, E2 | E, R2 | R>,\n  <A, E, R, A2, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    that: Stream.Stream<A2, E2, R2>\n  ) => Stream.Stream<A2 | A, E2 | E, R2 | R>\n>(\n  2,\n  <A, E, R, A2, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    that: Stream.Stream<A2, E2, R2>\n  ): Stream.Stream<A2 | A, E2 | E, R2 | R> => pipe(self, interleaveWith(that, forever(make(true, false))))\n)\n\n/** @internal */\nexport const interleaveWith = dual<\n  <A2, E2, R2, E3, R3>(\n    that: Stream.Stream<A2, E2, R2>,\n    decider: Stream.Stream<boolean, E3, R3>\n  ) => <A, E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A2 | A, E2 | E3 | E, R2 | R3 | R>,\n  <A, E, R, A2, E2, R2, E3, R3>(\n    self: Stream.Stream<A, E, R>,\n    that: Stream.Stream<A2, E2, R2>,\n    decider: Stream.Stream<boolean, E3, R3>\n  ) => Stream.Stream<A2 | A, E2 | E3 | E, R2 | R3 | R>\n>(\n  3,\n  <A, E, R, A2, E2, R2, E3, R3>(\n    self: Stream.Stream<A, E, R>,\n    that: Stream.Stream<A2, E2, R2>,\n    decider: Stream.Stream<boolean, E3, R3>\n  ): Stream.Stream<A2 | A, E2 | E3 | E, R2 | R3 | R> => {\n    const producer = (\n      handoff: Handoff.Handoff<Take.Take<A | A2, E | E2 | E3>>\n    ): Channel.Channel<never, A | A2, never, E | E2 | E3, void, unknown, R | R2 | R3> =>\n      core.readWithCause({\n        onInput: (value: A | A2) =>\n          core.flatMap(\n            core.fromEffect(\n              Handoff.offer<Take.Take<A | A2, E | E2 | E3>>(handoff, InternalTake.of(value))\n            ),\n            () => producer(handoff)\n          ),\n        onFailure: (cause) =>\n          core.fromEffect(\n            Handoff.offer<Take.Take<A | A2, E | E2 | E3>>(\n              handoff,\n              InternalTake.failCause(cause)\n            )\n          ),\n        onDone: () =>\n          core.fromEffect(\n            Handoff.offer<Take.Take<A | A2, E | E2 | E3>>(handoff, InternalTake.end)\n          )\n      })\n    return new StreamImpl(\n      channel.unwrapScopedWith((scope) =>\n        pipe(\n          Handoff.make<Take.Take<A | A2, E | E2 | E3>>(),\n          Effect.zip(Handoff.make<Take.Take<A | A2, E | E2 | E3>>()),\n          Effect.tap(([left]) =>\n            toChannel(self).pipe(\n              channel.concatMap(channel.writeChunk),\n              core.pipeTo(producer(left)),\n              channelExecutor.runIn(scope),\n              Effect.forkIn(scope)\n            )\n          ),\n          Effect.tap(([_, right]) =>\n            toChannel(that).pipe(\n              channel.concatMap(channel.writeChunk),\n              core.pipeTo(producer(right)),\n              channelExecutor.runIn(scope),\n              Effect.forkIn(scope)\n            )\n          ),\n          Effect.map(([left, right]) => {\n            const process = (\n              leftDone: boolean,\n              rightDone: boolean\n            ): Channel.Channel<Chunk.Chunk<A | A2>, boolean, E | E2 | E3, E | E2 | E3, void, unknown, R> =>\n              core.readWithCause({\n                onInput: (bool: boolean) => {\n                  if (bool && !leftDone) {\n                    return pipe(\n                      core.fromEffect(Handoff.take(left)),\n                      core.flatMap(InternalTake.match({\n                        onEnd: () => rightDone ? core.void : process(true, rightDone),\n                        onFailure: core.failCause,\n                        onSuccess: (chunk) => pipe(core.write(chunk), core.flatMap(() => process(leftDone, rightDone)))\n                      }))\n                    )\n                  }\n                  if (!bool && !rightDone) {\n                    return pipe(\n                      core.fromEffect(Handoff.take(right)),\n                      core.flatMap(InternalTake.match({\n                        onEnd: () => leftDone ? core.void : process(leftDone, true),\n                        onFailure: core.failCause,\n                        onSuccess: (chunk) => pipe(core.write(chunk), core.flatMap(() => process(leftDone, rightDone)))\n                      }))\n                    )\n                  }\n                  return process(leftDone, rightDone)\n                },\n                onFailure: core.failCause,\n                onDone: () => core.void\n              })\n            return pipe(\n              toChannel(decider),\n              channel.concatMap(channel.writeChunk),\n              core.pipeTo(process(false, false))\n            )\n          })\n        )\n      )\n    )\n  }\n)\n\n/** @internal */\nexport const intersperse = dual<\n  <A2>(element: A2) => <A, E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A2 | A, E, R>,\n  <A, E, R, A2>(self: Stream.Stream<A, E, R>, element: A2) => Stream.Stream<A2 | A, E, R>\n>(2, <A, E, R, A2>(self: Stream.Stream<A, E, R>, element: A2): Stream.Stream<A2 | A, E, R> =>\n  new StreamImpl(\n    pipe(\n      toChannel(self),\n      channel.pipeToOrFail(\n        core.suspend(() => {\n          const writer = (\n            isFirst: boolean\n          ): Channel.Channel<Chunk.Chunk<A | A2>, Chunk.Chunk<A>, E, E, unknown, unknown> =>\n            core.readWithCause({\n              onInput: (chunk: Chunk.Chunk<A>) => {\n                const builder: Array<A | A2> = []\n                let flagResult = isFirst\n                for (const output of chunk) {\n                  if (flagResult) {\n                    flagResult = false\n                    builder.push(output)\n                  } else {\n                    builder.push(element)\n                    builder.push(output)\n                  }\n                }\n                return pipe(\n                  core.write(Chunk.unsafeFromArray(builder)),\n                  core.flatMap(() => writer(flagResult))\n                )\n              },\n              onFailure: core.failCause,\n              onDone: () => core.void\n            })\n          return writer(true)\n        })\n      )\n    )\n  ))\n\n/** @internal */\nexport const intersperseAffixes = dual<\n  <A2, A3, A4>(\n    options: {\n      readonly start: A2\n      readonly middle: A3\n      readonly end: A4\n    }\n  ) => <A, E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A2 | A3 | A4 | A, E, R>,\n  <A, E, R, A2, A3, A4>(\n    self: Stream.Stream<A, E, R>,\n    options: {\n      readonly start: A2\n      readonly middle: A3\n      readonly end: A4\n    }\n  ) => Stream.Stream<A2 | A3 | A4 | A, E, R>\n>(\n  2,\n  <A, E, R, A2, A3, A4>(\n    self: Stream.Stream<A, E, R>,\n    { end, middle, start }: {\n      readonly start: A2\n      readonly middle: A3\n      readonly end: A4\n    }\n  ): Stream.Stream<A2 | A3 | A4 | A, E, R> =>\n    pipe(\n      make(start),\n      concat(pipe(self, intersperse(middle))),\n      concat(make(end))\n    )\n)\n\n/** @internal */\nexport const interruptAfter = dual<\n  (duration: Duration.DurationInput) => <A, E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A, E, R>,\n  <A, E, R>(self: Stream.Stream<A, E, R>, duration: Duration.DurationInput) => Stream.Stream<A, E, R>\n>(\n  2,\n  <A, E, R>(self: Stream.Stream<A, E, R>, duration: Duration.DurationInput): Stream.Stream<A, E, R> =>\n    pipe(self, interruptWhen(Clock.sleep(duration)))\n)\n\n/** @internal */\nexport const interruptWhen = dual<\n  <X, E2, R2>(\n    effect: Effect.Effect<X, E2, R2>\n  ) => <A, E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A, E2 | E, R2 | R>,\n  <A, E, R, X, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    effect: Effect.Effect<X, E2, R2>\n  ) => Stream.Stream<A, E2 | E, R2 | R>\n>(\n  2,\n  <A, E, R, X, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    effect: Effect.Effect<X, E2, R2>\n  ): Stream.Stream<A, E | E2, R | R2> => new StreamImpl(pipe(toChannel(self), channel.interruptWhen(effect)))\n)\n\n/** @internal */\nexport const interruptWhenDeferred = dual<\n  <X, E2>(deferred: Deferred.Deferred<X, E2>) => <A, E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A, E2 | E, R>,\n  <A, E, R, X, E2>(self: Stream.Stream<A, E, R>, deferred: Deferred.Deferred<X, E2>) => Stream.Stream<A, E2 | E, R>\n>(\n  2,\n  <A, E, R, X, E2>(self: Stream.Stream<A, E, R>, deferred: Deferred.Deferred<X, E2>): Stream.Stream<A, E2 | E, R> =>\n    new StreamImpl(pipe(toChannel(self), channel.interruptWhenDeferred(deferred)))\n)\n\n/** @internal */\nexport const iterate = <A>(value: A, next: (value: A) => A): Stream.Stream<A> =>\n  unfold(value, (a) => Option.some([a, next(a)] as const))\n\n/** @internal */\nexport const make = <As extends Array<any>>(...as: As): Stream.Stream<As[number]> => fromIterable(as)\n\n/** @internal */\nexport const map = dual<\n  <A, B>(f: (a: A) => B) => <E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<B, E, R>,\n  <A, E, R, B>(self: Stream.Stream<A, E, R>, f: (a: A) => B) => Stream.Stream<B, E, R>\n>(\n  2,\n  <A, E, R, B>(self: Stream.Stream<A, E, R>, f: (a: A) => B): Stream.Stream<B, E, R> =>\n    new StreamImpl(pipe(toChannel(self), channel.mapOut(Chunk.map(f))))\n)\n\n/** @internal */\nexport const mapAccum = dual<\n  <S, A, A2>(\n    s: S,\n    f: (s: S, a: A) => readonly [S, A2]\n  ) => <E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A2, E, R>,\n  <A, E, R, S, A2>(self: Stream.Stream<A, E, R>, s: S, f: (s: S, a: A) => readonly [S, A2]) => Stream.Stream<A2, E, R>\n>(\n  3,\n  <A, E, R, S, A2>(\n    self: Stream.Stream<A, E, R>,\n    s: S,\n    f: (s: S, a: A) => readonly [S, A2]\n  ): Stream.Stream<A2, E, R> => {\n    const accumulator = (s: S): Channel.Channel<Chunk.Chunk<A2>, Chunk.Chunk<A>, E, E, void, unknown> =>\n      core.readWith({\n        onInput: (input: Chunk.Chunk<A>) => {\n          const [nextS, chunk] = Chunk.mapAccum(input, s, f)\n          return core.flatMap(\n            core.write(chunk),\n            () => accumulator(nextS)\n          )\n        },\n        onFailure: core.fail,\n        onDone: () => core.void\n      })\n    return new StreamImpl(pipe(toChannel(self), core.pipeTo(accumulator(s))))\n  }\n)\n\n/** @internal */\nexport const mapAccumEffect = dual<\n  <S, A, A2, E2, R2>(\n    s: S,\n    f: (s: S, a: A) => Effect.Effect<readonly [S, A2], E2, R2>\n  ) => <E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A2, E2 | E, R2 | R>,\n  <A, E, R, S, A2, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    s: S,\n    f: (s: S, a: A) => Effect.Effect<readonly [S, A2], E2, R2>\n  ) => Stream.Stream<A2, E2 | E, R2 | R>\n>(\n  3,\n  <A, E, R, S, A2, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    s: S,\n    f: (s: S, a: A) => Effect.Effect<readonly [S, A2], E2, R2>\n  ): Stream.Stream<A2, E | E2, R | R2> =>\n    suspend(() => {\n      const accumulator = (\n        s: S\n      ): Channel.Channel<Chunk.Chunk<A2>, Chunk.Chunk<A>, E | E2, E, unknown, unknown, R | R2> =>\n        core.readWith({\n          onInput: (input: Chunk.Chunk<A>) =>\n            pipe(\n              Effect.suspend(() => {\n                const outputs: Array<A2> = []\n                const emit = (output: A2) =>\n                  Effect.sync(() => {\n                    outputs.push(output)\n                  })\n                return pipe(\n                  input,\n                  Effect.reduce(s, (s, a) =>\n                    pipe(\n                      f(s, a),\n                      Effect.flatMap(([s, a]) => pipe(emit(a), Effect.as(s)))\n                    )),\n                  Effect.match({\n                    onFailure: (error) => {\n                      if (outputs.length !== 0) {\n                        return channel.zipRight(core.write(Chunk.unsafeFromArray(outputs)), core.fail(error))\n                      }\n                      return core.fail(error)\n                    },\n                    onSuccess: (s) => core.flatMap(core.write(Chunk.unsafeFromArray(outputs)), () => accumulator(s))\n                  })\n                )\n              }),\n              channel.unwrap\n            ),\n          onFailure: core.fail,\n          onDone: () => core.void\n        })\n      return new StreamImpl(pipe(toChannel(self), channel.pipeToOrFail(accumulator(s))))\n    })\n)\n\n/** @internal */\nexport const mapBoth = dual<\n  <E, E2, A, A2>(\n    options: {\n      readonly onFailure: (e: E) => E2\n      readonly onSuccess: (a: A) => A2\n    }\n  ) => <R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A2, E2, R>,\n  <A, E, R, E2, A2>(\n    self: Stream.Stream<A, E, R>,\n    options: {\n      readonly onFailure: (e: E) => E2\n      readonly onSuccess: (a: A) => A2\n    }\n  ) => Stream.Stream<A2, E2, R>\n>(\n  2,\n  <A, E, R, E2, A2>(\n    self: Stream.Stream<A, E, R>,\n    options: {\n      readonly onFailure: (e: E) => E2\n      readonly onSuccess: (a: A) => A2\n    }\n  ): Stream.Stream<A2, E2, R> => pipe(self, mapError(options.onFailure), map(options.onSuccess))\n)\n\n/** @internal */\nexport const mapChunks = dual<\n  <A, B>(\n    f: (chunk: Chunk.Chunk<A>) => Chunk.Chunk<B>\n  ) => <E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<B, E, R>,\n  <A, E, R, B>(self: Stream.Stream<A, E, R>, f: (chunk: Chunk.Chunk<A>) => Chunk.Chunk<B>) => Stream.Stream<B, E, R>\n>(\n  2,\n  <A, E, R, B>(self: Stream.Stream<A, E, R>, f: (chunk: Chunk.Chunk<A>) => Chunk.Chunk<B>): Stream.Stream<B, E, R> =>\n    new StreamImpl(pipe(toChannel(self), channel.mapOut(f)))\n)\n\n/** @internal */\nexport const mapChunksEffect = dual<\n  <A, B, E2, R2>(\n    f: (chunk: Chunk.Chunk<A>) => Effect.Effect<Chunk.Chunk<B>, E2, R2>\n  ) => <E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<B, E2 | E, R2 | R>,\n  <A, E, R, B, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    f: (chunk: Chunk.Chunk<A>) => Effect.Effect<Chunk.Chunk<B>, E2, R2>\n  ) => Stream.Stream<B, E2 | E, R2 | R>\n>(\n  2,\n  <A, E, R, B, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    f: (chunk: Chunk.Chunk<A>) => Effect.Effect<Chunk.Chunk<B>, E2, R2>\n  ): Stream.Stream<B, E2 | E, R2 | R> => new StreamImpl(pipe(toChannel(self), channel.mapOutEffect(f)))\n)\n\n/** @internal */\nexport const mapConcat = dual<\n  <A, A2>(f: (a: A) => Iterable<A2>) => <E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A2, E, R>,\n  <A, E, R, A2>(self: Stream.Stream<A, E, R>, f: (a: A) => Iterable<A2>) => Stream.Stream<A2, E, R>\n>(\n  2,\n  <A, E, R, A2>(self: Stream.Stream<A, E, R>, f: (a: A) => Iterable<A2>): Stream.Stream<A2, E, R> =>\n    pipe(self, mapConcatChunk((a) => Chunk.fromIterable(f(a))))\n)\n\n/** @internal */\nexport const mapConcatChunk = dual<\n  <A, A2>(f: (a: A) => Chunk.Chunk<A2>) => <E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A2, E, R>,\n  <A, E, R, A2>(self: Stream.Stream<A, E, R>, f: (a: A) => Chunk.Chunk<A2>) => Stream.Stream<A2, E, R>\n>(\n  2,\n  <A, E, R, A2>(self: Stream.Stream<A, E, R>, f: (a: A) => Chunk.Chunk<A2>): Stream.Stream<A2, E, R> =>\n    pipe(self, mapChunks(Chunk.flatMap(f)))\n)\n\n/** @internal */\nexport const mapConcatChunkEffect = dual<\n  <A, A2, E2, R2>(\n    f: (a: A) => Effect.Effect<Chunk.Chunk<A2>, E2, R2>\n  ) => <E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A2, E2 | E, R2 | R>,\n  <A, E, R, A2, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    f: (a: A) => Effect.Effect<Chunk.Chunk<A2>, E2, R2>\n  ) => Stream.Stream<A2, E2 | E, R2 | R>\n>(\n  2,\n  <A, E, R, A2, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    f: (a: A) => Effect.Effect<Chunk.Chunk<A2>, E2, R2>\n  ): Stream.Stream<A2, E | E2, R | R2> => pipe(self, mapEffectSequential(f), mapConcatChunk(identity))\n)\n\n/** @internal */\nexport const mapConcatEffect = dual<\n  <A, A2, E2, R2>(\n    f: (a: A) => Effect.Effect<Iterable<A2>, E2, R2>\n  ) => <E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A2, E2 | E, R2 | R>,\n  <A, E, R, A2, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    f: (a: A) => Effect.Effect<Iterable<A2>, E2, R2>\n  ) => Stream.Stream<A2, E2 | E, R2 | R>\n>(\n  2,\n  <A, E, R, A2, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    f: (a: A) => Effect.Effect<Iterable<A2>, E2, R2>\n  ): Stream.Stream<A2, E | E2, R | R2> =>\n    pipe(self, mapEffectSequential((a) => pipe(f(a), Effect.map(Chunk.fromIterable))), mapConcatChunk(identity))\n)\n\n/** @internal */\nexport const mapEffectSequential = dual<\n  <A, A2, E2, R2>(\n    f: (a: A) => Effect.Effect<A2, E2, R2>\n  ) => <E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A2, E2 | E, R2 | R>,\n  <A, E, R, A2, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    f: (a: A) => Effect.Effect<A2, E2, R2>\n  ) => Stream.Stream<A2, E2 | E, R2 | R>\n>(\n  2,\n  <A, E, R, A2, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    f: (a: A) => Effect.Effect<A2, E2, R2>\n  ): Stream.Stream<A2, E | E2, R | R2> => {\n    const loop = (\n      iterator: Iterator<A>\n    ): Channel.Channel<Chunk.Chunk<A2>, Chunk.Chunk<A>, E | E2, E, unknown, unknown, R2> => {\n      const next = iterator.next()\n      if (next.done) {\n        return core.readWithCause({\n          onInput: (elem) => loop(elem[Symbol.iterator]()),\n          onFailure: core.failCause,\n          onDone: core.succeed\n        })\n      } else {\n        const value = next.value\n        return channel.unwrap(\n          Effect.map(f(value), (a2) =>\n            core.flatMap(\n              core.write(Chunk.of(a2)),\n              () => loop(iterator)\n            ))\n        )\n      }\n    }\n    return new StreamImpl(pipe(\n      toChannel(self),\n      core.pipeTo(core.suspend(() => loop(Chunk.empty<A>()[Symbol.iterator]())))\n    ))\n  }\n)\n\n/** @internal */\nexport const mapEffectPar = dual<\n  <A, A2, E2, R2>(\n    n: number,\n    f: (a: A) => Effect.Effect<A2, E2, R2>\n  ) => <E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A2, E2 | E, R2 | R>,\n  <A, E, R, A2, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    n: number,\n    f: (a: A) => Effect.Effect<A2, E2, R2>\n  ) => Stream.Stream<A2, E2 | E, R2 | R>\n>(\n  3,\n  <A, E, R, A2, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    n: number,\n    f: (a: A) => Effect.Effect<A2, E2, R2>\n  ): Stream.Stream<A2, E | E2, R | R2> =>\n    new StreamImpl(\n      pipe(\n        toChannel(self),\n        channel.concatMap(channel.writeChunk),\n        channel.mapOutEffectPar(f, n),\n        channel.mapOut(Chunk.of)\n      )\n    )\n)\n\n/** @internal */\nexport const mapError = dual<\n  <E, E2>(f: (error: E) => E2) => <A, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A, E2, R>,\n  <A, E, R, E2>(self: Stream.Stream<A, E, R>, f: (error: E) => E2) => Stream.Stream<A, E2, R>\n>(\n  2,\n  <A, E, R, E2>(self: Stream.Stream<A, E, R>, f: (error: E) => E2): Stream.Stream<A, E2, R> =>\n    new StreamImpl(pipe(toChannel(self), channel.mapError(f)))\n)\n\n/** @internal */\nexport const mapErrorCause = dual<\n  <E, E2>(\n    f: (cause: Cause.Cause<E>) => Cause.Cause<E2>\n  ) => <A, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A, E2, R>,\n  <A, E, R, E2>(self: Stream.Stream<A, E, R>, f: (cause: Cause.Cause<E>) => Cause.Cause<E2>) => Stream.Stream<A, E2, R>\n>(\n  2,\n  <A, E, R, E2>(self: Stream.Stream<A, E, R>, f: (cause: Cause.Cause<E>) => Cause.Cause<E2>): Stream.Stream<A, E2, R> =>\n    new StreamImpl(pipe(toChannel(self), channel.mapErrorCause(f)))\n)\n\n/** @internal */\nexport const merge = dual<\n  <A2, E2, R2>(\n    that: Stream.Stream<A2, E2, R2>,\n    options?: {\n      readonly haltStrategy?: HaltStrategy.HaltStrategyInput | undefined\n    }\n  ) => <A, E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A2 | A, E2 | E, R2 | R>,\n  <A, E, R, A2, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    that: Stream.Stream<A2, E2, R2>,\n    options?: {\n      readonly haltStrategy?: HaltStrategy.HaltStrategyInput | undefined\n    }\n  ) => Stream.Stream<A2 | A, E2 | E, R2 | R>\n>(\n  (args) => isStream(args[1]),\n  <A, E, R, A2, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    that: Stream.Stream<A2, E2, R2>,\n    options?: {\n      readonly haltStrategy?: HaltStrategy.HaltStrategyInput | undefined\n    }\n  ): Stream.Stream<A2 | A, E2 | E, R2 | R> =>\n    mergeWith(self, that, {\n      onSelf: identity,\n      onOther: identity,\n      haltStrategy: options?.haltStrategy\n    })\n)\n\n/** @internal */\nexport const mergeAll = dual<\n  (options: {\n    readonly concurrency: number | \"unbounded\"\n    readonly bufferSize?: number | undefined\n  }) => <A, E, R>(streams: Iterable<Stream.Stream<A, E, R>>) => Stream.Stream<A, E, R>,\n  <A, E, R>(streams: Iterable<Stream.Stream<A, E, R>>, options: {\n    readonly concurrency: number | \"unbounded\"\n    readonly bufferSize?: number | undefined\n  }) => Stream.Stream<A, E, R>\n>((args) => Symbol.iterator in args[0], (streams, options) => flatten(fromIterable(streams), options))\n\n/** @internal */\nexport const mergeWithTag: {\n  <S extends { [k in string]: Stream.Stream<any, any, any> }>(\n    streams: S,\n    options: {\n      readonly concurrency: number | \"unbounded\"\n      readonly bufferSize?: number | undefined\n    }\n  ): Stream.Stream<\n    { [K in keyof S]: { _tag: K; value: Stream.Stream.Success<S[K]> } }[keyof S],\n    Stream.Stream.Error<S[keyof S]>,\n    Stream.Stream.Context<S[keyof S]>\n  >\n  (options: {\n    readonly concurrency: number | \"unbounded\"\n    readonly bufferSize?: number | undefined\n  }): <S extends { [k in string]: Stream.Stream<any, any, any> }>(streams: S) => Stream.Stream<\n    { [K in keyof S]: { _tag: K; value: Stream.Stream.Success<S[K]> } }[keyof S],\n    Stream.Stream.Error<S[keyof S]>,\n    Stream.Stream.Context<S[keyof S]>\n  >\n} = dual(2, (streams, options) => {\n  const keys = Object.keys(streams)\n  const values = keys.map((key) => streams[key].pipe(map((value) => ({ _tag: key, value })))) as any\n  return mergeAll(values, options)\n})\n\n/** @internal */\nexport const mergeEither = dual<\n  <A2, E2, R2>(\n    that: Stream.Stream<A2, E2, R2>\n  ) => <A, E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<Either.Either<A2, A>, E2 | E, R2 | R>,\n  <A, E, R, A2, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    that: Stream.Stream<A2, E2, R2>\n  ) => Stream.Stream<Either.Either<A2, A>, E2 | E, R2 | R>\n>(\n  2,\n  <A, E, R, A2, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    that: Stream.Stream<A2, E2, R2>\n  ): Stream.Stream<Either.Either<A2, A>, E2 | E, R2 | R> =>\n    mergeWith(self, that, { onSelf: Either.left, onOther: Either.right })\n)\n\n/** @internal */\nexport const mergeLeft = dual<\n  <AR, ER, RR>(\n    right: Stream.Stream<AR, ER, RR>\n  ) => <AL, EL, RL>(left: Stream.Stream<AL, EL, RL>) => Stream.Stream<AL, ER | EL, RR | RL>,\n  <AL, EL, RL, AR, ER, RR>(\n    left: Stream.Stream<AL, EL, RL>,\n    right: Stream.Stream<AR, ER, RR>\n  ) => Stream.Stream<AL, ER | EL, RR | RL>\n>(\n  2,\n  <AL, EL, RL, AR, ER, RR>(\n    left: Stream.Stream<AL, EL, RL>,\n    right: Stream.Stream<AR, ER, RR>\n  ): Stream.Stream<AL, EL | ER, RL | RR> => pipe(left, merge(drain(right)))\n)\n\n/** @internal */\nexport const mergeRight = dual<\n  <AR, ER, RR>(\n    right: Stream.Stream<AR, ER, RR>\n  ) => <AL, EL, RL>(left: Stream.Stream<AL, EL, RL>) => Stream.Stream<AR, ER | EL, RR | RL>,\n  <AL, EL, RL, AR, ER, RR>(\n    left: Stream.Stream<AL, EL, RL>,\n    right: Stream.Stream<AR, ER, RR>\n  ) => Stream.Stream<AR, ER | EL, RR | RL>\n>(\n  2,\n  <AL, EL, RL, AR, ER, RR>(\n    left: Stream.Stream<AL, EL, RL>,\n    right: Stream.Stream<AR, ER, RR>\n  ): Stream.Stream<AR, EL | ER, RL | RR> => pipe(drain(left), merge(right))\n)\n\n/** @internal */\nexport const mergeWith = dual<\n  <A2, E2, R2, A, A3, A4>(\n    other: Stream.Stream<A2, E2, R2>,\n    options: {\n      readonly onSelf: (a: A) => A3\n      readonly onOther: (a2: A2) => A4\n      readonly haltStrategy?: HaltStrategy.HaltStrategyInput | undefined\n    }\n  ) => <E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A3 | A4, E2 | E, R2 | R>,\n  <A, E, R, A2, E2, R2, A3, A4>(\n    self: Stream.Stream<A, E, R>,\n    other: Stream.Stream<A2, E2, R2>,\n    options: {\n      readonly onSelf: (a: A) => A3\n      readonly onOther: (a2: A2) => A4\n      readonly haltStrategy?: HaltStrategy.HaltStrategyInput | undefined\n    }\n  ) => Stream.Stream<A3 | A4, E2 | E, R2 | R>\n>(\n  3,\n  <A, E, R, A2, E2, R2, A3, A4>(\n    self: Stream.Stream<A, E, R>,\n    other: Stream.Stream<A2, E2, R2>,\n    options: {\n      readonly onSelf: (a: A) => A3\n      readonly onOther: (a2: A2) => A4\n      readonly haltStrategy?: HaltStrategy.HaltStrategyInput | undefined\n    }\n  ): Stream.Stream<A3 | A4, E2 | E, R2 | R> => {\n    const strategy = options.haltStrategy ? haltStrategy.fromInput(options.haltStrategy) : HaltStrategy.Both\n    const handler =\n      (terminate: boolean) =>\n      (exit: Exit.Exit<unknown, E | E2>): MergeDecision.MergeDecision<R | R2, E | E2, unknown, E | E2, unknown> =>\n        terminate || !Exit.isSuccess(exit) ?\n          // TODO: remove\n          MergeDecision.Done(Effect.suspend(() => exit)) :\n          MergeDecision.Await((exit) => Effect.suspend(() => exit))\n\n    return new StreamImpl<A3 | A4, E | E2, R | R2>(\n      channel.mergeWith(toChannel(map(self, options.onSelf)), {\n        other: toChannel(map(other, options.onOther)),\n        onSelfDone: handler(strategy._tag === \"Either\" || strategy._tag === \"Left\"),\n        onOtherDone: handler(strategy._tag === \"Either\" || strategy._tag === \"Right\")\n      })\n    )\n  }\n)\n\n/** @internal */\nexport const mkString = <E, R>(self: Stream.Stream<string, E, R>): Effect.Effect<string, E, R> =>\n  run(self, sink_.mkString)\n\n/** @internal */\nexport const never: Stream.Stream<never> = fromEffect(Effect.never)\n\n/** @internal */\nexport const onEnd: {\n  <_, E2, R2>(\n    effect: Effect.Effect<_, E2, R2>\n  ): <A, E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A, E2 | E, R2 | R>\n  <A, E, R, _, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    effect: Effect.Effect<_, E2, R2>\n  ): Stream.Stream<A, E | E2, R | R2>\n} = dual(\n  2,\n  <A, E, R, _, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    effect: Effect.Effect<_, E2, R2>\n  ): Stream.Stream<A, E | E2, R | R2> => concat(self, drain(fromEffect(effect)))\n)\n\n/** @internal */\nexport const onError = dual<\n  <E, X, R2>(\n    cleanup: (cause: Cause.Cause<E>) => Effect.Effect<X, never, R2>\n  ) => <A, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A, E, R2 | R>,\n  <A, E, R, X, R2>(\n    self: Stream.Stream<A, E, R>,\n    cleanup: (cause: Cause.Cause<E>) => Effect.Effect<X, never, R2>\n  ) => Stream.Stream<A, E, R2 | R>\n>(\n  2,\n  <A, E, R, X, R2>(\n    self: Stream.Stream<A, E, R>,\n    cleanup: (cause: Cause.Cause<E>) => Effect.Effect<X, never, R2>\n  ): Stream.Stream<A, E, R | R2> =>\n    pipe(self, catchAllCause((cause) => fromEffect(pipe(cleanup(cause), Effect.zipRight(Effect.failCause(cause))))))\n)\n\n/** @internal */\nexport const onDone = dual<\n  <X, R2>(\n    cleanup: () => Effect.Effect<X, never, R2>\n  ) => <A, E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A, E, R2 | R>,\n  <A, E, R, X, R2>(\n    self: Stream.Stream<A, E, R>,\n    cleanup: () => Effect.Effect<X, never, R2>\n  ) => Stream.Stream<A, E, R2 | R>\n>(\n  2,\n  <A, E, R, X, R2>(\n    self: Stream.Stream<A, E, R>,\n    cleanup: () => Effect.Effect<X, never, R2>\n  ): Stream.Stream<A, E, R | R2> =>\n    new StreamImpl<A, E, R | R2>(\n      pipe(toChannel(self), core.ensuringWith((exit) => Exit.isSuccess(exit) ? cleanup() : Effect.void))\n    )\n)\n\n/** @internal */\nexport const onStart: {\n  <_, E2, R2>(\n    effect: Effect.Effect<_, E2, R2>\n  ): <A, E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A, E2 | E, R2 | R>\n  <A, E, R, _, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    effect: Effect.Effect<_, E2, R2>\n  ): Stream.Stream<A, E | E2, R | R2>\n} = dual(\n  2,\n  <A, E, R, _, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    effect: Effect.Effect<_, E2, R2>\n  ): Stream.Stream<A, E | E2, R | R2> => unwrap(Effect.as(effect, self))\n)\n\n/** @internal */\nexport const orDie = <A, E, R>(self: Stream.Stream<A, E, R>): Stream.Stream<A, never, R> =>\n  pipe(self, orDieWith(identity))\n\n/** @internal */\nexport const orDieWith = dual<\n  <E>(f: (e: E) => unknown) => <A, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A, never, R>,\n  <A, E, R>(self: Stream.Stream<A, E, R>, f: (e: E) => unknown) => Stream.Stream<A, never, R>\n>(\n  2,\n  <A, E, R>(self: Stream.Stream<A, E, R>, f: (e: E) => unknown): Stream.Stream<A, never, R> =>\n    new StreamImpl(pipe(toChannel(self), channel.orDieWith(f)))\n)\n\n/** @internal */\nexport const orElse = dual<\n  <A2, E2, R2>(\n    that: LazyArg<Stream.Stream<A2, E2, R2>>\n  ) => <A, E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A2 | A, E2, R2 | R>,\n  <A, E, R, A2, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    that: LazyArg<Stream.Stream<A2, E2, R2>>\n  ) => Stream.Stream<A2 | A, E2, R2 | R>\n>(\n  2,\n  <A, E, R, A2, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    that: LazyArg<Stream.Stream<A2, E2, R2>>\n  ): Stream.Stream<A2 | A, E2, R2 | R> =>\n    new StreamImpl<A | A2, E2, R | R2>(pipe(toChannel(self), channel.orElse(() => toChannel(that()))))\n)\n\n/** @internal */\nexport const orElseEither = dual<\n  <A2, E2, R2>(\n    that: LazyArg<Stream.Stream<A2, E2, R2>>\n  ) => <A, E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<Either.Either<A2, A>, E2, R2 | R>,\n  <A, E, R, A2, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    that: LazyArg<Stream.Stream<A2, E2, R2>>\n  ) => Stream.Stream<Either.Either<A2, A>, E2, R2 | R>\n>(\n  2,\n  <A, E, R, A2, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    that: LazyArg<Stream.Stream<A2, E2, R2>>\n  ): Stream.Stream<Either.Either<A2, A>, E2, R2 | R> =>\n    pipe(self, map(Either.left), orElse(() => pipe(that(), map(Either.right))))\n)\n\n/** @internal */\nexport const orElseFail = dual<\n  <E2>(error: LazyArg<E2>) => <A, E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A, E2, R>,\n  <A, E, R, E2>(self: Stream.Stream<A, E, R>, error: LazyArg<E2>) => Stream.Stream<A, E2, R>\n>(\n  2,\n  <A, E, R, E2>(self: Stream.Stream<A, E, R>, error: LazyArg<E2>): Stream.Stream<A, E2, R> =>\n    pipe(self, orElse(() => failSync(error)))\n)\n\n/** @internal */\nexport const orElseIfEmpty = dual<\n  <A2>(element: LazyArg<A2>) => <A, E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A2 | A, E, R>,\n  <A, E, R, A2>(self: Stream.Stream<A, E, R>, element: LazyArg<A2>) => Stream.Stream<A2 | A, E, R>\n>(\n  2,\n  <A, E, R, A2>(self: Stream.Stream<A, E, R>, element: LazyArg<A2>): Stream.Stream<A | A2, E, R> =>\n    pipe(self, orElseIfEmptyChunk(() => Chunk.of(element())))\n)\n\n/** @internal */\nexport const orElseIfEmptyChunk = dual<\n  <A2>(chunk: LazyArg<Chunk.Chunk<A2>>) => <A, E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A2 | A, E, R>,\n  <A, E, R, A2>(self: Stream.Stream<A, E, R>, chunk: LazyArg<Chunk.Chunk<A2>>) => Stream.Stream<A2 | A, E, R>\n>(\n  2,\n  <A, E, R, A2>(self: Stream.Stream<A, E, R>, chunk: LazyArg<Chunk.Chunk<A2>>): Stream.Stream<A | A2, E, R> =>\n    pipe(self, orElseIfEmptyStream(() => new StreamImpl(core.write(chunk()))))\n)\n\n/** @internal */\nexport const orElseIfEmptyStream = dual<\n  <A2, E2, R2>(\n    stream: LazyArg<Stream.Stream<A2, E2, R2>>\n  ) => <A, E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A2 | A, E2 | E, R2 | R>,\n  <A, E, R, A2, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    stream: LazyArg<Stream.Stream<A2, E2, R2>>\n  ) => Stream.Stream<A2 | A, E2 | E, R2 | R>\n>(\n  2,\n  <A, E, R, A2, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    stream: LazyArg<Stream.Stream<A2, E2, R2>>\n  ): Stream.Stream<A2 | A, E2 | E, R2 | R> => {\n    const writer: Channel.Channel<Chunk.Chunk<A | A2>, Chunk.Chunk<A>, E | E2, E, unknown, unknown, R2> = core.readWith(\n      {\n        onInput: (input: Chunk.Chunk<A>) => {\n          if (Chunk.isEmpty(input)) {\n            return core.suspend(() => writer)\n          }\n          return pipe(\n            core.write(input),\n            channel.zipRight(channel.identityChannel<Chunk.Chunk<A>, E, unknown>())\n          )\n        },\n        onFailure: core.fail,\n        onDone: () => core.suspend(() => toChannel(stream()))\n      }\n    )\n    return new StreamImpl(pipe(toChannel(self), core.pipeTo(writer)))\n  }\n)\n\n/** @internal */\nexport const orElseSucceed = dual<\n  <A2>(value: LazyArg<A2>) => <A, E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A2 | A, never, R>,\n  <A, E, R, A2>(self: Stream.Stream<A, E, R>, value: LazyArg<A2>) => Stream.Stream<A2 | A, never, R>\n>(\n  2,\n  <A, E, R, A2>(self: Stream.Stream<A, E, R>, value: LazyArg<A2>): Stream.Stream<A2 | A, never, R> =>\n    pipe(self, orElse(() => sync(value)))\n)\n\n/** @internal */\nexport const paginate = <S, A>(s: S, f: (s: S) => readonly [A, Option.Option<S>]): Stream.Stream<A> =>\n  paginateChunk(s, (s) => {\n    const page = f(s)\n    return [Chunk.of(page[0]), page[1]] as const\n  })\n\n/** @internal */\nexport const paginateChunk = <S, A>(\n  s: S,\n  f: (s: S) => readonly [Chunk.Chunk<A>, Option.Option<S>]\n): Stream.Stream<A> => {\n  const loop = (s: S): Channel.Channel<Chunk.Chunk<A>, unknown, never, unknown, unknown, unknown> => {\n    const page = f(s)\n    return Option.match(page[1], {\n      onNone: () => channel.zipRight(core.write(page[0]), core.void),\n      onSome: (s) => core.flatMap(core.write(page[0]), () => loop(s))\n    })\n  }\n  return new StreamImpl(core.suspend(() => loop(s)))\n}\n\n/** @internal */\nexport const paginateChunkEffect = <S, A, E, R>(\n  s: S,\n  f: (s: S) => Effect.Effect<readonly [Chunk.Chunk<A>, Option.Option<S>], E, R>\n): Stream.Stream<A, E, R> => {\n  const loop = (s: S): Channel.Channel<Chunk.Chunk<A>, unknown, E, unknown, unknown, unknown, R> =>\n    channel.unwrap(\n      Effect.map(f(s), ([chunk, option]) =>\n        Option.match(option, {\n          onNone: () => channel.zipRight(core.write(chunk), core.void),\n          onSome: (s) => core.flatMap(core.write(chunk), () => loop(s))\n        }))\n    )\n  return new StreamImpl(core.suspend(() => loop(s)))\n}\n\n/** @internal */\nexport const paginateEffect = <S, A, E, R>(\n  s: S,\n  f: (s: S) => Effect.Effect<readonly [A, Option.Option<S>], E, R>\n): Stream.Stream<A, E, R> =>\n  paginateChunkEffect(s, (s) => pipe(f(s), Effect.map(([a, s]) => [Chunk.of(a), s] as const)))\n\n/** @internal */\nexport const peel = dual<\n  <A2, A, E2, R2>(\n    sink: Sink.Sink<A2, A, A, E2, R2>\n  ) => <E, R>(\n    self: Stream.Stream<A, E, R>\n  ) => Effect.Effect<[A2, Stream.Stream<A, E>], E2 | E, Scope.Scope | R2 | R>,\n  <A, E, R, A2, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    sink: Sink.Sink<A2, A, A, E2, R2>\n  ) => Effect.Effect<[A2, Stream.Stream<A, E>], E2 | E, Scope.Scope | R2 | R>\n>(2, <A, E, R, A2, E2, R2>(\n  self: Stream.Stream<A, E, R>,\n  sink: Sink.Sink<A2, A, A, E2, R2>\n): Effect.Effect<[A2, Stream.Stream<A, E>], E2 | E, Scope.Scope | R2 | R> => {\n  type Signal = Emit | Halt | End\n  const OP_EMIT = \"Emit\" as const\n  type OP_EMIT = typeof OP_EMIT\n  const OP_HALT = \"Halt\" as const\n  type OP_HALT = typeof OP_HALT\n  const OP_END = \"End\" as const\n  type OP_END = typeof OP_END\n  interface Emit {\n    readonly _tag: OP_EMIT\n    readonly elements: Chunk.Chunk<A>\n  }\n  interface Halt {\n    readonly _tag: OP_HALT\n    readonly cause: Cause.Cause<E>\n  }\n  interface End {\n    readonly _tag: OP_END\n  }\n  return pipe(\n    Deferred.make<A2, E | E2>(),\n    Effect.flatMap((deferred) =>\n      pipe(\n        Handoff.make<Signal>(),\n        Effect.map((handoff) => {\n          const consumer = sink_.foldSink(sink_.collectLeftover(sink), {\n            onFailure: (error) =>\n              sink_.zipRight(\n                sink_.fromEffect(Deferred.fail(deferred, error)),\n                sink_.fail(error)\n              ),\n            onSuccess: ([z, leftovers]) => {\n              const loop: Channel.Channel<Chunk.Chunk<A>, Chunk.Chunk<A>, E | E2, E, void, unknown> = core\n                .readWithCause({\n                  onInput: (elements) =>\n                    core.flatMap(\n                      core.fromEffect(\n                        Handoff.offer<Signal>(handoff, { _tag: OP_EMIT, elements })\n                      ),\n                      () => loop\n                    ),\n                  onFailure: (cause) =>\n                    channel.zipRight(\n                      core.fromEffect(Handoff.offer<Signal>(handoff, { _tag: OP_HALT, cause })),\n                      core.failCause(cause)\n                    ),\n                  onDone: (_) =>\n                    channel.zipRight(\n                      core.fromEffect(Handoff.offer<Signal>(handoff, { _tag: OP_END })),\n                      core.void\n                    )\n                })\n              return sink_.fromChannel(\n                pipe(\n                  core.fromEffect(Deferred.succeed(deferred, z)),\n                  channel.zipRight(core.fromEffect(\n                    pipe(\n                      handoff,\n                      Handoff.offer<Signal>({ _tag: OP_EMIT, elements: leftovers })\n                    )\n                  )),\n                  channel.zipRight(loop)\n                )\n              )\n            }\n          })\n\n          const producer: Channel.Channel<Chunk.Chunk<A>, unknown, E, unknown, void, unknown> = pipe(\n            Handoff.take(handoff),\n            Effect.map((signal) => {\n              switch (signal._tag) {\n                case OP_EMIT: {\n                  return pipe(core.write(signal.elements), core.flatMap(() => producer))\n                }\n                case OP_HALT: {\n                  return core.failCause(signal.cause)\n                }\n                case OP_END: {\n                  return core.void\n                }\n              }\n            }),\n            channel.unwrap\n          )\n\n          return pipe(\n            self,\n            tapErrorCause((cause) => Deferred.failCause(deferred, cause)),\n            run(consumer),\n            Effect.forkScoped,\n            Effect.zipRight(Deferred.await(deferred)),\n            Effect.map((z) => [z, new StreamImpl(producer)] as [A2, StreamImpl<A, E>])\n          )\n        })\n      )\n    ),\n    Effect.flatten\n  )\n})\n\n/** @internal */\nexport const partition: {\n  <C extends A, B extends A, A = C>(\n    refinement: Refinement<Types.NoInfer<A>, B>,\n    options?: {\n      bufferSize?: number | undefined\n    }\n  ): <E, R>(\n    self: Stream.Stream<C, E, R>\n  ) => Effect.Effect<\n    [excluded: Stream.Stream<Exclude<C, B>, E>, satisfying: Stream.Stream<B, E>],\n    E,\n    Scope.Scope | R\n  >\n  <A>(\n    predicate: Predicate<A>,\n    options?: {\n      bufferSize?: number | undefined\n    }\n  ): <E, R>(\n    self: Stream.Stream<A, E, R>\n  ) => Effect.Effect<[excluded: Stream.Stream<A, E>, satisfying: Stream.Stream<A, E>], E, Scope.Scope | R>\n  <C extends A, E, R, B extends A, A = C>(\n    self: Stream.Stream<C, E, R>,\n    refinement: Refinement<A, B>,\n    options?: {\n      bufferSize?: number | undefined\n    }\n  ): Effect.Effect<\n    [excluded: Stream.Stream<Exclude<C, B>, E>, satisfying: Stream.Stream<B, E>],\n    E,\n    Scope.Scope | R\n  >\n  <A, E, R>(\n    self: Stream.Stream<A, E, R>,\n    predicate: Predicate<A>,\n    options?: {\n      bufferSize?: number | undefined\n    }\n  ): Effect.Effect<[excluded: Stream.Stream<A, E>, satisfying: Stream.Stream<A, E>], E, Scope.Scope | R>\n} = dual(\n  (args) => typeof args[1] === \"function\",\n  <A, E, R>(\n    self: Stream.Stream<A, E, R>,\n    predicate: Predicate<A>,\n    options?: {\n      readonly bufferSize?: number | undefined\n    }\n  ): Effect.Effect<\n    [Stream.Stream<A, E>, Stream.Stream<A, E>],\n    E,\n    R | Scope.Scope\n  > =>\n    partitionEither(\n      self,\n      (a) => Effect.succeed(predicate(a) ? Either.right(a) : Either.left(a)),\n      options\n    )\n)\n\n/** @internal */\nexport const partitionEither = dual<\n  <A, A3, A2, E2, R2>(\n    predicate: (a: Types.NoInfer<A>) => Effect.Effect<Either.Either<A3, A2>, E2, R2>,\n    options?: {\n      readonly bufferSize?: number | undefined\n    }\n  ) => <E, R>(\n    self: Stream.Stream<A, E, R>\n  ) => Effect.Effect<\n    [left: Stream.Stream<A2, E2 | E>, right: Stream.Stream<A3, E2 | E>],\n    E2 | E,\n    Scope.Scope | R2 | R\n  >,\n  <A, E, R, A3, A2, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    predicate: (a: A) => Effect.Effect<Either.Either<A3, A2>, E2, R2>,\n    options?: {\n      readonly bufferSize?: number | undefined\n    }\n  ) => Effect.Effect<\n    [left: Stream.Stream<A2, E2 | E>, right: Stream.Stream<A3, E2 | E>],\n    E2 | E,\n    Scope.Scope | R2 | R\n  >\n>(\n  (args) => typeof args[1] === \"function\",\n  <A, E, R, A3, A2, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    predicate: (a: A) => Effect.Effect<Either.Either<A3, A2>, E2, R2>,\n    options?: {\n      readonly bufferSize?: number | undefined\n    }\n  ): Effect.Effect<\n    [left: Stream.Stream<A2, E2 | E>, right: Stream.Stream<A3, E2 | E>],\n    E | E2,\n    R | R2 | Scope.Scope\n  > =>\n    pipe(\n      mapEffectSequential(self, predicate),\n      distributedWith({\n        size: 2,\n        maximumLag: options?.bufferSize ?? 16,\n        decide: Either.match({\n          onLeft: () => Effect.succeed((n) => n === 0),\n          onRight: () => Effect.succeed((n) => n === 1)\n        })\n      }),\n      Effect.flatMap(([queue1, queue2]) =>\n        Effect.succeed([\n          filterMap(\n            flattenExitOption(fromQueue(queue1, { shutdown: true })),\n            (_) =>\n              Either.match(_, {\n                onLeft: Option.some,\n                onRight: Option.none\n              })\n          ),\n          filterMap(\n            flattenExitOption(fromQueue(queue2, { shutdown: true })),\n            (_) =>\n              Either.match(_, {\n                onLeft: Option.none,\n                onRight: Option.some\n              })\n          )\n        ])\n      )\n    )\n)\n\n/** @internal */\nexport const pipeThrough = dual<\n  <A2, A, L, E2, R2>(\n    sink: Sink.Sink<A2, A, L, E2, R2>\n  ) => <E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<L, E2 | E, R2 | R>,\n  <A, E, R, A2, L, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    sink: Sink.Sink<A2, A, L, E2, R2>\n  ) => Stream.Stream<L, E2 | E, R2 | R>\n>(\n  2,\n  <A, E, R, A2, L, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    sink: Sink.Sink<A2, A, L, E2, R2>\n  ): Stream.Stream<L, E2 | E, R2 | R> =>\n    new StreamImpl(pipe(toChannel(self), channel.pipeToOrFail(sink_.toChannel(sink))))\n)\n\n/** @internal */\nexport const pipeThroughChannel = dual<\n  <R2, E, E2, A, A2>(\n    channel: Channel.Channel<Chunk.Chunk<A2>, Chunk.Chunk<A>, E2, E, unknown, unknown, R2>\n  ) => <R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A2, E2, R2 | R>,\n  <R, R2, E, E2, A, A2>(\n    self: Stream.Stream<A, E, R>,\n    channel: Channel.Channel<Chunk.Chunk<A2>, Chunk.Chunk<A>, E2, E, unknown, unknown, R2>\n  ) => Stream.Stream<A2, E2, R2 | R>\n>(\n  2,\n  <R, R2, E, E2, A, A2>(\n    self: Stream.Stream<A, E, R>,\n    channel: Channel.Channel<Chunk.Chunk<A2>, Chunk.Chunk<A>, E2, E, unknown, unknown, R2>\n  ): Stream.Stream<A2, E2, R2 | R> => new StreamImpl(core.pipeTo(toChannel(self), channel))\n)\n\n/** @internal */\nexport const pipeThroughChannelOrFail = dual<\n  <R2, E, E2, A, A2>(\n    chan: Channel.Channel<Chunk.Chunk<A2>, Chunk.Chunk<A>, E2, E, unknown, unknown, R2>\n  ) => <R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A2, E | E2, R2 | R>,\n  <R, R2, E, E2, A, A2>(\n    self: Stream.Stream<A, E, R>,\n    chan: Channel.Channel<Chunk.Chunk<A2>, Chunk.Chunk<A>, E2, E, unknown, unknown, R2>\n  ) => Stream.Stream<A2, E | E2, R2 | R>\n>(\n  2,\n  <R, R2, E, E2, A, A2>(\n    self: Stream.Stream<A, E, R>,\n    chan: Channel.Channel<Chunk.Chunk<A2>, Chunk.Chunk<A>, E2, E, unknown, unknown, R2>\n  ): Stream.Stream<A2, E | E2, R2 | R> => new StreamImpl(pipe(toChannel(self), channel.pipeToOrFail(chan)))\n)\n\n/** @internal */\nexport const prepend = dual<\n  <B>(values: Chunk.Chunk<B>) => <A, E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A | B, E, R>,\n  <A, E, R, B>(self: Stream.Stream<A, E, R>, values: Chunk.Chunk<B>) => Stream.Stream<A | B, E, R>\n>(2, (self, values) =>\n  new StreamImpl(\n    channel.zipRight(\n      core.write(values as Chunk.Chunk<any>),\n      toChannel(self)\n    )\n  ))\n\n/** @internal */\nexport const provideContext = dual<\n  <R>(context: Context.Context<R>) => <A, E>(self: Stream.Stream<A, E, R>) => Stream.Stream<A, E>,\n  <A, E, R>(self: Stream.Stream<A, E, R>, context: Context.Context<R>) => Stream.Stream<A, E>\n>(\n  2,\n  <A, E, R>(self: Stream.Stream<A, E, R>, context: Context.Context<R>): Stream.Stream<A, E> =>\n    new StreamImpl(pipe(toChannel(self), core.provideContext(context)))\n)\n\n/** @internal */\nexport const provideSomeContext = dual<\n  <R2>(context: Context.Context<R2>) => <A, E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A, E, Exclude<R, R2>>,\n  <A, E, R, R2>(self: Stream.Stream<A, E, R>, context: Context.Context<R2>) => Stream.Stream<A, E, Exclude<R, R2>>\n>(\n  2,\n  <A, E, R, R2>(self: Stream.Stream<A, E, R>, context: Context.Context<R2>): Stream.Stream<A, E, Exclude<R, R2>> =>\n    mapInputContext(self as any, Context.merge(context))\n)\n\n/** @internal */\nexport const provideLayer = dual<\n  <RIn, E2, ROut>(\n    layer: Layer.Layer<ROut, E2, RIn>\n  ) => <A, E>(self: Stream.Stream<A, E, ROut>) => Stream.Stream<A, E2 | E, RIn>,\n  <A, E, RIn, E2, ROut>(\n    self: Stream.Stream<A, E, ROut>,\n    layer: Layer.Layer<ROut, E2, RIn>\n  ) => Stream.Stream<A, E2 | E, RIn>\n>(\n  2,\n  <A, E, RIn, E2, ROut>(\n    self: Stream.Stream<A, E, ROut>,\n    layer: Layer.Layer<ROut, E2, RIn>\n  ): Stream.Stream<A, E2 | E, RIn> =>\n    new StreamImpl(\n      channel.unwrapScopedWith((scope) =>\n        Layer.buildWithScope(layer, scope).pipe(\n          Effect.map((env) => pipe(toChannel(self), core.provideContext(env)))\n        )\n      )\n    )\n)\n\n/** @internal */\nexport const provideService = dual<\n  <I, S>(\n    tag: Context.Tag<I, S>,\n    resource: Types.NoInfer<S>\n  ) => <A, E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A, E, Exclude<R, I>>,\n  <A, E, R, I, S>(\n    self: Stream.Stream<A, E, R>,\n    tag: Context.Tag<I, S>,\n    resource: Types.NoInfer<S>\n  ) => Stream.Stream<A, E, Exclude<R, I>>\n>(\n  3,\n  <A, E, R, I, S>(\n    self: Stream.Stream<A, E, R>,\n    tag: Context.Tag<I, S>,\n    resource: Types.NoInfer<S>\n  ) => provideServiceEffect(self, tag, Effect.succeed(resource))\n)\n\n/** @internal */\nexport const provideServiceEffect = dual<\n  <I, S, E2, R2>(\n    tag: Context.Tag<I, S>,\n    effect: Effect.Effect<Types.NoInfer<S>, E2, R2>\n  ) => <A, E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A, E2 | E, R2 | Exclude<R, I>>,\n  <A, E, R, I, S, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    tag: Context.Tag<I, S>,\n    effect: Effect.Effect<Types.NoInfer<S>, E2, R2>\n  ) => Stream.Stream<A, E2 | E, R2 | Exclude<R, I>>\n>(\n  3,\n  <A, E, R, I, S, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    tag: Context.Tag<I, S>,\n    effect: Effect.Effect<Types.NoInfer<S>, E2, R2>\n  ) => provideServiceStream(self, tag, fromEffect(effect))\n)\n\n/** @internal */\nexport const provideServiceStream = dual<\n  <I, S, E2, R2>(\n    tag: Context.Tag<I, S>,\n    stream: Stream.Stream<Types.NoInfer<S>, E2, R2>\n  ) => <A, E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A, E2 | E, R2 | Exclude<R, I>>,\n  <A, E, R, I, S, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    tag: Context.Tag<I, S>,\n    stream: Stream.Stream<Types.NoInfer<S>, E2, R2>\n  ) => Stream.Stream<A, E2 | E, R2 | Exclude<R, I>>\n>(\n  3,\n  <A, E, R, I, S, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    tag: Context.Tag<I, S>,\n    stream: Stream.Stream<Types.NoInfer<S>, E2, R2>\n  ): Stream.Stream<A, E2 | E, R2 | Exclude<R, I>> =>\n    contextWithStream((env: Context.Context<R2 | Exclude<R, I>>) =>\n      flatMap(\n        stream,\n        (service) => pipe(self, provideContext(Context.add(env, tag, service) as Context.Context<R | R2>))\n      )\n    )\n)\n\n/** @internal */\nexport const mapInputContext = dual<\n  <R0, R>(\n    f: (env: Context.Context<R0>) => Context.Context<R>\n  ) => <A, E>(self: Stream.Stream<A, E, R>) => Stream.Stream<A, E, R0>,\n  <A, E, R0, R>(\n    self: Stream.Stream<A, E, R>,\n    f: (env: Context.Context<R0>) => Context.Context<R>\n  ) => Stream.Stream<A, E, R0>\n>(\n  2,\n  <A, E, R0, R>(\n    self: Stream.Stream<A, E, R>,\n    f: (env: Context.Context<R0>) => Context.Context<R>\n  ): Stream.Stream<A, E, R0> => contextWithStream((env) => pipe(self, provideContext(f(env))))\n)\n\n/** @internal */\nexport const provideSomeLayer = dual<\n  <RIn, E2, ROut>(\n    layer: Layer.Layer<ROut, E2, RIn>\n  ) => <A, E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A, E2 | E, RIn | Exclude<R, ROut>>,\n  <A, E, R, RIn, E2, ROut>(\n    self: Stream.Stream<A, E, R>,\n    layer: Layer.Layer<ROut, E2, RIn>\n  ) => Stream.Stream<A, E2 | E, RIn | Exclude<R, ROut>>\n>(\n  2,\n  <A, E, R, RIn, E2, ROut>(\n    self: Stream.Stream<A, E, R>,\n    layer: Layer.Layer<ROut, E2, RIn>\n  ): Stream.Stream<A, E2 | E, RIn | Exclude<R, ROut>> =>\n    // @ts-expect-error\n    // @effect-diagnostics-next-line missingEffectContext:off\n    pipe(\n      self,\n      provideLayer(pipe(Layer.context(), Layer.merge(layer)))\n    )\n)\n\n/** @internal */\nexport const range = (min: number, max: number, chunkSize = DefaultChunkSize): Stream.Stream<number> =>\n  suspend(() => {\n    if (min > max) {\n      return empty as Stream.Stream<number>\n    }\n    const go = (\n      min: number,\n      max: number,\n      chunkSize: number\n    ): Channel.Channel<Chunk.Chunk<number>, unknown, never, unknown, unknown, unknown> => {\n      const remaining = max - min + 1\n      if (remaining > chunkSize) {\n        return pipe(\n          core.write(Chunk.range(min, min + chunkSize - 1)),\n          core.flatMap(() => go(min + chunkSize, max, chunkSize))\n        )\n      }\n      return core.write(Chunk.range(min, min + remaining - 1))\n    }\n    return new StreamImpl(go(min, max, chunkSize))\n  })\n\n/** @internal */\nexport const race: {\n  <AR, ER, RR>(\n    right: Stream.Stream<AR, ER, RR>\n  ): <AL, EL, RL>(left: Stream.Stream<AL, EL, RL>) => Stream.Stream<AL | AR, EL | ER, RL | RR>\n  <AL, EL, RL, AR, ER, RR>(\n    left: Stream.Stream<AL, EL, RL>,\n    right: Stream.Stream<AR, ER, RR>\n  ): Stream.Stream<AL | AR, EL | ER, RL | RR>\n} = dual(\n  2,\n  <AL, EL, RL, AR, ER, RR>(\n    left: Stream.Stream<AL, EL, RL>,\n    right: Stream.Stream<AR, ER, RR>\n  ): Stream.Stream<AL | AR, EL | ER, RL | RR> => raceAll(left, right)\n)\n\n/** @internal */\nexport const raceAll = <S extends ReadonlyArray<Stream.Stream<any, any, any>>>(\n  ...streams: S\n): Stream.Stream<\n  Stream.Stream.Success<S[number]>,\n  Stream.Stream.Error<S[number]>,\n  Stream.Stream.Context<S[number]>\n> =>\n  Deferred.make<void>().pipe(\n    Effect.map((halt) => {\n      let winner: number | null = null\n      return mergeAll(\n        streams.map((stream, index) =>\n          stream.pipe(\n            takeWhile(() => {\n              if (winner === null) {\n                winner = index\n                Deferred.unsafeDone(halt, Exit.void)\n                return true\n              }\n              return winner === index\n            }),\n            interruptWhen(\n              Deferred.await(halt).pipe(\n                Effect.flatMap(() => winner === index ? Effect.never : Effect.void)\n              )\n            )\n          )\n        ),\n        { concurrency: streams.length }\n      )\n    }),\n    unwrap\n  )\n\n/** @internal */\nexport const rechunk = dual<\n  (n: number) => <A, E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A, E, R>,\n  <A, E, R>(self: Stream.Stream<A, E, R>, n: number) => Stream.Stream<A, E, R>\n>(2, <A, E, R>(self: Stream.Stream<A, E, R>, n: number): Stream.Stream<A, E, R> =>\n  suspend(() => {\n    const target = Math.max(n, 1)\n    const process = rechunkProcess(new StreamRechunker(target), target)\n    return new StreamImpl(pipe(toChannel(self), core.pipeTo(process)))\n  }))\n\n/** @internal */\nconst rechunkProcess = <A, E>(\n  rechunker: StreamRechunker<A, E>,\n  target: number\n): Channel.Channel<Chunk.Chunk<A>, Chunk.Chunk<A>, E, E, unknown, unknown> =>\n  core.readWithCause({\n    onInput: (chunk: Chunk.Chunk<A>) => {\n      if (chunk.length === target && rechunker.isEmpty()) {\n        return core.flatMap(\n          core.write(chunk),\n          () => rechunkProcess(rechunker, target)\n        )\n      }\n      if (chunk.length > 0) {\n        const chunks: Array<Chunk.Chunk<A>> = []\n        let result: Chunk.Chunk<A> | undefined = undefined\n        let index = 0\n        while (index < chunk.length) {\n          while (index < chunk.length && result === undefined) {\n            result = rechunker.write(pipe(chunk, Chunk.unsafeGet(index)))\n            index = index + 1\n          }\n          if (result !== undefined) {\n            chunks.push(result)\n            result = undefined\n          }\n        }\n        return core.flatMap(\n          channel.writeAll(...chunks),\n          () => rechunkProcess(rechunker, target)\n        )\n      }\n      return core.suspend(() => rechunkProcess(rechunker, target))\n    },\n    onFailure: (cause) => channel.zipRight(rechunker.emitIfNotEmpty(), core.failCause(cause)),\n    onDone: () => rechunker.emitIfNotEmpty()\n  })\n\nclass StreamRechunker<out A, in out E> {\n  private builder: Array<A> = []\n  private pos = 0\n\n  constructor(readonly n: number) {\n  }\n\n  isEmpty(): boolean {\n    return this.pos === 0\n  }\n\n  write(elem: A): Chunk.Chunk<A> | undefined {\n    this.builder.push(elem)\n    this.pos += 1\n\n    if (this.pos === this.n) {\n      const result = Chunk.unsafeFromArray(this.builder)\n      this.builder = []\n      this.pos = 0\n      return result\n    }\n\n    return undefined\n  }\n\n  emitIfNotEmpty(): Channel.Channel<Chunk.Chunk<A>, unknown, E, E, void, unknown> {\n    if (this.pos !== 0) {\n      return core.write(Chunk.unsafeFromArray(this.builder))\n    }\n    return core.void\n  }\n}\n\n/** @internal */\nexport const refineOrDie = dual<\n  <E, E2>(pf: (error: E) => Option.Option<E2>) => <A, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A, E2, R>,\n  <A, E, R, E2>(self: Stream.Stream<A, E, R>, pf: (error: E) => Option.Option<E2>) => Stream.Stream<A, E2, R>\n>(\n  2,\n  <A, E, R, E2>(self: Stream.Stream<A, E, R>, pf: (error: E) => Option.Option<E2>): Stream.Stream<A, E2, R> =>\n    pipe(self, refineOrDieWith(pf, identity))\n)\n\n/** @internal */\nexport const refineOrDieWith = dual<\n  <E, E2>(\n    pf: (error: E) => Option.Option<E2>,\n    f: (error: E) => unknown\n  ) => <A, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A, E2, R>,\n  <A, E, R, E2>(\n    self: Stream.Stream<A, E, R>,\n    pf: (error: E) => Option.Option<E2>,\n    f: (error: E) => unknown\n  ) => Stream.Stream<A, E2, R>\n>(\n  3,\n  <A, E, R, E2>(\n    self: Stream.Stream<A, E, R>,\n    pf: (error: E) => Option.Option<E2>,\n    f: (error: E) => unknown\n  ): Stream.Stream<A, E2, R> =>\n    new StreamImpl(\n      channel.catchAll(toChannel(self), (error) =>\n        Option.match(pf(error), {\n          onNone: () => core.failCause(Cause.die(f(error))),\n          onSome: core.fail\n        }))\n    )\n)\n\n/** @internal */\nexport const repeat = dual<\n  <B, R2>(\n    schedule: Schedule.Schedule<B, unknown, R2>\n  ) => <A, E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A, E, R2 | R>,\n  <A, E, R, B, R2>(\n    self: Stream.Stream<A, E, R>,\n    schedule: Schedule.Schedule<B, unknown, R2>\n  ) => Stream.Stream<A, E, R2 | R>\n>(\n  2,\n  <A, E, R, B, R2>(\n    self: Stream.Stream<A, E, R>,\n    schedule: Schedule.Schedule<B, unknown, R2>\n  ): Stream.Stream<A, E, R | R2> =>\n    filterMap(\n      repeatEither(self, schedule),\n      (_) =>\n        Either.match(_, {\n          onLeft: Option.none,\n          onRight: Option.some\n        })\n    )\n)\n\n/** @internal */\nexport const repeatEffect = <A, E, R>(effect: Effect.Effect<A, E, R>): Stream.Stream<A, E, R> =>\n  repeatEffectOption(pipe(effect, Effect.mapError(Option.some)))\n\n/** @internal */\nexport const repeatEffectChunk = <A, E, R>(effect: Effect.Effect<Chunk.Chunk<A>, E, R>): Stream.Stream<A, E, R> =>\n  repeatEffectChunkOption(pipe(effect, Effect.mapError(Option.some)))\n\n/** @internal */\nexport const repeatEffectChunkOption = <A, E, R>(\n  effect: Effect.Effect<Chunk.Chunk<A>, Option.Option<E>, R>\n): Stream.Stream<A, E, R> =>\n  unfoldChunkEffect(effect, (effect) =>\n    pipe(\n      Effect.map(effect, (chunk) => Option.some([chunk, effect] as const)),\n      Effect.catchAll(Option.match({\n        onNone: () => Effect.succeed(Option.none()),\n        onSome: Effect.fail\n      }))\n    ))\n\n/** @internal */\nexport const repeatEffectOption = <A, E, R>(effect: Effect.Effect<A, Option.Option<E>, R>): Stream.Stream<A, E, R> =>\n  repeatEffectChunkOption(pipe(effect, Effect.map(Chunk.of)))\n\n/** @internal */\nexport const repeatEither = dual<\n  <B, R2>(\n    schedule: Schedule.Schedule<B, unknown, R2>\n  ) => <A, E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<Either.Either<A, B>, E, R2 | R>,\n  <A, E, R, B, R2>(\n    self: Stream.Stream<A, E, R>,\n    schedule: Schedule.Schedule<B, unknown, R2>\n  ) => Stream.Stream<Either.Either<A, B>, E, R2 | R>\n>(\n  2,\n  <A, E, R, B, R2>(\n    self: Stream.Stream<A, E, R>,\n    schedule: Schedule.Schedule<B, unknown, R2>\n  ): Stream.Stream<Either.Either<A, B>, E, R2 | R> =>\n    repeatWith(self, schedule, {\n      onElement: (a): Either.Either<A, B> => Either.right(a),\n      onSchedule: Either.left\n    })\n)\n\n/** @internal */\nexport const repeatElements = dual<\n  <B, R2>(\n    schedule: Schedule.Schedule<B, unknown, R2>\n  ) => <A, E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A, E, R2 | R>,\n  <A, E, R, B, R2>(\n    self: Stream.Stream<A, E, R>,\n    schedule: Schedule.Schedule<B, unknown, R2>\n  ) => Stream.Stream<A, E, R2 | R>\n>(\n  2,\n  <A, E, R, B, R2>(\n    self: Stream.Stream<A, E, R>,\n    schedule: Schedule.Schedule<B, unknown, R2>\n  ): Stream.Stream<A, E, R | R2> =>\n    filterMap(\n      repeatElementsWith(self, schedule, { onElement: (a) => Option.some(a), onSchedule: Option.none }),\n      identity\n    )\n)\n\n/** @internal */\nexport const repeatElementsWith = dual<\n  <B, R2, A, C>(\n    schedule: Schedule.Schedule<B, unknown, R2>,\n    options: {\n      readonly onElement: (a: A) => C\n      readonly onSchedule: (b: B) => C\n    }\n  ) => <E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<C, E, R2 | R>,\n  <A, E, R, B, R2, C>(\n    self: Stream.Stream<A, E, R>,\n    schedule: Schedule.Schedule<B, unknown, R2>,\n    options: {\n      readonly onElement: (a: A) => C\n      readonly onSchedule: (b: B) => C\n    }\n  ) => Stream.Stream<C, E, R2 | R>\n>(\n  3,\n  <A, E, R, B, R2, C>(\n    self: Stream.Stream<A, E, R>,\n    schedule: Schedule.Schedule<B, unknown, R2>,\n    options: {\n      readonly onElement: (a: A) => C\n      readonly onSchedule: (b: B) => C\n    }\n  ): Stream.Stream<C, E, R | R2> => {\n    const driver = pipe(\n      Schedule.driver(schedule),\n      Effect.map((driver) => {\n        const feed = (\n          input: Chunk.Chunk<A>\n        ): Channel.Channel<Chunk.Chunk<C>, Chunk.Chunk<A>, E, E, void, unknown, R2> =>\n          Option.match(Chunk.head(input), {\n            onNone: () => loop,\n            onSome: (a) =>\n              channel.zipRight(\n                core.write(Chunk.of(options.onElement(a))),\n                step(pipe(input, Chunk.drop(1)), a)\n              )\n          })\n        const step = (\n          input: Chunk.Chunk<A>,\n          a: A\n        ): Channel.Channel<Chunk.Chunk<C>, Chunk.Chunk<A>, E, E, void, unknown, R2> => {\n          const advance = pipe(\n            driver.next(a),\n            Effect.as(pipe(core.write(Chunk.of(options.onElement(a))), core.flatMap(() => step(input, a))))\n          )\n          const reset: Effect.Effect<\n            Channel.Channel<Chunk.Chunk<C>, Chunk.Chunk<A>, E, E, void, unknown, R2>,\n            never,\n            R2\n          > = pipe(\n            driver.last,\n            Effect.orDie,\n            Effect.flatMap((b) =>\n              pipe(\n                driver.reset,\n                Effect.map(() =>\n                  pipe(\n                    core.write(Chunk.of(options.onSchedule(b))),\n                    channel.zipRight(feed(input))\n                  )\n                )\n              )\n            )\n          )\n          return pipe(advance, Effect.orElse(() => reset), channel.unwrap)\n        }\n        const loop: Channel.Channel<Chunk.Chunk<C>, Chunk.Chunk<A>, E, E, void, unknown, R2> = core.readWith({\n          onInput: feed,\n          onFailure: core.fail,\n          onDone: () => core.void\n        })\n        return loop\n      }),\n      channel.unwrap\n    )\n    return new StreamImpl(pipe(toChannel(self), core.pipeTo(driver)))\n  }\n)\n\n/** @internal */\nexport const repeatValue = <A>(value: A): Stream.Stream<A> =>\n  new StreamImpl(\n    channel.repeated(core.write(Chunk.of(value)))\n  )\n\n/** @internal */\nexport const repeatWith = dual<\n  <B, R2, A, C>(\n    schedule: Schedule.Schedule<B, unknown, R2>,\n    options: {\n      readonly onElement: (a: A) => C\n      readonly onSchedule: (b: B) => C\n    }\n  ) => <E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<C, E, R2 | R>,\n  <A, E, R, B, R2, C>(\n    self: Stream.Stream<A, E, R>,\n    schedule: Schedule.Schedule<B, unknown, R2>,\n    options: {\n      readonly onElement: (a: A) => C\n      readonly onSchedule: (b: B) => C\n    }\n  ) => Stream.Stream<C, E, R2 | R>\n>(\n  3,\n  <A, E, R, B, R2, C>(\n    self: Stream.Stream<A, E, R>,\n    schedule: Schedule.Schedule<B, unknown, R2>,\n    options: {\n      readonly onElement: (a: A) => C\n      readonly onSchedule: (b: B) => C\n    }\n  ): Stream.Stream<C, E, R | R2> => {\n    return pipe(\n      Schedule.driver(schedule),\n      Effect.map((driver) => {\n        const provideLastIterationInfo = provideServiceEffect(\n          Schedule.CurrentIterationMetadata,\n          Ref.get(driver.iterationMeta)\n        )\n\n        const process = pipe(self, provideLastIterationInfo, map(options.onElement), toChannel)\n        const loop: Channel.Channel<Chunk.Chunk<C>, unknown, E, unknown, void, unknown, R | R2> = channel.unwrap(\n          Effect.match(\n            driver.next(void 0),\n            {\n              onFailure: () => core.void,\n              onSuccess: (output) =>\n                core.flatMap(\n                  process,\n                  () => channel.zipRight(core.write(Chunk.of(options.onSchedule(output))), loop)\n                )\n            }\n          )\n        )\n        return new StreamImpl(channel.zipRight(process, loop))\n      }),\n      unwrap\n    )\n  }\n)\n\nconst repeatWithSchedule = <A, R, X>(\n  value: A,\n  schedule: Schedule.Schedule<X, A, R>\n): Stream.Stream<A, never, R> => repeatEffectWithSchedule(Effect.succeed(value), schedule)\n\n/** @internal */\nexport const repeatEffectWithSchedule = <A, E, R, X, A0 extends A, R2>(\n  effect: Effect.Effect<A, E, R>,\n  schedule: Schedule.Schedule<X, A0, R2>\n): Stream.Stream<A, E, R | R2> =>\n  flatMap(\n    fromEffect(Effect.zip(effect, Schedule.driver(schedule))),\n    ([a, driver]) => {\n      const provideLastIterationInfo = Effect.provideServiceEffect(\n        Schedule.CurrentIterationMetadata,\n        Ref.get(driver.iterationMeta)\n      )\n      return concat(\n        succeed(a),\n        unfoldEffect(a, (s) =>\n          Effect.matchEffect(driver.next(s as A0), {\n            onFailure: Effect.succeed,\n            onSuccess: () =>\n              Effect.map(provideLastIterationInfo(effect), (nextA) => Option.some([nextA, nextA] as const))\n          }))\n      )\n    }\n  )\n\n/** @internal */\nexport const retry = dual<\n  <E, R2, X>(\n    policy: Schedule.Schedule<X, Types.NoInfer<E>, R2>\n  ) => <A, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A, E, R2 | R>,\n  <A, E, R, X, R2>(\n    self: Stream.Stream<A, E, R>,\n    policy: Schedule.Schedule<X, Types.NoInfer<E>, R2>\n  ) => Stream.Stream<A, E, R2 | R>\n>(\n  2,\n  <A, E, R, X, R2>(\n    self: Stream.Stream<A, E, R>,\n    policy: Schedule.Schedule<X, Types.NoInfer<E>, R2>\n  ): Stream.Stream<A, E, R2 | R> =>\n    Schedule.driver(policy).pipe(\n      Effect.map((driver) => {\n        const provideLastIterationInfo = provideServiceEffect(\n          Schedule.CurrentIterationMetadata,\n          Ref.get(driver.iterationMeta)\n        )\n\n        const loop: Channel.Channel<\n          Chunk.Chunk<A>,\n          unknown,\n          E,\n          unknown,\n          unknown,\n          unknown,\n          R2 | R\n        > = toChannel(provideLastIterationInfo(self)).pipe(\n          channel.mapOutEffect((out) => Effect.as(driver.reset, out)),\n          channel.catchAll((error) =>\n            driver.next(error).pipe(\n              Effect.match({\n                onFailure: () => core.fail(error),\n                onSuccess: () => loop\n              }),\n              channel.unwrap\n            )\n          )\n        )\n        return loop\n      }),\n      channel.unwrap,\n      fromChannel\n    )\n)\n\n/** @internal */\nexport const withExecutionPlan: {\n  <Input, R2, Provides, PolicyE>(\n    policy: ExecutionPlan<{\n      provides: Provides\n      input: Input\n      error: PolicyE\n      requirements: R2\n    }>,\n    options?: {\n      readonly preventFallbackOnPartialStream?: boolean | undefined\n    }\n  ): <A, E extends Input, R>(\n    self: Stream.Stream<A, E, R>\n  ) => Stream.Stream<A, E | PolicyE, R2 | Exclude<R, Provides>>\n  <A, E extends Input, R, R2, Input, Provides, PolicyE>(\n    self: Stream.Stream<A, E, R>,\n    policy: ExecutionPlan<{\n      provides: Provides\n      input: Input\n      error: PolicyE\n      requirements: R2\n    }>,\n    options?: {\n      readonly preventFallbackOnPartialStream?: boolean | undefined\n    }\n  ): Stream.Stream<A, E | PolicyE, R2 | Exclude<R, Provides>>\n} = dual((args) => isStream(args[0]), <A, E extends Input, R, R2, Input, Provides, PolicyE>(\n  self: Stream.Stream<A, E, R>,\n  policy: ExecutionPlan<{\n    provides: Provides\n    input: Input\n    error: PolicyE\n    requirements: R2\n  }>,\n  options?: {\n    readonly preventFallbackOnPartialStream?: boolean | undefined\n  }\n): Stream.Stream<A, E | PolicyE, R2 | Exclude<R, Provides>> =>\n  suspend(() => {\n    const preventFallbackOnPartialStream = options?.preventFallbackOnPartialStream ?? false\n    let i = 0\n    let lastError = Option.none<E | PolicyE>()\n    const loop: Stream.Stream<\n      A,\n      E | PolicyE,\n      R2 | Exclude<R, Provides>\n    > = suspend(() => {\n      const step = policy.steps[i++]\n      if (!step) {\n        return fail(Option.getOrThrow(lastError))\n      }\n\n      let nextStream: Stream.Stream<A, E | PolicyE, R2 | Exclude<R, Provides>> = Context.isContext(step.provide)\n        ? provideSomeContext(self, step.provide)\n        : provideSomeLayer(self, step.provide as Layer.Layer<Provides, E | PolicyE, R2>)\n      let receivedElements = false\n\n      if (Option.isSome(lastError)) {\n        const error = lastError.value\n        let attempted = false\n        const wrapped = nextStream\n        // ensure the schedule is applied at least once\n        nextStream = suspend(() => {\n          if (attempted) return wrapped\n          attempted = true\n          return fail(error)\n        })\n        nextStream = scheduleDefectRefail(retry(nextStream, internalExecutionPlan.scheduleFromStep(step, false)!))\n      } else {\n        const schedule = internalExecutionPlan.scheduleFromStep(step, true)\n        nextStream = schedule ? scheduleDefectRefail(retry(nextStream, schedule)) : nextStream\n      }\n\n      return catchAll(\n        preventFallbackOnPartialStream ?\n          mapChunks(nextStream, (chunk) => {\n            receivedElements = true\n            return chunk\n          }) :\n          nextStream,\n        (error) => {\n          if (preventFallbackOnPartialStream && receivedElements) {\n            return fail(error)\n          }\n          lastError = Option.some(error)\n          return loop\n        }\n      )\n    })\n    return loop\n  }))\n\nconst scheduleDefectRefail = <A, E, R>(self: Stream.Stream<A, E, R>) =>\n  catchAllCause(self, (cause) => failCause(InternalSchedule.scheduleDefectRefailCause(cause)))\n\n/** @internal */\nexport const run = dual<\n  <A2, A, E2, R2>(\n    sink: Sink.Sink<A2, A, unknown, E2, R2>\n  ) => <E, R>(\n    self: Stream.Stream<A, E, R>\n  ) => Effect.Effect<A2, E2 | E, R | R2>,\n  <A, E, R, A2, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    sink: Sink.Sink<A2, A, unknown, E2, R2>\n  ) => Effect.Effect<A2, E2 | E, R | R2>\n>(2, <A, E, R, A2, E2, R2>(\n  self: Stream.Stream<A, E, R>,\n  sink: Sink.Sink<A2, A, unknown, E2, R2>\n): Effect.Effect<A2, E2 | E, R | R2> =>\n  toChannel(self).pipe(\n    channel.pipeToOrFail(sink_.toChannel(sink)),\n    channel.runDrain\n  ))\n\n/** @internal */\nexport const runCollect = <A, E, R>(\n  self: Stream.Stream<A, E, R>\n): Effect.Effect<Chunk.Chunk<A>, E, R> => run(self, sink_.collectAll())\n\n/** @internal */\nexport const runCount = <A, E, R>(self: Stream.Stream<A, E, R>): Effect.Effect<number, E, R> => run(self, sink_.count)\n\n/** @internal */\nexport const runDrain = <A, E, R>(self: Stream.Stream<A, E, R>): Effect.Effect<void, E, R> => run(self, sink_.drain)\n\n/** @internal */\nexport const runFold = dual<\n  <S, A>(\n    s: S,\n    f: (s: S, a: A) => S\n  ) => <E, R>(\n    self: Stream.Stream<A, E, R>\n  ) => Effect.Effect<S, E, R>,\n  <A, E, R, S>(\n    self: Stream.Stream<A, E, R>,\n    s: S,\n    f: (s: S, a: A) => S\n  ) => Effect.Effect<S, E, R>\n>(\n  3,\n  <A, E, R, S>(self: Stream.Stream<A, E, R>, s: S, f: (s: S, a: A) => S): Effect.Effect<S, E, R> =>\n    runFoldWhile(self, s, constTrue, f)\n)\n\n/** @internal */\nexport const runFoldEffect = dual<\n  <S, A, E2, R2>(\n    s: S,\n    f: (s: S, a: A) => Effect.Effect<S, E2, R2>\n  ) => <E, R>(self: Stream.Stream<A, E, R>) => Effect.Effect<S, E2 | E, R | R2>,\n  <A, E, R, S, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    s: S,\n    f: (s: S, a: A) => Effect.Effect<S, E2, R2>\n  ) => Effect.Effect<S, E2 | E, R | R2>\n>(3, <A, E, R, S, E2, R2>(\n  self: Stream.Stream<A, E, R>,\n  s: S,\n  f: (s: S, a: A) => Effect.Effect<S, E2, R2>\n): Effect.Effect<S, E2 | E, R | R2> => runFoldWhileEffect(self, s, constTrue, f))\n\n/** @internal */\nexport const runFoldScoped = dual<\n  <S, A>(s: S, f: (s: S, a: A) => S) => <E, R>(self: Stream.Stream<A, E, R>) => Effect.Effect<S, E, Scope.Scope | R>,\n  <A, E, R, S>(self: Stream.Stream<A, E, R>, s: S, f: (s: S, a: A) => S) => Effect.Effect<S, E, Scope.Scope | R>\n>(\n  3,\n  <A, E, R, S>(self: Stream.Stream<A, E, R>, s: S, f: (s: S, a: A) => S): Effect.Effect<S, E, Scope.Scope | R> =>\n    pipe(self, runFoldWhileScoped(s, constTrue, f))\n)\n\n/** @internal */\nexport const runFoldScopedEffect = dual<\n  <S, A, E2, R2>(\n    s: S,\n    f: (s: S, a: A) => Effect.Effect<S, E2, R2>\n  ) => <E, R>(self: Stream.Stream<A, E, R>) => Effect.Effect<S, E2 | E, Scope.Scope | R2 | R>,\n  <A, E, R, S, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    s: S,\n    f: (s: S, a: A) => Effect.Effect<S, E2, R2>\n  ) => Effect.Effect<S, E2 | E, Scope.Scope | R2 | R>\n>(3, <A, E, R, S, E2, R2>(\n  self: Stream.Stream<A, E, R>,\n  s: S,\n  f: (s: S, a: A) => Effect.Effect<S, E2, R2>\n): Effect.Effect<S, E2 | E, Scope.Scope | R2 | R> => pipe(self, runFoldWhileScopedEffect(s, constTrue, f)))\n\n/** @internal */\nexport const runFoldWhile = dual<\n  <S, A>(\n    s: S,\n    cont: Predicate<S>,\n    f: (s: S, a: A) => S\n  ) => <E, R>(\n    self: Stream.Stream<A, E, R>\n  ) => Effect.Effect<S, E, R>,\n  <A, E, R, S>(\n    self: Stream.Stream<A, E, R>,\n    s: S,\n    cont: Predicate<S>,\n    f: (s: S, a: A) => S\n  ) => Effect.Effect<S, E, R>\n>(4, <A, E, R, S>(\n  self: Stream.Stream<A, E, R>,\n  s: S,\n  cont: Predicate<S>,\n  f: (s: S, a: A) => S\n): Effect.Effect<S, E, R> => run(self, sink_.fold(s, cont, f)))\n\n/** @internal */\nexport const runFoldWhileEffect = dual<\n  <S, A, E2, R2>(\n    s: S,\n    cont: Predicate<S>,\n    f: (s: S, a: A) => Effect.Effect<S, E2, R2>\n  ) => <E, R>(\n    self: Stream.Stream<A, E, R>\n  ) => Effect.Effect<S, E2 | E, R | R2>,\n  <A, E, R, S, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    s: S,\n    cont: Predicate<S>,\n    f: (s: S, a: A) => Effect.Effect<S, E2, R2>\n  ) => Effect.Effect<S, E2 | E, R | R2>\n>(4, <A, E, R, S, E2, R2>(\n  self: Stream.Stream<A, E, R>,\n  s: S,\n  cont: Predicate<S>,\n  f: (s: S, a: A) => Effect.Effect<S, E2, R2>\n): Effect.Effect<S, E2 | E, R | R2> => run(self, sink_.foldEffect(s, cont, f)))\n\n/** @internal */\nexport const runFoldWhileScoped = dual<\n  <S, A>(\n    s: S,\n    cont: Predicate<S>,\n    f: (s: S, a: A) => S\n  ) => <E, R>(self: Stream.Stream<A, E, R>) => Effect.Effect<S, E, Scope.Scope | R>,\n  <A, E, R, S>(\n    self: Stream.Stream<A, E, R>,\n    s: S,\n    cont: Predicate<S>,\n    f: (s: S, a: A) => S\n  ) => Effect.Effect<S, E, Scope.Scope | R>\n>(4, <A, E, R, S>(\n  self: Stream.Stream<A, E, R>,\n  s: S,\n  cont: Predicate<S>,\n  f: (s: S, a: A) => S\n): Effect.Effect<S, E, Scope.Scope | R> => pipe(self, runScoped(sink_.fold(s, cont, f))))\n\n/** @internal */\nexport const runFoldWhileScopedEffect = dual<\n  <S, A, E2, R2>(\n    s: S,\n    cont: Predicate<S>,\n    f: (s: S, a: A) => Effect.Effect<S, E2, R2>\n  ) => <E, R>(self: Stream.Stream<A, E, R>) => Effect.Effect<S, E2 | E, Scope.Scope | R2 | R>,\n  <A, E, R, S, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    s: S,\n    cont: Predicate<S>,\n    f: (s: S, a: A) => Effect.Effect<S, E2, R2>\n  ) => Effect.Effect<S, E2 | E, Scope.Scope | R2 | R>\n>(4, <A, E, R, S, E2, R2>(\n  self: Stream.Stream<A, E, R>,\n  s: S,\n  cont: Predicate<S>,\n  f: (s: S, a: A) => Effect.Effect<S, E2, R2>\n): Effect.Effect<S, E2 | E, Scope.Scope | R2 | R> => pipe(self, runScoped(sink_.foldEffect(s, cont, f))))\n\n/** @internal */\nexport const runForEach = dual<\n  <A, X, E2, R2>(\n    f: (a: A) => Effect.Effect<X, E2, R2>\n  ) => <E, R>(\n    self: Stream.Stream<A, E, R>\n  ) => Effect.Effect<void, E2 | E, R | R2>,\n  <A, E, R, X, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    f: (a: A) => Effect.Effect<X, E2, R2>\n  ) => Effect.Effect<void, E2 | E, R | R2>\n>(2, <A, E, R, X, E2, R2>(\n  self: Stream.Stream<A, E, R>,\n  f: (a: A) => Effect.Effect<X, E2, R2>\n): Effect.Effect<void, E2 | E, R | R2> => run(self, sink_.forEach(f)))\n\n/** @internal */\nexport const runForEachChunk = dual<\n  <A, X, E2, R2>(\n    f: (a: Chunk.Chunk<A>) => Effect.Effect<X, E2, R2>\n  ) => <E, R>(\n    self: Stream.Stream<A, E, R>\n  ) => Effect.Effect<void, E2 | E, R | R2>,\n  <A, E, R, X, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    f: (a: Chunk.Chunk<A>) => Effect.Effect<X, E2, R2>\n  ) => Effect.Effect<void, E2 | E, R | R2>\n>(2, <A, E, R, X, E2, R2>(\n  self: Stream.Stream<A, E, R>,\n  f: (a: Chunk.Chunk<A>) => Effect.Effect<X, E2, R2>\n): Effect.Effect<void, E2 | E, R | R2> => run(self, sink_.forEachChunk(f)))\n\n/** @internal */\nexport const runForEachChunkScoped = dual<\n  <A, X, E2, R2>(\n    f: (a: Chunk.Chunk<A>) => Effect.Effect<X, E2, R2>\n  ) => <E, R>(self: Stream.Stream<A, E, R>) => Effect.Effect<void, E2 | E, Scope.Scope | R2 | R>,\n  <A, E, R, X, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    f: (a: Chunk.Chunk<A>) => Effect.Effect<X, E2, R2>\n  ) => Effect.Effect<void, E2 | E, Scope.Scope | R2 | R>\n>(2, <A, E, R, X, E2, R2>(\n  self: Stream.Stream<A, E, R>,\n  f: (a: Chunk.Chunk<A>) => Effect.Effect<X, E2, R2>\n): Effect.Effect<void, E2 | E, Scope.Scope | R2 | R> => pipe(self, runScoped(sink_.forEachChunk(f))))\n\n/** @internal */\nexport const runForEachScoped = dual<\n  <A, X, E2, R2>(\n    f: (a: A) => Effect.Effect<X, E2, R2>\n  ) => <E, R>(self: Stream.Stream<A, E, R>) => Effect.Effect<void, E2 | E, R2 | R | Scope.Scope>,\n  <A, E, R, X, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    f: (a: A) => Effect.Effect<X, E2, R2>\n  ) => Effect.Effect<void, E2 | E, R2 | R | Scope.Scope>\n>(2, <A, E, R, X, E2, R2>(\n  self: Stream.Stream<A, E, R>,\n  f: (a: A) => Effect.Effect<X, E2, R2>\n): Effect.Effect<void, E2 | E, R2 | R | Scope.Scope> => pipe(self, runScoped(sink_.forEach(f))))\n\n/** @internal */\nexport const runForEachWhile = dual<\n  <A, E2, R2>(\n    f: (a: A) => Effect.Effect<boolean, E2, R2>\n  ) => <E, R>(\n    self: Stream.Stream<A, E, R>\n  ) => Effect.Effect<void, E2 | E, R | R2>,\n  <A, E, R, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    f: (a: A) => Effect.Effect<boolean, E2, R2>\n  ) => Effect.Effect<void, E2 | E, R | R2>\n>(2, <A, E, R, E2, R2>(\n  self: Stream.Stream<A, E, R>,\n  f: (a: A) => Effect.Effect<boolean, E2, R2>\n): Effect.Effect<void, E2 | E, R | R2> => run(self, sink_.forEachWhile(f)))\n\n/** @internal */\nexport const runForEachWhileScoped = dual<\n  <A, E2, R2>(\n    f: (a: A) => Effect.Effect<boolean, E2, R2>\n  ) => <E, R>(self: Stream.Stream<A, E, R>) => Effect.Effect<void, E2 | E, R2 | R | Scope.Scope>,\n  <A, E, R, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    f: (a: A) => Effect.Effect<boolean, E2, R2>\n  ) => Effect.Effect<void, E2 | E, R2 | R | Scope.Scope>\n>(2, <A, E, R, E2, R2>(\n  self: Stream.Stream<A, E, R>,\n  f: (a: A) => Effect.Effect<boolean, E2, R2>\n): Effect.Effect<void, E2 | E, R2 | R | Scope.Scope> => pipe(self, runScoped(sink_.forEachWhile(f))))\n\n/** @internal */\nexport const runHead = <A, E, R>(\n  self: Stream.Stream<A, E, R>\n): Effect.Effect<Option.Option<A>, E, R> => run(self, sink_.head<A>())\n\n/** @internal */\nexport const runIntoPubSub = dual<\n  <A, E>(\n    pubsub: PubSub.PubSub<Take.Take<A, E>>\n  ) => <R>(self: Stream.Stream<A, E, R>) => Effect.Effect<void, never, Exclude<R, Scope.Scope>>,\n  <A, E, R>(\n    self: Stream.Stream<A, E, R>,\n    pubsub: PubSub.PubSub<Take.Take<A, E>>\n  ) => Effect.Effect<void, never, Exclude<R, Scope.Scope>>\n>(\n  2,\n  <A, E, R>(\n    self: Stream.Stream<A, E, R>,\n    pubsub: PubSub.PubSub<Take.Take<A, E>>\n  ): Effect.Effect<void, never, Exclude<R, Scope.Scope>> => pipe(self, runIntoQueue(pubsub))\n)\n\n/** @internal */\nexport const runIntoPubSubScoped = dual<\n  <A, E>(\n    pubsub: PubSub.PubSub<Take.Take<A, E>>\n  ) => <R>(self: Stream.Stream<A, E, R>) => Effect.Effect<void, never, Scope.Scope | R>,\n  <A, E, R>(\n    self: Stream.Stream<A, E, R>,\n    pubsub: PubSub.PubSub<Take.Take<A, E>>\n  ) => Effect.Effect<void, never, Scope.Scope | R>\n>(2, <A, E, R>(\n  self: Stream.Stream<A, E, R>,\n  pubsub: PubSub.PubSub<Take.Take<A, E>>\n): Effect.Effect<void, never, Scope.Scope | R> => pipe(self, runIntoQueueScoped(pubsub)))\n\n/** @internal */\nexport const runIntoQueue = dual<\n  <A, E>(\n    queue: Queue.Enqueue<Take.Take<A, E>>\n  ) => <R>(self: Stream.Stream<A, E, R>) => Effect.Effect<void, never, Exclude<R, Scope.Scope>>,\n  <A, E, R>(\n    self: Stream.Stream<A, E, R>,\n    queue: Queue.Enqueue<Take.Take<A, E>>\n  ) => Effect.Effect<void, never, Exclude<R, Scope.Scope>>\n>(\n  2,\n  <A, E, R>(\n    self: Stream.Stream<A, E, R>,\n    queue: Queue.Enqueue<Take.Take<A, E>>\n  ): Effect.Effect<void, never, Exclude<R, Scope.Scope>> => pipe(self, runIntoQueueScoped(queue), Effect.scoped)\n)\n\n/** @internal */\nexport const runIntoQueueElementsScoped = dual<\n  <A, E>(\n    queue: Queue.Enqueue<Exit.Exit<A, Option.Option<E>>>\n  ) => <R>(self: Stream.Stream<A, E, R>) => Effect.Effect<void, never, Scope.Scope | R>,\n  <A, E, R>(\n    self: Stream.Stream<A, E, R>,\n    queue: Queue.Enqueue<Exit.Exit<A, Option.Option<E>>>\n  ) => Effect.Effect<void, never, Scope.Scope | R>\n>(2, <A, E, R>(\n  self: Stream.Stream<A, E, R>,\n  queue: Queue.Enqueue<Exit.Exit<A, Option.Option<E>>>\n): Effect.Effect<void, never, Scope.Scope | R> => {\n  const writer: Channel.Channel<Exit.Exit<A, Option.Option<E>>, Chunk.Chunk<A>, never, E, unknown, unknown, R> = core\n    .readWithCause({\n      onInput: (input: Chunk.Chunk<A>) =>\n        core.flatMap(\n          core.fromEffect(Queue.offerAll(queue, Chunk.map(input, Exit.succeed))),\n          () => writer\n        ),\n      onFailure: (cause) => core.fromEffect(Queue.offer(queue, Exit.failCause(Cause.map(cause, Option.some)))),\n      onDone: () => core.fromEffect(Queue.offer(queue, Exit.fail(Option.none())))\n    })\n  return pipe(\n    core.pipeTo(toChannel(self), writer),\n    channel.drain,\n    channel.runScoped,\n    Effect.asVoid\n  )\n})\n\n/** @internal */\nexport const runIntoQueueScoped = dual<\n  <A, E>(\n    queue: Queue.Enqueue<Take.Take<A, E>>\n  ) => <R>(self: Stream.Stream<A, E, R>) => Effect.Effect<void, never, Scope.Scope | R>,\n  <A, E, R>(\n    self: Stream.Stream<A, E, R>,\n    queue: Queue.Enqueue<Take.Take<A, E>>\n  ) => Effect.Effect<void, never, Scope.Scope | R>\n>(2, <A, E, R>(\n  self: Stream.Stream<A, E, R>,\n  queue: Queue.Enqueue<Take.Take<A, E>>\n): Effect.Effect<void, never, Scope.Scope | R> => {\n  const writer: Channel.Channel<Take.Take<A, E>, Chunk.Chunk<A>, never, E, unknown, unknown, R> = core\n    .readWithCause({\n      onInput: (input: Chunk.Chunk<A>) => core.flatMap(core.write(InternalTake.chunk(input)), () => writer),\n      onFailure: (cause) => core.write(InternalTake.failCause(cause)),\n      onDone: () => core.write(InternalTake.end)\n    })\n  return pipe(\n    core.pipeTo(toChannel(self), writer),\n    channel.mapOutEffect((take) => Queue.offer(queue, take)),\n    channel.drain,\n    channel.runScoped,\n    Effect.asVoid\n  )\n})\n\n/** @internal */\nexport const runLast = <A, E, R>(\n  self: Stream.Stream<A, E, R>\n): Effect.Effect<Option.Option<A>, E, R> => run(self, sink_.last())\n\n/** @internal */\nexport const runScoped = dual<\n  <A2, A, E2, R2>(\n    sink: Sink.Sink<A2, A, unknown, E2, R2>\n  ) => <E, R>(self: Stream.Stream<A, E, R>) => Effect.Effect<A2, E | E2, R | R2 | Scope.Scope>,\n  <A, E, R, A2, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    sink: Sink.Sink<A2, A, unknown, E2, R2>\n  ) => Effect.Effect<A2, E | E2, R | R2 | Scope.Scope>\n>(2, <A, E, R, A2, E2, R2>(\n  self: Stream.Stream<A, E, R>,\n  sink: Sink.Sink<A2, A, unknown, E2, R2>\n): Effect.Effect<A2, E | E2, R | R2 | Scope.Scope> =>\n  pipe(\n    toChannel(self),\n    channel.pipeToOrFail(sink_.toChannel(sink)),\n    channel.drain,\n    channel.runScoped\n  ))\n\n/** @internal */\nexport const runSum = <E, R>(self: Stream.Stream<number, E, R>): Effect.Effect<number, E, R> => run(self, sink_.sum)\n\n/** @internal */\nexport const scan = dual<\n  <S, A>(s: S, f: (s: S, a: A) => S) => <E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<S, E, R>,\n  <A, E, R, S>(self: Stream.Stream<A, E, R>, s: S, f: (s: S, a: A) => S) => Stream.Stream<S, E, R>\n>(\n  3,\n  <A, E, R, S>(self: Stream.Stream<A, E, R>, s: S, f: (s: S, a: A) => S): Stream.Stream<S, E, R> =>\n    pipe(self, scanEffect(s, (s, a) => Effect.succeed(f(s, a))))\n)\n\n/** @internal */\nexport const scanReduce = dual<\n  <A2, A>(f: (a2: A2 | A, a: A) => A2) => <E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A2 | A, E, R>,\n  <A, E, R, A2>(self: Stream.Stream<A, E, R>, f: (a2: A2 | A, a: A) => A2) => Stream.Stream<A2 | A, E, R>\n>(\n  2,\n  <A, E, R, A2>(self: Stream.Stream<A, E, R>, f: (a2: A | A2, a: A) => A2): Stream.Stream<A | A2, E, R> =>\n    pipe(self, scanReduceEffect((a2, a) => Effect.succeed(f(a2, a))))\n)\n\n/** @internal */\nexport const scanReduceEffect = dual<\n  <A2, A, E2, R2>(\n    f: (a2: A2 | A, a: A) => Effect.Effect<A2 | A, E2, R2>\n  ) => <E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A2 | A, E2 | E, R2 | R>,\n  <A, E, R, A2, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    f: (a2: A2 | A, a: A) => Effect.Effect<A2 | A, E2, R2>\n  ) => Stream.Stream<A2 | A, E2 | E, R2 | R>\n>(\n  2,\n  <A, E, R, A2, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    f: (a2: A | A2, a: A) => Effect.Effect<A2 | A, E2, R2>\n  ): Stream.Stream<A2 | A, E2 | E, R2 | R> =>\n    pipe(\n      self,\n      mapAccumEffect<Option.Option<A | A2>, A, A | A2, E2, R2>(Option.none() as Option.Option<A | A2>, (option, a) => {\n        switch (option._tag) {\n          case \"None\": {\n            return Effect.succeed([Option.some<A | A2>(a), a] as const)\n          }\n          case \"Some\": {\n            return pipe(\n              f(option.value, a),\n              Effect.map((b) => [Option.some<A | A2>(b), b] as const)\n            )\n          }\n        }\n      })\n    )\n)\n\n/** @internal */\nexport const schedule = dual<\n  <X, A0 extends A, R2, A>(\n    schedule: Schedule.Schedule<X, A0, R2>\n  ) => <E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A, E, R2 | R>,\n  <A, E, R, X, A0 extends A, R2>(\n    self: Stream.Stream<A, E, R>,\n    schedule: Schedule.Schedule<X, A0, R2>\n  ) => Stream.Stream<A, E, R2 | R>\n>(\n  2,\n  <A, E, R, X, A0 extends A, R2>(\n    self: Stream.Stream<A, E, R>,\n    schedule: Schedule.Schedule<X, A0, R2>\n  ): Stream.Stream<A, E, R | R2> =>\n    filterMap(\n      scheduleWith(self, schedule, { onElement: Option.some, onSchedule: Option.none }),\n      identity\n    )\n)\n\n/** @internal */\nexport const scheduleWith = dual<\n  <B, A0 extends A, R2, A, C>(\n    schedule: Schedule.Schedule<B, A0, R2>,\n    options: {\n      readonly onElement: (a: A) => C\n      readonly onSchedule: (b: B) => C\n    }\n  ) => <E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<C, E, R2 | R>,\n  <A, E, R, B, A0 extends A, R2, C>(\n    self: Stream.Stream<A, E, R>,\n    schedule: Schedule.Schedule<B, A0, R2>,\n    options: {\n      readonly onElement: (a: A) => C\n      readonly onSchedule: (b: B) => C\n    }\n  ) => Stream.Stream<C, E, R2 | R>\n>(\n  3,\n  <A, E, R, B, A0 extends A, R2, C>(\n    self: Stream.Stream<A, E, R>,\n    schedule: Schedule.Schedule<B, A0, R2>,\n    options: {\n      readonly onElement: (a: A) => C\n      readonly onSchedule: (b: B) => C\n    }\n  ): Stream.Stream<C, E, R | R2> => {\n    const loop = (\n      driver: Schedule.ScheduleDriver<B, A0, R2>,\n      iterator: Iterator<A>\n    ): Channel.Channel<Chunk.Chunk<C>, Chunk.Chunk<A>, E, E, unknown, unknown, R2> => {\n      const next = iterator.next()\n      if (next.done) {\n        return core.readWithCause({\n          onInput: (chunk: Chunk.Chunk<A>) => loop(driver, chunk[Symbol.iterator]()),\n          onFailure: core.failCause,\n          onDone: core.succeedNow\n        })\n      }\n      return channel.unwrap(\n        Effect.matchEffect(driver.next(next.value as A0), {\n          onFailure: () =>\n            pipe(\n              driver.last,\n              Effect.orDie,\n              Effect.map((b) =>\n                pipe(\n                  core.write(Chunk.make(options.onElement(next.value), options.onSchedule(b))),\n                  core.flatMap(() => loop(driver, iterator))\n                )\n              ),\n              Effect.zipLeft(driver.reset)\n            ),\n          onSuccess: () =>\n            Effect.succeed(pipe(\n              core.write(Chunk.of(options.onElement(next.value))),\n              core.flatMap(() => loop(driver, iterator))\n            ))\n        })\n      )\n    }\n    return new StreamImpl(\n      pipe(\n        core.fromEffect(Schedule.driver(schedule)),\n        core.flatMap((driver) =>\n          pipe(\n            toChannel(self),\n            core.pipeTo(loop(driver, Chunk.empty<A>()[Symbol.iterator]()))\n          )\n        )\n      )\n    )\n  }\n)\n\n/** @internal */\nexport const scanEffect = dual<\n  <S, A, E2, R2>(\n    s: S,\n    f: (s: S, a: A) => Effect.Effect<S, E2, R2>\n  ) => <E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<S, E2 | E, R2 | R>,\n  <A, E, R, S, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    s: S,\n    f: (s: S, a: A) => Effect.Effect<S, E2, R2>\n  ) => Stream.Stream<S, E2 | E, R2 | R>\n>(\n  3,\n  <A, E, R, S, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    s: S,\n    f: (s: S, a: A) => Effect.Effect<S, E2, R2>\n  ): Stream.Stream<S, E2 | E, R2 | R> =>\n    new StreamImpl(\n      pipe(\n        core.write(Chunk.of(s)),\n        core.flatMap(() =>\n          toChannel(pipe(\n            self,\n            mapAccumEffect(s, (s, a) => pipe(f(s, a), Effect.map((s) => [s, s])))\n          ))\n        )\n      )\n    )\n)\n\n/** @internal */\nexport const scoped = <A, E, R>(\n  effect: Effect.Effect<A, E, R>\n): Stream.Stream<A, E, Exclude<R, Scope.Scope>> =>\n  new StreamImpl(channel.ensuring(channel.scoped(pipe(effect, Effect.map(Chunk.of))), Effect.void))\n\n/** @internal */\nexport const scopedWith = <A, E, R>(\n  f: (scope: Scope.Scope) => Effect.Effect<A, E, R>\n): Stream.Stream<A, E, R> =>\n  new StreamImpl(channel.scopedWith((scope) =>\n    f(scope).pipe(\n      Effect.map(Chunk.of)\n    )\n  ))\n\n/** @internal */\nexport const some = <A, E, R>(self: Stream.Stream<Option.Option<A>, E, R>): Stream.Stream<A, Option.Option<E>, R> =>\n  pipe(self, mapError(Option.some), someOrFail(() => Option.none()))\n\n/** @internal */\nexport const someOrElse = dual<\n  <A2>(fallback: LazyArg<A2>) => <A, E, R>(self: Stream.Stream<Option.Option<A>, E, R>) => Stream.Stream<A2 | A, E, R>,\n  <A, E, R, A2>(self: Stream.Stream<Option.Option<A>, E, R>, fallback: LazyArg<A2>) => Stream.Stream<A2 | A, E, R>\n>(\n  2,\n  <A, E, R, A2>(self: Stream.Stream<Option.Option<A>, E, R>, fallback: LazyArg<A2>): Stream.Stream<A | A2, E, R> =>\n    pipe(self, map(Option.getOrElse(fallback)))\n)\n\n/** @internal */\nexport const someOrFail = dual<\n  <E2>(error: LazyArg<E2>) => <A, E, R>(self: Stream.Stream<Option.Option<A>, E, R>) => Stream.Stream<A, E2 | E, R>,\n  <A, E, R, E2>(self: Stream.Stream<Option.Option<A>, E, R>, error: LazyArg<E2>) => Stream.Stream<A, E2 | E, R>\n>(\n  2,\n  <A, E, R, E2>(self: Stream.Stream<Option.Option<A>, E, R>, error: LazyArg<E2>): Stream.Stream<A, E | E2, R> =>\n    mapEffectSequential(\n      self,\n      Option.match({\n        onNone: () => Effect.failSync(error),\n        onSome: Effect.succeed\n      })\n    )\n)\n\n/** @internal */\nexport const sliding = dual<\n  (\n    chunkSize: number\n  ) => <A, E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<Chunk.Chunk<A>, E, R>,\n  <A, E, R>(self: Stream.Stream<A, E, R>, chunkSize: number) => Stream.Stream<Chunk.Chunk<A>, E, R>\n>(\n  2,\n  <A, E, R>(self: Stream.Stream<A, E, R>, chunkSize: number): Stream.Stream<Chunk.Chunk<A>, E, R> =>\n    slidingSize(self, chunkSize, 1)\n)\n\n/** @internal */\nexport const slidingSize = dual<\n  (\n    chunkSize: number,\n    stepSize: number\n  ) => <A, E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<Chunk.Chunk<A>, E, R>,\n  <A, E, R>(self: Stream.Stream<A, E, R>, chunkSize: number, stepSize: number) => Stream.Stream<Chunk.Chunk<A>, E, R>\n>(\n  3,\n  <A, E, R>(self: Stream.Stream<A, E, R>, chunkSize: number, stepSize: number): Stream.Stream<Chunk.Chunk<A>, E, R> => {\n    if (chunkSize <= 0 || stepSize <= 0) {\n      return die(\n        new Cause.IllegalArgumentException(\"Invalid bounds - `chunkSize` and `stepSize` must be greater than zero\")\n      )\n    }\n    return new StreamImpl(core.suspend(() => {\n      const queue = new RingBuffer<A>(chunkSize)\n      const emitOnStreamEnd = (\n        queueSize: number,\n        channelEnd: Channel.Channel<Chunk.Chunk<Chunk.Chunk<A>>, Chunk.Chunk<A>, E, E, unknown, unknown>\n      ) => {\n        if (queueSize < chunkSize) {\n          const items = queue.toChunk()\n          const result = Chunk.isEmpty(items) ? Chunk.empty<Chunk.Chunk<A>>() : Chunk.of(items)\n          return pipe(core.write(result), core.flatMap(() => channelEnd))\n        }\n        const lastEmitIndex = queueSize - (queueSize - chunkSize) % stepSize\n        if (lastEmitIndex === queueSize) {\n          return channelEnd\n        }\n        const leftovers = queueSize - (lastEmitIndex - chunkSize + stepSize)\n        const lastItems = pipe(queue.toChunk(), Chunk.takeRight(leftovers))\n        const result = Chunk.isEmpty(lastItems) ? Chunk.empty<Chunk.Chunk<A>>() : Chunk.of(lastItems)\n        return pipe(core.write(result), core.flatMap(() => channelEnd))\n      }\n      const reader = (\n        queueSize: number\n      ): Channel.Channel<Chunk.Chunk<Chunk.Chunk<A>>, Chunk.Chunk<A>, E, E, unknown, unknown> =>\n        core.readWithCause({\n          onInput: (input: Chunk.Chunk<A>) =>\n            core.flatMap(\n              core.write(\n                Chunk.filterMap(input, (element, index) => {\n                  queue.put(element)\n                  const currentIndex = queueSize + index + 1\n                  if (currentIndex < chunkSize || (currentIndex - chunkSize) % stepSize > 0) {\n                    return Option.none()\n                  }\n                  return Option.some(queue.toChunk())\n                })\n              ),\n              () => reader(queueSize + input.length)\n            ),\n          onFailure: (cause) => emitOnStreamEnd(queueSize, core.failCause(cause)),\n          onDone: () => emitOnStreamEnd(queueSize, core.void)\n        })\n      return pipe(toChannel(self), core.pipeTo(reader(0)))\n    }))\n  }\n)\n\n/** @internal */\nexport const split: {\n  <A, B extends A>(\n    refinement: Refinement<Types.NoInfer<A>, B>\n  ): <E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<Chunk.Chunk<Exclude<A, B>>, E, R>\n  <A>(\n    predicate: Predicate<Types.NoInfer<A>>\n  ): <E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<Chunk.Chunk<A>, E, R>\n  <A, E, R, B extends A>(\n    self: Stream.Stream<A, E, R>,\n    refinement: Refinement<A, B>\n  ): Stream.Stream<Chunk.Chunk<Exclude<A, B>>, E, R>\n  <A, E, R>(self: Stream.Stream<A, E, R>, predicate: Predicate<A>): Stream.Stream<Chunk.Chunk<A>, E, R>\n} = dual(\n  2,\n  <A, E, R>(\n    self: Stream.Stream<A, E, R>,\n    predicate: Predicate<A>\n  ): Stream.Stream<Chunk.Chunk<A>, E, R> => {\n    const split = (\n      leftovers: Chunk.Chunk<A>,\n      input: Chunk.Chunk<A>\n    ): Channel.Channel<Chunk.Chunk<Chunk.Chunk<A>>, Chunk.Chunk<A>, E, E, unknown, unknown, R> => {\n      const [chunk, remaining] = pipe(leftovers, Chunk.appendAll(input), Chunk.splitWhere(predicate))\n      if (Chunk.isEmpty(chunk) || Chunk.isEmpty(remaining)) {\n        return loop(pipe(chunk, Chunk.appendAll(pipe(remaining, Chunk.drop(1)))))\n      }\n      return pipe(\n        core.write(Chunk.of(chunk)),\n        core.flatMap(() => split(Chunk.empty(), pipe(remaining, Chunk.drop(1))))\n      )\n    }\n    const loop = (\n      leftovers: Chunk.Chunk<A>\n    ): Channel.Channel<Chunk.Chunk<Chunk.Chunk<A>>, Chunk.Chunk<A>, E, E, unknown, unknown, R> =>\n      core.readWith({\n        onInput: (input: Chunk.Chunk<A>) => split(leftovers, input),\n        onFailure: core.fail,\n        onDone: () => {\n          if (Chunk.isEmpty(leftovers)) {\n            return core.void\n          }\n          if (Option.isNone(pipe(leftovers, Chunk.findFirst(predicate)))) {\n            return channel.zipRight(core.write(Chunk.of(leftovers)), core.void)\n          }\n          return channel.zipRight(\n            split(Chunk.empty(), leftovers),\n            core.void\n          )\n        }\n      })\n    return new StreamImpl(pipe(toChannel(self), core.pipeTo(loop(Chunk.empty()))))\n  }\n)\n\n/** @internal */\nexport const splitOnChunk = dual<\n  <A>(delimiter: Chunk.Chunk<A>) => <E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<Chunk.Chunk<A>, E, R>,\n  <A, E, R>(self: Stream.Stream<A, E, R>, delimiter: Chunk.Chunk<A>) => Stream.Stream<Chunk.Chunk<A>, E, R>\n>(2, <A, E, R>(self: Stream.Stream<A, E, R>, delimiter: Chunk.Chunk<A>): Stream.Stream<Chunk.Chunk<A>, E, R> => {\n  const next = (\n    leftover: Option.Option<Chunk.Chunk<A>>,\n    delimiterIndex: number\n  ): Channel.Channel<Chunk.Chunk<Chunk.Chunk<A>>, Chunk.Chunk<A>, E, E, unknown, unknown, R> =>\n    core.readWithCause({\n      onInput: (inputChunk: Chunk.Chunk<A>) => {\n        let buffer: Array<Chunk.Chunk<A>> | undefined\n        const [carry, delimiterCursor] = pipe(\n          inputChunk,\n          Chunk.reduce(\n            [pipe(leftover, Option.getOrElse(() => Chunk.empty<A>())), delimiterIndex] as const,\n            ([carry, delimiterCursor], a) => {\n              const concatenated = pipe(carry, Chunk.append(a))\n              if (\n                delimiterCursor < delimiter.length &&\n                Equal.equals(a, pipe(delimiter, Chunk.unsafeGet(delimiterCursor)))\n              ) {\n                if (delimiterCursor + 1 === delimiter.length) {\n                  if (buffer === undefined) {\n                    buffer = []\n                  }\n                  buffer.push(pipe(concatenated, Chunk.take(concatenated.length - delimiter.length)))\n                  return [Chunk.empty<A>(), 0] as const\n                }\n                return [concatenated, delimiterCursor + 1] as const\n              }\n              return [concatenated, Equal.equals(a, pipe(delimiter, Chunk.unsafeGet(0))) ? 1 : 0] as const\n            }\n          )\n        )\n        const output = buffer === undefined ? Chunk.empty<Chunk.Chunk<A>>() : Chunk.unsafeFromArray(buffer)\n        return core.flatMap(\n          core.write(output),\n          () => next(Chunk.isNonEmpty(carry) ? Option.some(carry) : Option.none(), delimiterCursor)\n        )\n      },\n      onFailure: (cause) =>\n        Option.match(leftover, {\n          onNone: () => core.failCause(cause),\n          onSome: (chunk) =>\n            channel.zipRight(\n              core.write(Chunk.of(chunk)),\n              core.failCause(cause)\n            )\n        }),\n      onDone: (done) =>\n        Option.match(leftover, {\n          onNone: () => core.succeed(done),\n          onSome: (chunk) => channel.zipRight(core.write(Chunk.of(chunk)), core.succeed(done))\n        })\n    })\n  return new StreamImpl(pipe(toChannel(self), core.pipeTo(next(Option.none(), 0))))\n})\n\n/** @internal */\nexport const splitLines = <E, R>(self: Stream.Stream<string, E, R>): Stream.Stream<string, E, R> =>\n  pipeThroughChannel(self, channel.splitLines())\n\n/** @internal */\nexport const succeed = <A>(value: A): Stream.Stream<A> => fromChunk(Chunk.of(value))\n\n/** @internal */\nexport const sync = <A>(evaluate: LazyArg<A>): Stream.Stream<A> => suspend(() => fromChunk(Chunk.of(evaluate())))\n\n/** @internal */\nexport const suspend = <A, E, R>(stream: LazyArg<Stream.Stream<A, E, R>>): Stream.Stream<A, E, R> =>\n  new StreamImpl(core.suspend(() => toChannel(stream())))\n\n/** @internal */\nexport const take = dual<\n  (n: number) => <A, E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A, E, R>,\n  <A, E, R>(self: Stream.Stream<A, E, R>, n: number) => Stream.Stream<A, E, R>\n>(2, <A, E, R>(self: Stream.Stream<A, E, R>, n: number): Stream.Stream<A, E, R> => {\n  if (!Number.isInteger(n)) {\n    return die(new Cause.IllegalArgumentException(`${n} must be an integer`))\n  }\n  const loop = (n: number): Channel.Channel<Chunk.Chunk<A>, Chunk.Chunk<A>, never, never, unknown, unknown> =>\n    core.readWith({\n      onInput: (input: Chunk.Chunk<A>) => {\n        const taken = pipe(input, Chunk.take(Math.min(n, Number.POSITIVE_INFINITY)))\n        const leftover = Math.max(0, n - taken.length)\n        const more = leftover > 0\n        if (more) {\n          return pipe(core.write(taken), core.flatMap(() => loop(leftover)))\n        }\n        return core.write(taken)\n      },\n      onFailure: core.fail,\n      onDone: core.succeed\n    })\n  return new StreamImpl(\n    pipe(\n      toChannel(self),\n      channel.pipeToOrFail(0 < n ? loop(n) : core.void)\n    )\n  )\n})\n\n/** @internal */\nexport const takeRight = dual<\n  (n: number) => <A, E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A, E, R>,\n  <A, E, R>(self: Stream.Stream<A, E, R>, n: number) => Stream.Stream<A, E, R>\n>(2, <A, E, R>(self: Stream.Stream<A, E, R>, n: number): Stream.Stream<A, E, R> => {\n  if (n <= 0) {\n    return empty\n  }\n  return new StreamImpl(\n    pipe(\n      Effect.succeed(new RingBuffer<A>(n)),\n      Effect.map((queue) => {\n        const reader: Channel.Channel<Chunk.Chunk<A>, Chunk.Chunk<A>, E, E, void, unknown> = core.readWith({\n          onInput: (input: Chunk.Chunk<A>) => {\n            for (const element of input) {\n              queue.put(element)\n            }\n            return reader\n          },\n          onFailure: core.fail,\n          onDone: () => pipe(core.write(queue.toChunk()), channel.zipRight(core.void))\n        })\n        return pipe(toChannel(self), core.pipeTo(reader))\n      }),\n      channel.unwrap\n    )\n  )\n})\n\n/** @internal */\nexport const takeUntil: {\n  <A>(predicate: Predicate<Types.NoInfer<A>>): <E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A, E, R>\n  <A, E, R>(self: Stream.Stream<A, E, R>, predicate: Predicate<A>): Stream.Stream<A, E, R>\n} = dual(2, <A, E, R>(self: Stream.Stream<A, E, R>, predicate: Predicate<A>): Stream.Stream<A, E, R> => {\n  const loop: Channel.Channel<Chunk.Chunk<A>, Chunk.Chunk<A>, never, never, unknown, unknown> = core.readWith({\n    onInput: (input: Chunk.Chunk<A>) => {\n      const taken = pipe(input, Chunk.takeWhile((a) => !predicate(a)))\n      const last = pipe(input, Chunk.drop(taken.length), Chunk.take(1))\n      if (Chunk.isEmpty(last)) {\n        return pipe(core.write(taken), core.flatMap(() => loop))\n      }\n      return core.write(pipe(taken, Chunk.appendAll(last)))\n    },\n    onFailure: core.fail,\n    onDone: core.succeed\n  })\n  return new StreamImpl(pipe(toChannel(self), channel.pipeToOrFail(loop)))\n})\n\n/** @internal */\nexport const takeUntilEffect: {\n  <A, E2, R2>(\n    predicate: (a: Types.NoInfer<A>) => Effect.Effect<boolean, E2, R2>\n  ): <E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A, E2 | E, R2 | R>\n  <A, E, R, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    predicate: (a: A) => Effect.Effect<boolean, E2, R2>\n  ): Stream.Stream<A, E | E2, R | R2>\n} = dual(\n  2,\n  <A, E, R, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    predicate: (a: A) => Effect.Effect<boolean, E2, R2>\n  ): Stream.Stream<A, E | E2, R | R2> => {\n    const loop = (\n      iterator: Iterator<A>\n    ): Channel.Channel<Chunk.Chunk<A>, Chunk.Chunk<A>, E | E2, E, unknown, unknown, R2> => {\n      const next = iterator.next()\n      if (next.done) {\n        return core.readWithCause({\n          onInput: (elem) => loop(elem[Symbol.iterator]()),\n          onFailure: core.failCause,\n          onDone: core.succeed\n        })\n      }\n      return pipe(\n        predicate(next.value),\n        Effect.map((bool) =>\n          bool ?\n            core.write(Chunk.of(next.value)) :\n            pipe(\n              core.write(Chunk.of(next.value)),\n              core.flatMap(() => loop(iterator))\n            )\n        ),\n        channel.unwrap\n      )\n    }\n    return new StreamImpl(pipe(toChannel(self), core.pipeTo(loop(Chunk.empty<A>()[Symbol.iterator]()))))\n  }\n)\n\n/** @internal */\nexport const takeWhile: {\n  <A, B extends A>(\n    refinement: Refinement<Types.NoInfer<A>, B>\n  ): <E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<B, E, R>\n  <A>(predicate: Predicate<Types.NoInfer<A>>): <E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A, E, R>\n  <A, E, R, B extends A>(self: Stream.Stream<A, E, R>, refinement: Refinement<A, B>): Stream.Stream<B, E, R>\n  <A, E, R>(self: Stream.Stream<A, E, R>, predicate: Predicate<A>): Stream.Stream<A, E, R>\n} = dual(2, <A, E, R>(self: Stream.Stream<A, E, R>, predicate: Predicate<A>): Stream.Stream<A, E, R> => {\n  const loop: Channel.Channel<Chunk.Chunk<A>, Chunk.Chunk<A>, never, never, unknown, unknown> = core.readWith({\n    onInput: (input: Chunk.Chunk<A>) => {\n      const taken = pipe(input, Chunk.takeWhile(predicate))\n      const more = taken.length === input.length\n      if (more) {\n        return pipe(core.write(taken), core.flatMap(() => loop))\n      }\n      return core.write(taken)\n    },\n    onFailure: core.fail,\n    onDone: core.succeed\n  })\n  return new StreamImpl(pipe(toChannel(self), channel.pipeToOrFail(loop)))\n})\n\n/** @internal */\nexport const tap: {\n  <A, X, E2, R2>(\n    f: (a: Types.NoInfer<A>) => Effect.Effect<X, E2, R2>\n  ): <E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A, E2 | E, R2 | R>\n  <A, E, R, X, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    f: (a: Types.NoInfer<A>) => Effect.Effect<X, E2, R2>\n  ): Stream.Stream<A, E | E2, R | R2>\n} = dual(\n  2,\n  <A, E, R, X, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    f: (a: Types.NoInfer<A>) => Effect.Effect<X, E2, R2>\n  ): Stream.Stream<A, E | E2, R | R2> => mapEffectSequential(self, (a) => Effect.as(f(a), a))\n)\n\n/** @internal */\nexport const tapBoth: {\n  <E, X1, E2, R2, A, X2, E3, R3>(\n    options: {\n      readonly onFailure: (e: Types.NoInfer<E>) => Effect.Effect<X1, E2, R2>\n      readonly onSuccess: (a: Types.NoInfer<A>) => Effect.Effect<X2, E3, R3>\n    }\n  ): <R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A, E | E2 | E3, R | R2 | R3>\n  <A, E, R, X1, E2, R2, X2, E3, R3>(\n    self: Stream.Stream<A, E, R>,\n    options: {\n      readonly onFailure: (e: Types.NoInfer<E>) => Effect.Effect<X1, E2, R2>\n      readonly onSuccess: (a: Types.NoInfer<A>) => Effect.Effect<X2, E3, R3>\n    }\n  ): Stream.Stream<A, E | E2 | E3, R | R2 | R3>\n} = dual(\n  2,\n  <A, E, R, X1, E2, R2, X2, E3, R3>(\n    self: Stream.Stream<A, E, R>,\n    options: {\n      readonly onFailure: (e: Types.NoInfer<E>) => Effect.Effect<X1, E2, R2>\n      readonly onSuccess: (a: Types.NoInfer<A>) => Effect.Effect<X2, E3, R3>\n    }\n  ): Stream.Stream<A, E | E2 | E3, R | R2 | R3> => pipe(self, tapError(options.onFailure), tap(options.onSuccess))\n)\n\n/** @internal */\nexport const tapError: {\n  <E, X, E2, R2>(\n    f: (error: Types.NoInfer<E>) => Effect.Effect<X, E2, R2>\n  ): <A, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A, E | E2, R2 | R>\n  <A, E, R, X, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    f: (error: E) => Effect.Effect<X, E2, R2>\n  ): Stream.Stream<A, E | E2, R | R2>\n} = dual(\n  2,\n  <A, E, R, X, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    f: (error: E) => Effect.Effect<X, E2, R2>\n  ): Stream.Stream<A, E | E2, R | R2> =>\n    catchAll(self, (error) => fromEffect(Effect.zipRight(f(error), Effect.fail(error))))\n)\n\n/** @internal */\nexport const tapErrorCause: {\n  <E, X, E2, R2>(\n    f: (cause: Cause.Cause<Types.NoInfer<E>>) => Effect.Effect<X, E2, R2>\n  ): <A, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A, E | E2, R2 | R>\n  <A, E, R, X, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    f: (cause: Cause.Cause<E>) => Effect.Effect<X, E2, R2>\n  ): Stream.Stream<A, E | E2, R | R2>\n} = dual(\n  2,\n  <A, E, R, X, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    f: (cause: Cause.Cause<E>) => Effect.Effect<X, E2, R2>\n  ): Stream.Stream<A, E | E2, R | R2> => {\n    const loop: Channel.Channel<Chunk.Chunk<A>, Chunk.Chunk<A>, E | E2, E, unknown, unknown, R | R2> = core\n      .readWithCause({\n        onInput: (chunk) => core.flatMap(core.write(chunk), () => loop),\n        onFailure: (cause) => core.fromEffect(Effect.zipRight(f(cause), Effect.failCause(cause))),\n        onDone: core.succeedNow\n      })\n\n    return new StreamImpl(pipe(toChannel(self), core.pipeTo(loop)))\n  }\n)\n\n/** @internal */\nexport const tapSink = dual<\n  <A, E2, R2>(\n    sink: Sink.Sink<unknown, A, unknown, E2, R2>\n  ) => <E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A, E2 | E, R2 | R>,\n  <A, E, R, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    sink: Sink.Sink<unknown, A, unknown, E2, R2>\n  ) => Stream.Stream<A, E2 | E, R2 | R>\n>(\n  2,\n  <A, E, R, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    sink: Sink.Sink<unknown, A, unknown, E2, R2>\n  ): Stream.Stream<A, E | E2, R | R2> =>\n    pipe(\n      fromEffect(Effect.all([Queue.bounded<Take.Take<A, E | E2>>(1), Deferred.make<void>()])),\n      flatMap(([queue, deferred]) => {\n        const right = flattenTake(fromQueue(queue, { maxChunkSize: 1 }))\n        const loop: Channel.Channel<Chunk.Chunk<A>, Chunk.Chunk<A>, E | E2, E, unknown, unknown, R2> = core\n          .readWithCause({\n            onInput: (chunk: Chunk.Chunk<A>) =>\n              pipe(\n                core.fromEffect(Queue.offer(queue, InternalTake.chunk(chunk))),\n                core.foldCauseChannel({\n                  onFailure: () => core.flatMap(core.write(chunk), () => channel.identityChannel()),\n                  onSuccess: () => core.flatMap(core.write(chunk), () => loop)\n                })\n              ) as Channel.Channel<Chunk.Chunk<A>, Chunk.Chunk<A>, E | E2, E, unknown, unknown, R2>,\n            onFailure: (cause: Cause.Cause<E | E2>) =>\n              pipe(\n                core.fromEffect(Queue.offer(queue, InternalTake.failCause(cause))),\n                core.foldCauseChannel({\n                  onFailure: () => core.failCause(cause),\n                  onSuccess: () => core.failCause(cause)\n                })\n              ),\n            onDone: () =>\n              pipe(\n                core.fromEffect(Queue.offer(queue, InternalTake.end)),\n                core.foldCauseChannel({\n                  onFailure: () => core.void,\n                  onSuccess: () => core.void\n                })\n              )\n          })\n        return pipe(\n          new StreamImpl(pipe(\n            core.pipeTo(toChannel(self), loop),\n            channel.ensuring(Effect.zipRight(\n              Effect.forkDaemon(Queue.offer(queue, InternalTake.end)),\n              Deferred.await(deferred)\n            ))\n          )),\n          merge(\n            execute(pipe(\n              run(right, sink),\n              Effect.ensuring(Effect.zipRight(\n                Queue.shutdown(queue),\n                Deferred.succeed(deferred, void 0)\n              ))\n            ))\n          )\n        )\n      })\n    )\n)\n\n/** @internal */\nexport const throttle = dual<\n  <A>(\n    options: {\n      readonly cost: (chunk: Chunk.Chunk<A>) => number\n      readonly units: number\n      readonly duration: Duration.DurationInput\n      readonly burst?: number | undefined\n      readonly strategy?: \"enforce\" | \"shape\" | undefined\n    }\n  ) => <E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A, E, R>,\n  <A, E, R>(\n    self: Stream.Stream<A, E, R>,\n    options: {\n      readonly cost: (chunk: Chunk.Chunk<A>) => number\n      readonly units: number\n      readonly duration: Duration.DurationInput\n      readonly burst?: number | undefined\n      readonly strategy?: \"enforce\" | \"shape\" | undefined\n    }\n  ) => Stream.Stream<A, E, R>\n>(\n  2,\n  <A, E, R>(\n    self: Stream.Stream<A, E, R>,\n    options: {\n      readonly cost: (chunk: Chunk.Chunk<A>) => number\n      readonly units: number\n      readonly duration: Duration.DurationInput\n      readonly burst?: number | undefined\n      readonly strategy?: \"enforce\" | \"shape\" | undefined\n    }\n  ): Stream.Stream<A, E, R> =>\n    throttleEffect(self, {\n      ...options,\n      cost: (chunk) => Effect.succeed(options.cost(chunk))\n    })\n)\n\n/** @internal */\nexport const throttleEffect = dual<\n  <A, E2, R2>(\n    options: {\n      readonly cost: (chunk: Chunk.Chunk<A>) => Effect.Effect<number, E2, R2>\n      readonly units: number\n      readonly duration: Duration.DurationInput\n      readonly burst?: number | undefined\n      readonly strategy?: \"enforce\" | \"shape\" | undefined\n    }\n  ) => <E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A, E2 | E, R2 | R>,\n  <A, E, R, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    options: {\n      readonly cost: (chunk: Chunk.Chunk<A>) => Effect.Effect<number, E2, R2>\n      readonly units: number\n      readonly duration: Duration.DurationInput\n      readonly burst?: number | undefined\n      readonly strategy?: \"enforce\" | \"shape\" | undefined\n    }\n  ) => Stream.Stream<A, E2 | E, R2 | R>\n>(\n  2,\n  <A, E, R, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    options: {\n      readonly cost: (chunk: Chunk.Chunk<A>) => Effect.Effect<number, E2, R2>\n      readonly units: number\n      readonly duration: Duration.DurationInput\n      readonly burst?: number | undefined\n      readonly strategy?: \"enforce\" | \"shape\" | undefined\n    }\n  ): Stream.Stream<A, E | E2, R | R2> => {\n    if (options.strategy === \"enforce\") {\n      return throttleEnforceEffect(self, options.cost, options.units, options.duration, options.burst ?? 0)\n    }\n    return throttleShapeEffect(self, options.cost, options.units, options.duration, options.burst ?? 0)\n  }\n)\n\nconst throttleEnforceEffect = <A, E, R, E2, R2>(\n  self: Stream.Stream<A, E, R>,\n  cost: (chunk: Chunk.Chunk<A>) => Effect.Effect<number, E2, R2>,\n  units: number,\n  duration: Duration.DurationInput,\n  burst: number\n): Stream.Stream<A, E | E2, R | R2> => {\n  const loop = (\n    tokens: number,\n    timestampMillis: number\n  ): Channel.Channel<Chunk.Chunk<A>, Chunk.Chunk<A>, E | E2, E, void, unknown, R2> =>\n    core.readWithCause({\n      onInput: (input: Chunk.Chunk<A>) =>\n        pipe(\n          cost(input),\n          Effect.zip(Clock.currentTimeMillis),\n          Effect.map(([weight, currentTimeMillis]) => {\n            const elapsed = currentTimeMillis - timestampMillis\n            const cycles = elapsed / Duration.toMillis(duration)\n            const sum = tokens + (cycles * units)\n            const max = units + burst < 0 ? Number.POSITIVE_INFINITY : units + burst\n            const available = sum < 0 ? max : Math.min(sum, max)\n            if (weight <= available) {\n              return pipe(\n                core.write(input),\n                core.flatMap(() => loop(available - weight, currentTimeMillis))\n              )\n            }\n            return loop(tokens, timestampMillis)\n          }),\n          channel.unwrap\n        ),\n      onFailure: core.failCause,\n      onDone: () => core.void\n    })\n  const throttled = pipe(\n    Clock.currentTimeMillis,\n    Effect.map((currentTimeMillis) => loop(units, currentTimeMillis)),\n    channel.unwrap\n  )\n  return new StreamImpl(pipe(toChannel(self), channel.pipeToOrFail(throttled)))\n}\n\nconst throttleShapeEffect = <A, E, R, E2, R2>(\n  self: Stream.Stream<A, E, R>,\n  costFn: (chunk: Chunk.Chunk<A>) => Effect.Effect<number, E2, R2>,\n  units: number,\n  duration: Duration.DurationInput,\n  burst: number\n): Stream.Stream<A, E | E2, R | R2> => {\n  const loop = (\n    tokens: number,\n    timestampMillis: number\n  ): Channel.Channel<Chunk.Chunk<A>, Chunk.Chunk<A>, E | E2, E, void, unknown, R2> =>\n    core.readWithCause({\n      onInput: (input: Chunk.Chunk<A>) =>\n        pipe(\n          costFn(input),\n          Effect.zip(Clock.currentTimeMillis),\n          Effect.map(([weight, currentTimeMillis]) => {\n            const elapsed = currentTimeMillis - timestampMillis\n            const cycles = elapsed / Duration.toMillis(duration)\n            const sum = tokens + (cycles * units)\n            const max = units + burst < 0 ? Number.POSITIVE_INFINITY : units + burst\n            const available = sum < 0 ? max : Math.min(sum, max)\n            const remaining = available - weight\n            const waitCycles = remaining >= 0 ? 0 : -remaining / units\n            const delay = Duration.millis(Math.max(0, waitCycles * Duration.toMillis(duration)))\n            if (Duration.greaterThan(delay, Duration.zero)) {\n              return pipe(\n                core.fromEffect(Clock.sleep(delay)),\n                channel.zipRight(core.write(input)),\n                core.flatMap(() => loop(remaining, currentTimeMillis))\n              )\n            }\n            return core.flatMap(\n              core.write(input),\n              () => loop(remaining, currentTimeMillis)\n            )\n          }),\n          channel.unwrap\n        ),\n      onFailure: core.failCause,\n      onDone: () => core.void\n    })\n  const throttled = pipe(\n    Clock.currentTimeMillis,\n    Effect.map((currentTimeMillis) => loop(units, currentTimeMillis)),\n    channel.unwrap\n  )\n  return new StreamImpl(pipe(toChannel(self), channel.pipeToOrFail(throttled)))\n}\n\n/** @internal */\nexport const tick = (interval: Duration.DurationInput): Stream.Stream<void> =>\n  repeatWithSchedule(void 0, Schedule.spaced(interval))\n\n/** @internal */\nexport const timeout = dual<\n  (duration: Duration.DurationInput) => <A, E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A, E, R>,\n  <A, E, R>(self: Stream.Stream<A, E, R>, duration: Duration.DurationInput) => Stream.Stream<A, E, R>\n>(2, <A, E, R>(self: Stream.Stream<A, E, R>, duration: Duration.DurationInput): Stream.Stream<A, E, R> =>\n  pipe(\n    toPull(self),\n    Effect.map(Effect.timeoutFail<Option.Option<E>>({\n      onTimeout: () => Option.none(),\n      duration\n    })),\n    fromPull\n  ))\n\n/** @internal */\nexport const timeoutFail = dual<\n  <E2>(\n    error: LazyArg<E2>,\n    duration: Duration.DurationInput\n  ) => <A, E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A, E2 | E, R>,\n  <A, E, R, E2>(\n    self: Stream.Stream<A, E, R>,\n    error: LazyArg<E2>,\n    duration: Duration.DurationInput\n  ) => Stream.Stream<A, E2 | E, R>\n>(\n  3,\n  <A, E, R, E2>(\n    self: Stream.Stream<A, E, R>,\n    error: LazyArg<E2>,\n    duration: Duration.DurationInput\n  ): Stream.Stream<A, E | E2, R> => pipe(self, timeoutTo(duration, failSync(error)))\n)\n\n/** @internal */\nexport const timeoutFailCause = dual<\n  <E2>(\n    cause: LazyArg<Cause.Cause<E2>>,\n    duration: Duration.DurationInput\n  ) => <A, E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A, E2 | E, R>,\n  <A, E, R, E2>(\n    self: Stream.Stream<A, E, R>,\n    cause: LazyArg<Cause.Cause<E2>>,\n    duration: Duration.DurationInput\n  ) => Stream.Stream<A, E2 | E, R>\n>(\n  3,\n  <A, E, R, E2>(\n    self: Stream.Stream<A, E, R>,\n    cause: LazyArg<Cause.Cause<E2>>,\n    duration: Duration.DurationInput\n  ): Stream.Stream<A, E | E2, R> =>\n    pipe(\n      toPull(self),\n      Effect.map(\n        Effect.timeoutFailCause<Option.Option<E | E2>>({\n          onTimeout: () => Cause.map(cause(), Option.some),\n          duration\n        })\n      ),\n      fromPull\n    )\n)\n\n/** @internal */\nexport const timeoutTo = dual<\n  <A2, E2, R2>(\n    duration: Duration.DurationInput,\n    that: Stream.Stream<A2, E2, R2>\n  ) => <A, E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A2 | A, E2 | E, R2 | R>,\n  <A, E, R, A2, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    duration: Duration.DurationInput,\n    that: Stream.Stream<A2, E2, R2>\n  ) => Stream.Stream<A2 | A, E2 | E, R2 | R>\n>(\n  3,\n  <A, E, R, A2, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    duration: Duration.DurationInput,\n    that: Stream.Stream<A2, E2, R2>\n  ): Stream.Stream<A2 | A, E2 | E, R2 | R> => {\n    const StreamTimeout = new Cause.RuntimeException(\"Stream Timeout\")\n    return pipe(\n      self,\n      timeoutFailCause<E | E2>(() => Cause.die(StreamTimeout), duration),\n      catchSomeCause((cause) =>\n        Cause.isDieType(cause) &&\n          Cause.isRuntimeException(cause.defect) &&\n          cause.defect.message !== undefined &&\n          cause.defect.message === \"Stream Timeout\" ?\n          Option.some(that) :\n          Option.none()\n      )\n    )\n  }\n)\n\nconst pubsubFromOptions = <A, E>(\n  options: number | {\n    readonly capacity: \"unbounded\"\n    readonly replay?: number | undefined\n  } | {\n    readonly capacity: number\n    readonly strategy?: \"sliding\" | \"dropping\" | \"suspend\" | undefined\n    readonly replay?: number | undefined\n  }\n): Effect.Effect<PubSub.PubSub<Take.Take<A, E>>> => {\n  if (typeof options === \"number\") {\n    return PubSub.bounded(options)\n  } else if (options.capacity === \"unbounded\") {\n    return PubSub.unbounded({ replay: options.replay })\n  }\n  switch (options.strategy) {\n    case \"dropping\":\n      return PubSub.dropping(options)\n    case \"sliding\":\n      return PubSub.sliding(options)\n    default:\n      return PubSub.bounded(options)\n  }\n}\n\n/** @internal */\nexport const toPubSub = dual<\n  (\n    capacity: number | {\n      readonly capacity: \"unbounded\"\n      readonly replay?: number | undefined\n    } | {\n      readonly capacity: number\n      readonly strategy?: \"sliding\" | \"dropping\" | \"suspend\" | undefined\n      readonly replay?: number | undefined\n    }\n  ) => <A, E, R>(self: Stream.Stream<A, E, R>) => Effect.Effect<PubSub.PubSub<Take.Take<A, E>>, never, Scope.Scope | R>,\n  <A, E, R>(\n    self: Stream.Stream<A, E, R>,\n    capacity: number | {\n      readonly capacity: \"unbounded\"\n      readonly replay?: number | undefined\n    } | {\n      readonly capacity: number\n      readonly strategy?: \"sliding\" | \"dropping\" | \"suspend\" | undefined\n      readonly replay?: number | undefined\n    }\n  ) => Effect.Effect<PubSub.PubSub<Take.Take<A, E>>, never, Scope.Scope | R>\n>(2, <A, E, R>(\n  self: Stream.Stream<A, E, R>,\n  capacity: number | {\n    readonly capacity: \"unbounded\"\n    readonly replay?: number | undefined\n  } | {\n    readonly capacity: number\n    readonly strategy?: \"sliding\" | \"dropping\" | \"suspend\" | undefined\n    readonly replay?: number | undefined\n  }\n): Effect.Effect<PubSub.PubSub<Take.Take<A, E>>, never, Scope.Scope | R> =>\n  pipe(\n    Effect.acquireRelease(pubsubFromOptions<A, E>(capacity), (pubsub) => PubSub.shutdown(pubsub)),\n    Effect.tap((pubsub) => pipe(self, runIntoPubSubScoped(pubsub), Effect.forkScoped))\n  ))\n\n/** @internal */\nexport const toPull = <A, E, R>(\n  self: Stream.Stream<A, E, R>\n): Effect.Effect<Effect.Effect<Chunk.Chunk<A>, Option.Option<E>, R>, never, R | Scope.Scope> =>\n  Effect.map(channel.toPull(toChannel(self)), (pull) =>\n    pipe(\n      pull,\n      Effect.mapError(Option.some),\n      Effect.flatMap(Either.match({\n        onLeft: () => Effect.fail(Option.none()),\n        onRight: Effect.succeed\n      }))\n    ))\n\n/** @internal */\nexport const toQueue = dual<\n  (\n    options?: {\n      readonly strategy?: \"suspend\" | \"sliding\" | \"dropping\" | undefined\n      readonly capacity?: number | undefined\n    } | {\n      readonly strategy: \"unbounded\"\n    }\n  ) => <A, E, R>(\n    self: Stream.Stream<A, E, R>\n  ) => Effect.Effect<Queue.Dequeue<Take.Take<A, E>>, never, R | Scope.Scope>,\n  <A, E, R>(\n    self: Stream.Stream<A, E, R>,\n    options?: {\n      readonly strategy?: \"suspend\" | \"sliding\" | \"dropping\" | undefined\n      readonly capacity?: number | undefined\n    } | {\n      readonly strategy: \"unbounded\"\n    }\n  ) => Effect.Effect<Queue.Dequeue<Take.Take<A, E>>, never, R | Scope.Scope>\n>((args) => isStream(args[0]), <A, E, R>(\n  self: Stream.Stream<A, E, R>,\n  options?: {\n    readonly strategy?: \"suspend\" | \"sliding\" | \"dropping\" | undefined\n    readonly capacity?: number | undefined\n  } | {\n    readonly strategy: \"unbounded\"\n  }\n) =>\n  Effect.tap(\n    Effect.acquireRelease(\n      options?.strategy === \"unbounded\" ?\n        Queue.unbounded<Take.Take<A, E>>() :\n        options?.strategy === \"dropping\" ?\n        Queue.dropping<Take.Take<A, E>>(options.capacity ?? 2) :\n        options?.strategy === \"sliding\" ?\n        Queue.sliding<Take.Take<A, E>>(options.capacity ?? 2) :\n        Queue.bounded<Take.Take<A, E>>(options?.capacity ?? 2),\n      (queue) => Queue.shutdown(queue)\n    ),\n    (queue) => Effect.forkScoped(runIntoQueueScoped(self, queue))\n  ))\n\n/** @internal */\nexport const toQueueOfElements = dual<\n  (options?: {\n    readonly capacity?: number | undefined\n  }) => <A, E, R>(\n    self: Stream.Stream<A, E, R>\n  ) => Effect.Effect<Queue.Dequeue<Exit.Exit<A, Option.Option<E>>>, never, R | Scope.Scope>,\n  <A, E, R>(\n    self: Stream.Stream<A, E, R>,\n    options?: {\n      readonly capacity?: number | undefined\n    }\n  ) => Effect.Effect<Queue.Dequeue<Exit.Exit<A, Option.Option<E>>>, never, R | Scope.Scope>\n>((args) => isStream(args[0]), <A, E, R>(\n  self: Stream.Stream<A, E, R>,\n  options?: {\n    readonly capacity?: number | undefined\n  }\n) =>\n  Effect.tap(\n    Effect.acquireRelease(\n      Queue.bounded<Exit.Exit<A, Option.Option<E>>>(options?.capacity ?? 2),\n      (queue) => Queue.shutdown(queue)\n    ),\n    (queue) => Effect.forkScoped(runIntoQueueElementsScoped(self, queue))\n  ))\n\n/** @internal */\nexport const toReadableStream = dual<\n  <A>(\n    options?: { readonly strategy?: QueuingStrategy<A> | undefined }\n  ) => <E>(self: Stream.Stream<A, E>) => ReadableStream<A>,\n  <A, E>(\n    self: Stream.Stream<A, E>,\n    options?: { readonly strategy?: QueuingStrategy<A> | undefined }\n  ) => ReadableStream<A>\n>(\n  (args) => isStream(args[0]),\n  <A, E>(\n    self: Stream.Stream<A, E>,\n    options?: { readonly strategy?: QueuingStrategy<A> | undefined }\n  ) => toReadableStreamRuntime(self, Runtime.defaultRuntime, options)\n)\n\n/** @internal */\nexport const toReadableStreamEffect = dual<\n  <A>(\n    options?: { readonly strategy?: QueuingStrategy<A> | undefined }\n  ) => <E, R>(self: Stream.Stream<A, E, R>) => Effect.Effect<ReadableStream<A>, never, R>,\n  <A, E, R>(\n    self: Stream.Stream<A, E, R>,\n    options?: { readonly strategy?: QueuingStrategy<A> | undefined }\n  ) => Effect.Effect<ReadableStream<A>, never, R>\n>(\n  (args) => isStream(args[0]),\n  <A, E, R>(\n    self: Stream.Stream<A, E, R>,\n    options?: { readonly strategy?: QueuingStrategy<A> | undefined }\n  ) => Effect.map(Effect.runtime<R>(), (runtime) => toReadableStreamRuntime(self, runtime, options))\n)\n\n/** @internal */\nexport const toReadableStreamRuntime = dual<\n  <A, XR>(\n    runtime: Runtime.Runtime<XR>,\n    options?: { readonly strategy?: QueuingStrategy<A> | undefined }\n  ) => <E, R extends XR>(self: Stream.Stream<A, E, R>) => ReadableStream<A>,\n  <A, E, XR, R extends XR>(\n    self: Stream.Stream<A, E, R>,\n    runtime: Runtime.Runtime<XR>,\n    options?: { readonly strategy?: QueuingStrategy<A> | undefined }\n  ) => ReadableStream<A>\n>(\n  (args) => isStream(args[0]),\n  <A, E, XR, R extends XR>(\n    self: Stream.Stream<A, E, R>,\n    runtime: Runtime.Runtime<XR>,\n    options?: { readonly strategy?: QueuingStrategy<A> | undefined }\n  ): ReadableStream<A> => {\n    const runFork = Runtime.runFork(runtime)\n    let currentResolve: (() => void) | undefined = undefined\n    let fiber: Fiber.RuntimeFiber<void, E> | undefined = undefined\n    const latch = Effect.unsafeMakeLatch(false)\n\n    return new ReadableStream<A>({\n      start(controller) {\n        fiber = runFork(runForEachChunk(self, (chunk) => {\n          if (chunk.length === 0) return Effect.void\n          return latch.whenOpen(Effect.sync(() => {\n            latch.unsafeClose()\n            for (const item of chunk) {\n              controller.enqueue(item)\n            }\n            currentResolve!()\n            currentResolve = undefined\n          }))\n        }))\n        fiber.addObserver((exit) => {\n          try {\n            if (exit._tag === \"Failure\") {\n              controller.error(Cause.squash(exit.cause))\n            } else {\n              controller.close()\n            }\n          } catch {\n            // ignore\n          }\n        })\n      },\n      pull() {\n        return new Promise<void>((resolve) => {\n          currentResolve = resolve\n          Effect.runSync(latch.open)\n        })\n      },\n      cancel() {\n        if (!fiber) return\n        return Effect.runPromise(Effect.asVoid(Fiber.interrupt(fiber)))\n      }\n    }, options?.strategy)\n  }\n)\n\n/** @internal */\nexport const transduce = dual<\n  <A2, A, E2, R2>(\n    sink: Sink.Sink<A2, A, A, E2, R2>\n  ) => <E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A2, E2 | E, R2 | R>,\n  <A, E, R, A2, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    sink: Sink.Sink<A2, A, A, E2, R2>\n  ) => Stream.Stream<A2, E2 | E, R2 | R>\n>(\n  2,\n  <A, E, R, A2, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    sink: Sink.Sink<A2, A, A, E2, R2>\n  ): Stream.Stream<A2, E2 | E, R2 | R> => {\n    const newChannel = core.suspend(() => {\n      const leftovers = { ref: Chunk.empty<Chunk.Chunk<A>>() }\n      const upstreamDone = { ref: false }\n      const buffer: Channel.Channel<Chunk.Chunk<A>, Chunk.Chunk<A>, E, E, unknown, unknown> = core.suspend(\n        () => {\n          const leftover = leftovers.ref\n          if (Chunk.isEmpty(leftover)) {\n            return core.readWith({\n              onInput: (input) => pipe(core.write(input), core.flatMap(() => buffer)),\n              onFailure: core.fail,\n              onDone: core.succeedNow\n            })\n          }\n          leftovers.ref = Chunk.empty<Chunk.Chunk<A>>()\n          return pipe(channel.writeChunk(leftover), core.flatMap(() => buffer))\n        }\n      )\n      const concatAndGet = (chunk: Chunk.Chunk<Chunk.Chunk<A>>): Chunk.Chunk<Chunk.Chunk<A>> => {\n        const leftover = leftovers.ref\n        const concatenated = Chunk.appendAll(leftover, Chunk.filter(chunk, (chunk) => chunk.length !== 0))\n        leftovers.ref = concatenated\n        return concatenated\n      }\n      const upstreamMarker: Channel.Channel<Chunk.Chunk<A>, Chunk.Chunk<A>, E, E, unknown, unknown> = core\n        .readWith({\n          onInput: (input: Chunk.Chunk<A>) => core.flatMap(core.write(input), () => upstreamMarker),\n          onFailure: core.fail,\n          onDone: (done) =>\n            channel.zipRight(\n              core.sync(() => {\n                upstreamDone.ref = true\n              }),\n              core.succeedNow(done)\n            )\n        })\n      const transducer: Channel.Channel<Chunk.Chunk<A2>, Chunk.Chunk<A>, E | E2, never, void, unknown, R | R2> = pipe(\n        sink,\n        sink_.toChannel,\n        core.collectElements,\n        core.flatMap(([leftover, z]) =>\n          pipe(\n            core.succeed([upstreamDone.ref, concatAndGet(leftover)] as const),\n            core.flatMap(([done, newLeftovers]) => {\n              const nextChannel = done && Chunk.isEmpty(newLeftovers) ?\n                core.void :\n                transducer\n              return pipe(core.write(Chunk.of(z)), core.flatMap(() => nextChannel))\n            })\n          )\n        )\n      )\n      return pipe(\n        toChannel(self),\n        core.pipeTo(upstreamMarker),\n        core.pipeTo(buffer),\n        channel.pipeToOrFail(transducer)\n      )\n    })\n    return new StreamImpl(newChannel)\n  }\n)\n\n/** @internal */\nexport const toAsyncIterableRuntime = dual<\n  <A, XR>(\n    runtime: Runtime.Runtime<XR>\n  ) => <E, R extends XR>(self: Stream.Stream<A, E, R>) => AsyncIterable<A>,\n  <A, E, XR, R extends XR>(\n    self: Stream.Stream<A, E, R>,\n    runtime: Runtime.Runtime<XR>\n  ) => AsyncIterable<A>\n>(\n  (args) => isStream(args[0]),\n  <A, E, XR, R extends XR>(\n    self: Stream.Stream<A, E, R>,\n    runtime: Runtime.Runtime<XR>\n  ): AsyncIterable<A> => {\n    const runFork = Runtime.runFork(runtime)\n    return {\n      [Symbol.asyncIterator]() {\n        let currentResolve: ((value: IteratorResult<A>) => void) | undefined = undefined\n        let currentReject: ((reason: any) => void) | undefined = undefined\n        let fiber: Fiber.RuntimeFiber<void, E> | undefined = undefined\n        const latch = Effect.unsafeMakeLatch(false)\n        return {\n          next() {\n            if (!fiber) {\n              fiber = runFork(runForEach(self, (value) =>\n                latch.whenOpen(Effect.sync(() => {\n                  latch.unsafeClose()\n                  currentResolve!({ done: false, value })\n                  currentResolve = currentReject = undefined\n                }))))\n              fiber.addObserver((exit) => {\n                fiber = Effect.runFork(latch.whenOpen(Effect.sync(() => {\n                  if (exit._tag === \"Failure\") {\n                    currentReject!(Cause.squash(exit.cause))\n                  } else {\n                    currentResolve!({ done: true, value: void 0 })\n                  }\n                  currentResolve = currentReject = undefined\n                })))\n              })\n            }\n            return new Promise<IteratorResult<A>>((resolve, reject) => {\n              currentResolve = resolve\n              currentReject = reject\n              latch.unsafeOpen()\n            })\n          },\n          return() {\n            if (!fiber) return Promise.resolve({ done: true, value: void 0 })\n            return Effect.runPromise(Effect.as(Fiber.interrupt(fiber), { done: true, value: void 0 }))\n          }\n        }\n      }\n    }\n  }\n)\n\n/** @internal */\nexport const toAsyncIterable = <A, E>(self: Stream.Stream<A, E>): AsyncIterable<A> =>\n  toAsyncIterableRuntime(self, Runtime.defaultRuntime)\n\n/** @internal */\nexport const toAsyncIterableEffect = <A, E, R>(\n  self: Stream.Stream<A, E, R>\n): Effect.Effect<AsyncIterable<A>, never, R> =>\n  Effect.map(Effect.runtime<R>(), (runtime) => toAsyncIterableRuntime(self, runtime))\n\n/** @internal */\nexport const unfold = <S, A>(s: S, f: (s: S) => Option.Option<readonly [A, S]>): Stream.Stream<A> =>\n  unfoldChunk(s, (s) => pipe(f(s), Option.map(([a, s]) => [Chunk.of(a), s])))\n\n/** @internal */\nexport const unfoldChunk = <S, A>(\n  s: S,\n  f: (s: S) => Option.Option<readonly [Chunk.Chunk<A>, S]>\n): Stream.Stream<A> => {\n  const loop = (s: S): Channel.Channel<Chunk.Chunk<A>, unknown, never, unknown, unknown, unknown> =>\n    Option.match(f(s), {\n      onNone: () => core.void,\n      onSome: ([chunk, s]) => core.flatMap(core.write(chunk), () => loop(s))\n    })\n  return new StreamImpl(core.suspend(() => loop(s)))\n}\n\n/** @internal */\nexport const unfoldChunkEffect = <S, A, E, R>(\n  s: S,\n  f: (s: S) => Effect.Effect<Option.Option<readonly [Chunk.Chunk<A>, S]>, E, R>\n): Stream.Stream<A, E, R> =>\n  suspend(() => {\n    const loop = (s: S): Channel.Channel<Chunk.Chunk<A>, unknown, E, unknown, unknown, unknown, R> =>\n      channel.unwrap(\n        Effect.map(\n          f(s),\n          Option.match({\n            onNone: () => core.void,\n            onSome: ([chunk, s]) => core.flatMap(core.write(chunk), () => loop(s))\n          })\n        )\n      )\n    return new StreamImpl(loop(s))\n  })\n\n/** @internal */\nexport const unfoldEffect = <S, A, E, R>(\n  s: S,\n  f: (s: S) => Effect.Effect<Option.Option<readonly [A, S]>, E, R>\n): Stream.Stream<A, E, R> =>\n  unfoldChunkEffect(s, (s) => pipe(f(s), Effect.map(Option.map(([a, s]) => [Chunk.of(a), s]))))\n\nconst void_: Stream.Stream<void> = succeed(void 0)\nexport {\n  /** @internal */\n  void_ as void\n}\n\n/** @internal */\nexport const unwrap = <A, E2, R2, E, R>(\n  effect: Effect.Effect<Stream.Stream<A, E2, R2>, E, R>\n): Stream.Stream<A, E | E2, R | R2> => flatten(fromEffect(effect))\n\n/** @internal */\nexport const unwrapScoped = <A, E2, R2, E, R>(\n  effect: Effect.Effect<Stream.Stream<A, E2, R2>, E, R>\n): Stream.Stream<A, E | E2, Exclude<R, Scope.Scope> | R2> => flatten(scoped(effect))\n\n/** @internal */\nexport const unwrapScopedWith = <A, E2, R2, E, R>(\n  f: (scope: Scope.Scope) => Effect.Effect<Stream.Stream<A, E2, R2>, E, R>\n): Stream.Stream<A, E | E2, R | R2> => flatten(scopedWith((scope) => f(scope)))\n\n/** @internal */\nexport const updateService = dual<\n  <I, S>(\n    tag: Context.Tag<I, S>,\n    f: (service: Types.NoInfer<S>) => Types.NoInfer<S>\n  ) => <A, E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A, E, I | R>,\n  <A, E, R, I, S>(\n    self: Stream.Stream<A, E, R>,\n    tag: Context.Tag<I, S>,\n    f: (service: Types.NoInfer<S>) => Types.NoInfer<S>\n  ) => Stream.Stream<A, E, I | R>\n>(\n  3,\n  <A, E, R, I, S>(\n    self: Stream.Stream<A, E, R>,\n    tag: Context.Tag<I, S>,\n    f: (service: Types.NoInfer<S>) => Types.NoInfer<S>\n  ): Stream.Stream<A, E, I | R> =>\n    pipe(\n      self,\n      mapInputContext((context) =>\n        pipe(\n          context,\n          Context.add(tag, f(pipe(context, Context.unsafeGet(tag))))\n        )\n      )\n    )\n)\n\n/** @internal */\nexport const when = dual<\n  (test: LazyArg<boolean>) => <A, E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A, E, R>,\n  <A, E, R>(self: Stream.Stream<A, E, R>, test: LazyArg<boolean>) => Stream.Stream<A, E, R>\n>(\n  2,\n  <A, E, R>(self: Stream.Stream<A, E, R>, test: LazyArg<boolean>): Stream.Stream<A, E, R> =>\n    pipe(self, whenEffect(Effect.sync(test)))\n)\n\n/** @internal */\nexport const whenCase = <A, A2, E, R>(\n  evaluate: LazyArg<A>,\n  pf: (a: A) => Option.Option<Stream.Stream<A2, E, R>>\n) => whenCaseEffect(pf)(Effect.sync(evaluate))\n\n/** @internal */\nexport const whenCaseEffect = dual<\n  <A, A2, E2, R2>(\n    pf: (a: A) => Option.Option<Stream.Stream<A2, E2, R2>>\n  ) => <E, R>(self: Effect.Effect<A, E, R>) => Stream.Stream<A2, E2 | E, R2 | R>,\n  <A, E, R, A2, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    pf: (a: A) => Option.Option<Stream.Stream<A2, E2, R2>>\n  ) => Stream.Stream<A2, E2 | E, R2 | R>\n>(\n  2,\n  <A, E, R, A2, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    pf: (a: A) => Option.Option<Stream.Stream<A2, E2, R2>>\n  ): Stream.Stream<A2, E | E2, R | R2> =>\n    pipe(\n      fromEffect(self),\n      flatMap((a) => pipe(pf(a), Option.getOrElse(() => empty)))\n    )\n)\n\n/** @internal */\nexport const whenEffect = dual<\n  <E2, R2>(\n    effect: Effect.Effect<boolean, E2, R2>\n  ) => <A, E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A, E2 | E, R2 | R>,\n  <A, E, R, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    effect: Effect.Effect<boolean, E2, R2>\n  ) => Stream.Stream<A, E2 | E, R2 | R>\n>(\n  2,\n  <A, E, R, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    effect: Effect.Effect<boolean, E2, R2>\n  ): Stream.Stream<A, E | E2, R | R2> => pipe(fromEffect(effect), flatMap((bool) => bool ? self : empty))\n)\n\n/** @internal */\nexport const withSpan: {\n  (\n    name: string,\n    options?: Tracer.SpanOptions\n  ): <A, E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A, E, Exclude<R, Tracer.ParentSpan>>\n  <A, E, R>(\n    self: Stream.Stream<A, E, R>,\n    name: string,\n    options?: Tracer.SpanOptions\n  ): Stream.Stream<A, E, Exclude<R, Tracer.ParentSpan>>\n} = function() {\n  const dataFirst = typeof arguments[0] !== \"string\"\n  const name = dataFirst ? arguments[1] : arguments[0]\n  const options = InternalTracer.addSpanStackTrace(dataFirst ? arguments[2] : arguments[1])\n  if (dataFirst) {\n    const self = arguments[0]\n    return new StreamImpl(channel.withSpan(toChannel(self), name, options))\n  }\n  return (self: Stream.Stream<any, any, any>) => new StreamImpl(channel.withSpan(toChannel(self), name, options))\n} as any\n\n/** @internal */\nexport const zip = dual<\n  <A2, E2, R2>(\n    that: Stream.Stream<A2, E2, R2>\n  ) => <A, E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<[A, A2], E2 | E, R2 | R>,\n  <A, E, R, A2, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    that: Stream.Stream<A2, E2, R2>\n  ) => Stream.Stream<[A, A2], E2 | E, R2 | R>\n>(\n  2,\n  <A, E, R, A2, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    that: Stream.Stream<A2, E2, R2>\n  ): Stream.Stream<[A, A2], E2 | E, R2 | R> => pipe(self, zipWith(that, (a, a2) => [a, a2]))\n)\n\n/** @internal */\nexport const zipFlatten = dual<\n  <A2, E2, R2>(\n    that: Stream.Stream<A2, E2, R2>\n  ) => <A extends ReadonlyArray<any>, E, R>(\n    self: Stream.Stream<A, E, R>\n  ) => Stream.Stream<[...A, A2], E2 | E, R2 | R>,\n  <A extends ReadonlyArray<any>, E, R, A2, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    that: Stream.Stream<A2, E2, R2>\n  ) => Stream.Stream<[...A, A2], E2 | E, R2 | R>\n>(\n  2,\n  <A extends ReadonlyArray<any>, E, R, A2, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    that: Stream.Stream<A2, E2, R2>\n  ): Stream.Stream<[...A, A2], E2 | E, R2 | R> => pipe(self, zipWith(that, (a, a2) => [...a, a2]))\n)\n\n/** @internal */\nexport const zipAll = dual<\n  <A2, E2, R2, A>(\n    options: {\n      readonly other: Stream.Stream<A2, E2, R2>\n      readonly defaultSelf: A\n      readonly defaultOther: A2\n    }\n  ) => <E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<[A, A2], E2 | E, R2 | R>,\n  <A, E, R, A2, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    options: {\n      readonly other: Stream.Stream<A2, E2, R2>\n      readonly defaultSelf: A\n      readonly defaultOther: A2\n    }\n  ) => Stream.Stream<[A, A2], E2 | E, R2 | R>\n>(\n  2,\n  <A, E, R, A2, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    options: {\n      readonly other: Stream.Stream<A2, E2, R2>\n      readonly defaultSelf: A\n      readonly defaultOther: A2\n    }\n  ): Stream.Stream<[A, A2], E2 | E, R2 | R> =>\n    zipAllWith(self, {\n      other: options.other,\n      onSelf: (a) => [a, options.defaultOther],\n      onOther: (a2) => [options.defaultSelf, a2],\n      onBoth: (a, a2) => [a, a2]\n    })\n)\n\n/** @internal */\nexport const zipAllLeft = dual<\n  <A2, E2, R2, A>(\n    that: Stream.Stream<A2, E2, R2>,\n    defaultLeft: A\n  ) => <E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A, E2 | E, R2 | R>,\n  <A, E, R, A2, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    that: Stream.Stream<A2, E2, R2>,\n    defaultLeft: A\n  ) => Stream.Stream<A, E2 | E, R2 | R>\n>(\n  3,\n  <A, E, R, A2, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    other: Stream.Stream<A2, E2, R2>,\n    defaultSelf: A\n  ): Stream.Stream<A, E | E2, R | R2> =>\n    zipAllWith(self, {\n      other,\n      onSelf: identity,\n      onOther: () => defaultSelf,\n      onBoth: (a) => a\n    })\n)\n\n/** @internal */\nexport const zipAllRight = dual<\n  <A2, E2, R2>(\n    that: Stream.Stream<A2, E2, R2>,\n    defaultRight: A2\n  ) => <A, E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A2, E2 | E, R2 | R>,\n  <A, E, R, A2, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    that: Stream.Stream<A2, E2, R2>,\n    defaultRight: A2\n  ) => Stream.Stream<A2, E2 | E, R2 | R>\n>(\n  3,\n  <A, E, R, A2, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    other: Stream.Stream<A2, E2, R2>,\n    defaultRight: A2\n  ): Stream.Stream<A2, E | E2, R | R2> =>\n    zipAllWith(self, {\n      other,\n      onSelf: () => defaultRight,\n      onOther: identity,\n      onBoth: (_, a2) => a2\n    })\n)\n\n/** @internal */\nexport const zipAllSortedByKey = dual<\n  <A2, E2, R2, A, K>(\n    options: {\n      readonly other: Stream.Stream<readonly [K, A2], E2, R2>\n      readonly defaultSelf: A\n      readonly defaultOther: A2\n      readonly order: Order.Order<K>\n    }\n  ) => <E, R>(\n    self: Stream.Stream<readonly [K, A], E, R>\n  ) => Stream.Stream<[K, [A, A2]], E2 | E, R2 | R>,\n  <K, A, E, R, A2, E2, R2>(\n    self: Stream.Stream<readonly [K, A], E, R>,\n    options: {\n      readonly other: Stream.Stream<readonly [K, A2], E2, R2>\n      readonly defaultSelf: A\n      readonly defaultOther: A2\n      readonly order: Order.Order<K>\n    }\n  ) => Stream.Stream<[K, [A, A2]], E2 | E, R2 | R>\n>(\n  2,\n  <K, A, E, R, A2, E2, R2>(\n    self: Stream.Stream<readonly [K, A], E, R>,\n    options: {\n      readonly other: Stream.Stream<readonly [K, A2], E2, R2>\n      readonly defaultSelf: A\n      readonly defaultOther: A2\n      readonly order: Order.Order<K>\n    }\n  ): Stream.Stream<[K, [A, A2]], E2 | E, R2 | R> =>\n    zipAllSortedByKeyWith(self, {\n      other: options.other,\n      onSelf: (a) => [a, options.defaultOther],\n      onOther: (a2) => [options.defaultSelf, a2],\n      onBoth: (a, a2) => [a, a2],\n      order: options.order\n    })\n)\n\n/** @internal */\nexport const zipAllSortedByKeyLeft = dual<\n  <A2, E2, R2, A, K>(\n    options: {\n      readonly other: Stream.Stream<readonly [K, A2], E2, R2>\n      readonly defaultSelf: A\n      readonly order: Order.Order<K>\n    }\n  ) => <E, R>(self: Stream.Stream<readonly [K, A], E, R>) => Stream.Stream<[K, A], E2 | E, R2 | R>,\n  <K, A, E, R, A2, E2, R2>(\n    self: Stream.Stream<readonly [K, A], E, R>,\n    options: {\n      readonly other: Stream.Stream<readonly [K, A2], E2, R2>\n      readonly defaultSelf: A\n      readonly order: Order.Order<K>\n    }\n  ) => Stream.Stream<[K, A], E2 | E, R2 | R>\n>(\n  2,\n  <K, A, E, R, A2, E2, R2>(\n    self: Stream.Stream<readonly [K, A], E, R>,\n    options: {\n      readonly other: Stream.Stream<readonly [K, A2], E2, R2>\n      readonly defaultSelf: A\n      readonly order: Order.Order<K>\n    }\n  ): Stream.Stream<[K, A], E2 | E, R2 | R> =>\n    zipAllSortedByKeyWith(self, {\n      other: options.other,\n      onSelf: identity,\n      onOther: () => options.defaultSelf,\n      onBoth: (a) => a,\n      order: options.order\n    })\n)\n\n/** @internal */\nexport const zipAllSortedByKeyRight = dual<\n  <K, A2, E2, R2>(\n    options: {\n      readonly other: Stream.Stream<readonly [K, A2], E2, R2>\n      readonly defaultOther: A2\n      readonly order: Order.Order<K>\n    }\n  ) => <A, E, R>(self: Stream.Stream<readonly [K, A], E, R>) => Stream.Stream<[K, A2], E2 | E, R2 | R>,\n  <A, E, R, K, A2, E2, R2>(\n    self: Stream.Stream<readonly [K, A], E, R>,\n    options: {\n      readonly other: Stream.Stream<readonly [K, A2], E2, R2>\n      readonly defaultOther: A2\n      readonly order: Order.Order<K>\n    }\n  ) => Stream.Stream<[K, A2], E2 | E, R2 | R>\n>(\n  2,\n  <A, E, R, K, A2, E2, R2>(\n    self: Stream.Stream<readonly [K, A], E, R>,\n    options: {\n      readonly other: Stream.Stream<readonly [K, A2], E2, R2>\n      readonly defaultOther: A2\n      readonly order: Order.Order<K>\n    }\n  ): Stream.Stream<[K, A2], E2 | E, R2 | R> =>\n    zipAllSortedByKeyWith(self, {\n      other: options.other,\n      onSelf: () => options.defaultOther,\n      onOther: identity,\n      onBoth: (_, a2) => a2,\n      order: options.order\n    })\n)\n\n/** @internal */\nexport const zipAllSortedByKeyWith = dual<\n  <K, A2, E2, R2, A, A3>(\n    options: {\n      readonly other: Stream.Stream<readonly [K, A2], E2, R2>\n      readonly onSelf: (a: A) => A3\n      readonly onOther: (a2: A2) => A3\n      readonly onBoth: (a: A, a2: A2) => A3\n      readonly order: Order.Order<K>\n    }\n  ) => <E, R>(self: Stream.Stream<readonly [K, A], E, R>) => Stream.Stream<[K, A3], E2 | E, R2 | R>,\n  <K, A, E, R, A2, E2, R2, A3>(\n    self: Stream.Stream<readonly [K, A], E, R>,\n    options: {\n      readonly other: Stream.Stream<readonly [K, A2], E2, R2>\n      readonly onSelf: (a: A) => A3\n      readonly onOther: (a2: A2) => A3\n      readonly onBoth: (a: A, a2: A2) => A3\n      readonly order: Order.Order<K>\n    }\n  ) => Stream.Stream<[K, A3], E2 | E, R2 | R>\n>(\n  2,\n  <K, A, E, R, A2, E2, R2, A3>(\n    self: Stream.Stream<readonly [K, A], E, R>,\n    options: {\n      readonly other: Stream.Stream<readonly [K, A2], E2, R2>\n      readonly onSelf: (a: A) => A3\n      readonly onOther: (a2: A2) => A3\n      readonly onBoth: (a: A, a2: A2) => A3\n      readonly order: Order.Order<K>\n    }\n  ): Stream.Stream<[K, A3], E2 | E, R2 | R> => {\n    const pull = (\n      state: ZipAllState.ZipAllState<readonly [K, A], readonly [K, A2]>,\n      pullLeft: Effect.Effect<Chunk.Chunk<readonly [K, A]>, Option.Option<E>, R>,\n      pullRight: Effect.Effect<Chunk.Chunk<readonly [K, A2]>, Option.Option<E2>, R2>\n    ): Effect.Effect<\n      Exit.Exit<\n        readonly [\n          Chunk.Chunk<[K, A3]>,\n          ZipAllState.ZipAllState<readonly [K, A], readonly [K, A2]>\n        ],\n        Option.Option<E | E2>\n      >,\n      never,\n      R | R2\n    > => {\n      switch (state._tag) {\n        case ZipAllState.OP_DRAIN_LEFT: {\n          return pipe(\n            pullLeft,\n            Effect.match({\n              onFailure: Exit.fail,\n              onSuccess: (leftChunk) =>\n                Exit.succeed(\n                  [\n                    Chunk.map(leftChunk, ([k, a]) => [k, options.onSelf(a)]),\n                    ZipAllState.DrainLeft\n                  ] as const\n                )\n            })\n          )\n        }\n        case ZipAllState.OP_DRAIN_RIGHT: {\n          return pipe(\n            pullRight,\n            Effect.match({\n              onFailure: Exit.fail,\n              onSuccess: (rightChunk) =>\n                Exit.succeed(\n                  [\n                    Chunk.map(rightChunk, ([k, a2]) => [k, options.onOther(a2)]),\n                    ZipAllState.DrainRight\n                  ] as const\n                )\n            })\n          )\n        }\n        case ZipAllState.OP_PULL_BOTH: {\n          return pipe(\n            unsome(pullLeft),\n            Effect.zip(unsome(pullRight), { concurrent: true }),\n            Effect.matchEffect({\n              onFailure: (error) => Effect.succeed(Exit.fail(Option.some(error))),\n              onSuccess: ([leftOption, rightOption]) => {\n                if (Option.isSome(leftOption) && Option.isSome(rightOption)) {\n                  if (Chunk.isEmpty(leftOption.value) && Chunk.isEmpty(rightOption.value)) {\n                    return pull(ZipAllState.PullBoth, pullLeft, pullRight)\n                  }\n                  if (Chunk.isEmpty(leftOption.value)) {\n                    return pull(ZipAllState.PullLeft(rightOption.value), pullLeft, pullRight)\n                  }\n                  if (Chunk.isEmpty(rightOption.value)) {\n                    return pull(ZipAllState.PullRight(leftOption.value), pullLeft, pullRight)\n                  }\n                  return Effect.succeed(Exit.succeed(merge(leftOption.value, rightOption.value)))\n                }\n                if (Option.isSome(leftOption) && Option.isNone(rightOption)) {\n                  if (Chunk.isEmpty(leftOption.value)) {\n                    return pull(ZipAllState.DrainLeft, pullLeft, pullRight)\n                  }\n                  return Effect.succeed(\n                    Exit.succeed(\n                      [\n                        pipe(leftOption.value, Chunk.map(([k, a]) => [k, options.onSelf(a)])),\n                        ZipAllState.DrainLeft\n                      ] as const\n                    )\n                  )\n                }\n                if (Option.isNone(leftOption) && Option.isSome(rightOption)) {\n                  if (Chunk.isEmpty(rightOption.value)) {\n                    return pull(ZipAllState.DrainRight, pullLeft, pullRight)\n                  }\n                  return Effect.succeed(\n                    Exit.succeed(\n                      [\n                        pipe(rightOption.value, Chunk.map(([k, a2]) => [k, options.onOther(a2)])),\n                        ZipAllState.DrainRight\n                      ] as const\n                    )\n                  )\n                }\n                return Effect.succeed(Exit.fail<Option.Option<E | E2>>(Option.none()))\n              }\n            })\n          )\n        }\n        case ZipAllState.OP_PULL_LEFT: {\n          return Effect.matchEffect(pullLeft, {\n            onFailure: Option.match({\n              onNone: () =>\n                Effect.succeed(\n                  Exit.succeed([\n                    pipe(state.rightChunk, Chunk.map(([k, a2]) => [k, options.onOther(a2)])),\n                    ZipAllState.DrainRight\n                  ])\n                ),\n              onSome: (error) =>\n                Effect.succeed<\n                  Exit.Exit<\n                    readonly [\n                      Chunk.Chunk<[K, A3]>,\n                      ZipAllState.ZipAllState<readonly [K, A], readonly [K, A2]>\n                    ],\n                    Option.Option<E | E2>\n                  >\n                >(Exit.fail(Option.some(error)))\n            }),\n            onSuccess: (leftChunk) =>\n              Chunk.isEmpty(leftChunk) ?\n                pull(ZipAllState.PullLeft(state.rightChunk), pullLeft, pullRight) :\n                Effect.succeed(Exit.succeed(merge(leftChunk, state.rightChunk)))\n          })\n        }\n        case ZipAllState.OP_PULL_RIGHT: {\n          return Effect.matchEffect(pullRight, {\n            onFailure: Option.match({\n              onNone: () =>\n                Effect.succeed(\n                  Exit.succeed(\n                    [\n                      Chunk.map(state.leftChunk, ([k, a]) => [k, options.onSelf(a)]),\n                      ZipAllState.DrainLeft\n                    ] as const\n                  )\n                ),\n              onSome: (error) =>\n                Effect.succeed<\n                  Exit.Exit<\n                    readonly [\n                      Chunk.Chunk<[K, A3]>,\n                      ZipAllState.ZipAllState<readonly [K, A], readonly [K, A2]>\n                    ],\n                    Option.Option<E | E2>\n                  >\n                >(Exit.fail(Option.some(error)))\n            }),\n            onSuccess: (rightChunk) =>\n              Chunk.isEmpty(rightChunk) ?\n                pull(ZipAllState.PullRight(state.leftChunk), pullLeft, pullRight) :\n                Effect.succeed(Exit.succeed(merge(state.leftChunk, rightChunk)))\n          })\n        }\n      }\n    }\n    const merge = (\n      leftChunk: Chunk.Chunk<readonly [K, A]>,\n      rightChunk: Chunk.Chunk<readonly [K, A2]>\n    ): readonly [\n      Chunk.Chunk<[K, A3]>,\n      ZipAllState.ZipAllState<readonly [K, A], readonly [K, A2]>\n    ] => {\n      const hasNext = <T>(chunk: Chunk.Chunk<T>, index: number) => index < chunk.length - 1\n      const builder: Array<[K, A3]> = []\n      let state:\n        | ZipAllState.ZipAllState<\n          readonly [K, A],\n          readonly [K, A2]\n        >\n        | undefined = undefined\n      let leftIndex = 0\n      let rightIndex = 0\n      let leftTuple = pipe(leftChunk, Chunk.unsafeGet(leftIndex))\n      let rightTuple = pipe(rightChunk, Chunk.unsafeGet(rightIndex))\n      let k1 = leftTuple[0]\n      let a = leftTuple[1]\n      let k2 = rightTuple[0]\n      let a2 = rightTuple[1]\n      let loop = true\n      while (loop) {\n        const compare = options.order(k1, k2)\n        if (compare === 0) {\n          builder.push([k1, options.onBoth(a, a2)])\n          if (hasNext(leftChunk, leftIndex) && hasNext(rightChunk, rightIndex)) {\n            leftIndex = leftIndex + 1\n            rightIndex = rightIndex + 1\n            leftTuple = pipe(leftChunk, Chunk.unsafeGet(leftIndex))\n            rightTuple = pipe(rightChunk, Chunk.unsafeGet(rightIndex))\n            k1 = leftTuple[0]\n            a = leftTuple[1]\n            k2 = rightTuple[0]\n            a2 = rightTuple[1]\n          } else if (hasNext(leftChunk, leftIndex)) {\n            state = ZipAllState.PullRight(pipe(leftChunk, Chunk.drop(leftIndex + 1)))\n            loop = false\n          } else if (hasNext(rightChunk, rightIndex)) {\n            state = ZipAllState.PullLeft(pipe(rightChunk, Chunk.drop(rightIndex + 1)))\n            loop = false\n          } else {\n            state = ZipAllState.PullBoth\n            loop = false\n          }\n        } else if (compare < 0) {\n          builder.push([k1, options.onSelf(a)])\n          if (hasNext(leftChunk, leftIndex)) {\n            leftIndex = leftIndex + 1\n            leftTuple = pipe(leftChunk, Chunk.unsafeGet(leftIndex))\n            k1 = leftTuple[0]\n            a = leftTuple[1]\n          } else {\n            const rightBuilder: Array<readonly [K, A2]> = []\n            rightBuilder.push(rightTuple)\n            while (hasNext(rightChunk, rightIndex)) {\n              rightIndex = rightIndex + 1\n              rightTuple = pipe(rightChunk, Chunk.unsafeGet(rightIndex))\n              rightBuilder.push(rightTuple)\n            }\n            state = ZipAllState.PullLeft(Chunk.unsafeFromArray(rightBuilder))\n            loop = false\n          }\n        } else {\n          builder.push([k2, options.onOther(a2)])\n          if (hasNext(rightChunk, rightIndex)) {\n            rightIndex = rightIndex + 1\n            rightTuple = pipe(rightChunk, Chunk.unsafeGet(rightIndex))\n            k2 = rightTuple[0]\n            a2 = rightTuple[1]\n          } else {\n            const leftBuilder: Array<readonly [K, A]> = []\n            leftBuilder.push(leftTuple)\n            while (hasNext(leftChunk, leftIndex)) {\n              leftIndex = leftIndex + 1\n              leftTuple = pipe(leftChunk, Chunk.unsafeGet(leftIndex))\n              leftBuilder.push(leftTuple)\n            }\n            state = ZipAllState.PullRight(Chunk.unsafeFromArray(leftBuilder))\n            loop = false\n          }\n        }\n      }\n      return [Chunk.unsafeFromArray(builder), state!]\n    }\n    return combineChunks(self, options.other, ZipAllState.PullBoth, pull)\n  }\n)\n\n/** @internal */\nexport const zipAllWith = dual<\n  <A2, E2, R2, A, A3>(\n    options: {\n      readonly other: Stream.Stream<A2, E2, R2>\n      readonly onSelf: (a: A) => A3\n      readonly onOther: (a2: A2) => A3\n      readonly onBoth: (a: A, a2: A2) => A3\n    }\n  ) => <E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A3, E2 | E, R2 | R>,\n  <A, E, R, A2, E2, R2, A3>(\n    self: Stream.Stream<A, E, R>,\n    options: {\n      readonly other: Stream.Stream<A2, E2, R2>\n      readonly onSelf: (a: A) => A3\n      readonly onOther: (a2: A2) => A3\n      readonly onBoth: (a: A, a2: A2) => A3\n    }\n  ) => Stream.Stream<A3, E2 | E, R2 | R>\n>(\n  2,\n  <A, E, R, A2, E2, R2, A3>(\n    self: Stream.Stream<A, E, R>,\n    options: {\n      readonly other: Stream.Stream<A2, E2, R2>\n      readonly onSelf: (a: A) => A3\n      readonly onOther: (a2: A2) => A3\n      readonly onBoth: (a: A, a2: A2) => A3\n    }\n  ): Stream.Stream<A3, E2 | E, R2 | R> => {\n    const pull = (\n      state: ZipAllState.ZipAllState<A, A2>,\n      pullLeft: Effect.Effect<Chunk.Chunk<A>, Option.Option<E>, R>,\n      pullRight: Effect.Effect<Chunk.Chunk<A2>, Option.Option<E2>, R2>\n    ): Effect.Effect<\n      Exit.Exit<readonly [Chunk.Chunk<A3>, ZipAllState.ZipAllState<A, A2>], Option.Option<E | E2>>,\n      never,\n      R | R2\n    > => {\n      switch (state._tag) {\n        case ZipAllState.OP_DRAIN_LEFT: {\n          return Effect.matchEffect(pullLeft, {\n            onFailure: (error) => Effect.succeed(Exit.fail(error)),\n            onSuccess: (leftChunk) =>\n              Effect.succeed(Exit.succeed(\n                [\n                  Chunk.map(leftChunk, options.onSelf),\n                  ZipAllState.DrainLeft\n                ] as const\n              ))\n          })\n        }\n        case ZipAllState.OP_DRAIN_RIGHT: {\n          return Effect.matchEffect(pullRight, {\n            onFailure: (error) => Effect.succeed(Exit.fail(error)),\n            onSuccess: (rightChunk) =>\n              Effect.succeed(Exit.succeed(\n                [\n                  Chunk.map(rightChunk, options.onOther),\n                  ZipAllState.DrainRight\n                ] as const\n              ))\n          })\n        }\n        case ZipAllState.OP_PULL_BOTH: {\n          return pipe(\n            unsome(pullLeft),\n            Effect.zip(unsome(pullRight), { concurrent: true }),\n            Effect.matchEffect({\n              onFailure: (error) => Effect.succeed(Exit.fail(Option.some(error))),\n              onSuccess: ([leftOption, rightOption]) => {\n                if (Option.isSome(leftOption) && Option.isSome(rightOption)) {\n                  if (Chunk.isEmpty(leftOption.value) && Chunk.isEmpty(rightOption.value)) {\n                    return pull(ZipAllState.PullBoth, pullLeft, pullRight)\n                  }\n                  if (Chunk.isEmpty(leftOption.value)) {\n                    return pull(ZipAllState.PullLeft(rightOption.value), pullLeft, pullRight)\n                  }\n                  if (Chunk.isEmpty(rightOption.value)) {\n                    return pull(ZipAllState.PullRight(leftOption.value), pullLeft, pullRight)\n                  }\n                  return Effect.succeed(Exit.succeed(zip(leftOption.value, rightOption.value, options.onBoth)))\n                }\n                if (Option.isSome(leftOption) && Option.isNone(rightOption)) {\n                  return Effect.succeed(Exit.succeed(\n                    [\n                      Chunk.map(leftOption.value, options.onSelf),\n                      ZipAllState.DrainLeft\n                    ] as const\n                  ))\n                }\n                if (Option.isNone(leftOption) && Option.isSome(rightOption)) {\n                  return Effect.succeed(Exit.succeed(\n                    [\n                      Chunk.map(rightOption.value, options.onOther),\n                      ZipAllState.DrainRight\n                    ] as const\n                  ))\n                }\n                return Effect.succeed(Exit.fail<Option.Option<E | E2>>(Option.none()))\n              }\n            })\n          )\n        }\n        case ZipAllState.OP_PULL_LEFT: {\n          return Effect.matchEffect(pullLeft, {\n            onFailure: Option.match({\n              onNone: () =>\n                Effect.succeed(Exit.succeed(\n                  [\n                    Chunk.map(state.rightChunk, options.onOther),\n                    ZipAllState.DrainRight\n                  ] as const\n                )),\n              onSome: (error) =>\n                Effect.succeed<\n                  Exit.Exit<readonly [Chunk.Chunk<A3>, ZipAllState.ZipAllState<A, A2>], Option.Option<E | E2>>\n                >(\n                  Exit.fail(Option.some(error))\n                )\n            }),\n            onSuccess: (leftChunk) => {\n              if (Chunk.isEmpty(leftChunk)) {\n                return pull(ZipAllState.PullLeft(state.rightChunk), pullLeft, pullRight)\n              }\n              if (Chunk.isEmpty(state.rightChunk)) {\n                return pull(ZipAllState.PullRight(leftChunk), pullLeft, pullRight)\n              }\n              return Effect.succeed(Exit.succeed(zip(leftChunk, state.rightChunk, options.onBoth)))\n            }\n          })\n        }\n        case ZipAllState.OP_PULL_RIGHT: {\n          return Effect.matchEffect(pullRight, {\n            onFailure: Option.match({\n              onNone: () =>\n                Effect.succeed(\n                  Exit.succeed(\n                    [\n                      Chunk.map(state.leftChunk, options.onSelf),\n                      ZipAllState.DrainLeft\n                    ] as const\n                  )\n                ),\n              onSome: (error) =>\n                Effect.succeed<\n                  Exit.Exit<readonly [Chunk.Chunk<A3>, ZipAllState.ZipAllState<A, A2>], Option.Option<E | E2>>\n                >(\n                  Exit.fail(Option.some(error))\n                )\n            }),\n            onSuccess: (rightChunk) => {\n              if (Chunk.isEmpty(rightChunk)) {\n                return pull(\n                  ZipAllState.PullRight(state.leftChunk),\n                  pullLeft,\n                  pullRight\n                )\n              }\n              if (Chunk.isEmpty(state.leftChunk)) {\n                return pull(\n                  ZipAllState.PullLeft(rightChunk),\n                  pullLeft,\n                  pullRight\n                )\n              }\n              return Effect.succeed(Exit.succeed(zip(state.leftChunk, rightChunk, options.onBoth)))\n            }\n          })\n        }\n      }\n    }\n    const zip = (\n      leftChunk: Chunk.Chunk<A>,\n      rightChunk: Chunk.Chunk<A2>,\n      f: (a: A, a2: A2) => A3\n    ): readonly [Chunk.Chunk<A3>, ZipAllState.ZipAllState<A, A2>] => {\n      const [output, either] = zipChunks(leftChunk, rightChunk, f)\n      switch (either._tag) {\n        case \"Left\": {\n          if (Chunk.isEmpty(either.left)) {\n            return [output, ZipAllState.PullBoth] as const\n          }\n          return [output, ZipAllState.PullRight(either.left)] as const\n        }\n        case \"Right\": {\n          if (Chunk.isEmpty(either.right)) {\n            return [output, ZipAllState.PullBoth] as const\n          }\n          return [output, ZipAllState.PullLeft(either.right)] as const\n        }\n      }\n    }\n    return combineChunks(self, options.other, ZipAllState.PullBoth, pull)\n  }\n)\n\n/** @internal */\nexport const zipLatest: {\n  <AR, ER, RR>(\n    right: Stream.Stream<AR, ER, RR>\n  ): <AL, EL, RL>(left: Stream.Stream<AL, EL, RL>) => Stream.Stream<[AL, AR], EL | ER, RL | RR>\n  <AL, EL, RL, AR, ER, RR>(\n    left: Stream.Stream<AL, EL, RL>,\n    right: Stream.Stream<AR, ER, RR>\n  ): Stream.Stream<[AL, AR], EL | ER, RL | RR>\n} = dual(\n  2,\n  <AL, EL, RL, AR, ER, RR>(\n    left: Stream.Stream<AL, EL, RL>,\n    right: Stream.Stream<AR, ER, RR>\n  ): Stream.Stream<[AL, AR], EL | ER, RL | RR> => pipe(left, zipLatestWith(right, (a, a2) => [a, a2]))\n)\n\nexport const zipLatestAll = <T extends ReadonlyArray<Stream.Stream<any, any, any>>>(\n  ...streams: T\n): Stream.Stream<\n  [T[number]] extends [never] ? never\n    : { [K in keyof T]: T[K] extends Stream.Stream<infer A, infer _E, infer _R> ? A : never },\n  [T[number]] extends [never] ? never : T[number] extends Stream.Stream<infer _A, infer _E, infer _R> ? _E : never,\n  [T[number]] extends [never] ? never : T[number] extends Stream.Stream<infer _A, infer _E, infer _R> ? _R : never\n> => {\n  if (streams.length === 0) {\n    return empty\n  } else if (streams.length === 1) {\n    return map(streams[0]!, (x) => [x]) as any\n  }\n  const [head, ...tail] = streams\n  return zipLatestWith(\n    head,\n    zipLatestAll(...tail),\n    (first, second) => [first, ...second]\n  ) as any\n}\n\n/** @internal */\nexport const zipLatestWith: {\n  <AR, ER, RR, AL, A>(\n    right: Stream.Stream<AR, ER, RR>,\n    f: (left: AL, right: AR) => A\n  ): <EL, RL>(left: Stream.Stream<AL, EL, RL>) => Stream.Stream<A, EL | ER, RL | RR>\n  <AL, EL, RL, AR, ER, RR, A>(\n    left: Stream.Stream<AL, EL, RL>,\n    right: Stream.Stream<AR, ER, RR>,\n    f: (left: AL, right: AR) => A\n  ): Stream.Stream<A, EL | ER, RL | RR>\n} = dual(\n  3,\n  <AL, EL, RL, AR, ER, RR, A>(\n    left: Stream.Stream<AL, EL, RL>,\n    right: Stream.Stream<AR, ER, RR>,\n    f: (left: AL, right: AR) => A\n  ): Stream.Stream<A, EL | ER, RL | RR> => {\n    const pullNonEmpty = <_R, _E, _A>(\n      pull: Effect.Effect<Chunk.Chunk<_A>, Option.Option<_E>, _R>\n    ): Effect.Effect<Chunk.Chunk<_A>, Option.Option<_E>, _R> =>\n      pipe(pull, Effect.flatMap((chunk) => Chunk.isEmpty(chunk) ? pullNonEmpty(pull) : Effect.succeed(chunk)))\n    return pipe(\n      toPull(left),\n      Effect.map(pullNonEmpty),\n      Effect.zip(pipe(toPull(right), Effect.map(pullNonEmpty))),\n      Effect.flatMap(([left, right]) =>\n        pipe(\n          fromEffectOption<readonly [Chunk.Chunk<AL>, Chunk.Chunk<AR>, boolean], EL | ER, RL | RR>(\n            Effect.raceWith(left, right, {\n              onSelfDone: (leftDone, rightFiber) =>\n                pipe(\n                  Effect.suspend(() => leftDone),\n                  Effect.zipWith(Fiber.join(rightFiber), (l, r) => [l, r, true] as const)\n                ),\n              onOtherDone: (rightDone, leftFiber) =>\n                pipe(\n                  Effect.suspend(() => rightDone),\n                  Effect.zipWith(Fiber.join(leftFiber), (l, r) => [r, l, false] as const)\n                )\n            })\n          ),\n          flatMap(([l, r, leftFirst]) =>\n            pipe(\n              fromEffect(\n                Ref.make([Chunk.unsafeLast(l), Chunk.unsafeLast(r)] as const)\n              ),\n              flatMap((latest) =>\n                pipe(\n                  fromChunk(\n                    leftFirst ?\n                      pipe(r, Chunk.map((a2) => f(Chunk.unsafeLast(l), a2))) :\n                      pipe(l, Chunk.map((a) => f(a, Chunk.unsafeLast(r))))\n                  ),\n                  concat(\n                    pipe(\n                      repeatEffectOption(left),\n                      mergeEither(repeatEffectOption(right)),\n                      mapEffectSequential(Either.match({\n                        onLeft: (leftChunk) =>\n                          pipe(\n                            Ref.modify(latest, ([_, rightLatest]) =>\n                              [\n                                pipe(leftChunk, Chunk.map((a) => f(a, rightLatest))),\n                                [Chunk.unsafeLast(leftChunk), rightLatest] as const\n                              ] as const)\n                          ),\n                        onRight: (rightChunk) =>\n                          pipe(\n                            Ref.modify(latest, ([leftLatest, _]) =>\n                              [\n                                pipe(rightChunk, Chunk.map((a2) => f(leftLatest, a2))),\n                                [leftLatest, Chunk.unsafeLast(rightChunk)] as const\n                              ] as const)\n                          )\n                      })),\n                      flatMap(fromChunk)\n                    )\n                  )\n                )\n              )\n            )\n          ),\n          toPull\n        )\n      ),\n      fromPull\n    )\n  }\n)\n\n/** @internal */\nexport const zipLeft: {\n  <AR, ER, RR>(\n    right: Stream.Stream<AR, ER, RR>\n  ): <AL, EL, RL>(left: Stream.Stream<AL, EL, RL>) => Stream.Stream<AL, ER | EL, RR | RL>\n  <AL, EL, RL, AR, ER, RR>(\n    left: Stream.Stream<AL, EL, RL>,\n    right: Stream.Stream<AR, ER, RR>\n  ): Stream.Stream<AL, EL | ER, RL | RR>\n} = dual(\n  2,\n  <AL, EL, RL, AR, ER, RR>(\n    left: Stream.Stream<AL, EL, RL>,\n    right: Stream.Stream<AR, ER, RR>\n  ): Stream.Stream<AL, EL | ER, RL | RR> =>\n    pipe(\n      left,\n      zipWithChunks(right, (left, right) => {\n        if (left.length > right.length) {\n          return [\n            pipe(left, Chunk.take(right.length)),\n            Either.left(pipe(left, Chunk.take(right.length)))\n          ] as const\n        }\n        return [\n          left,\n          Either.right(pipe(right, Chunk.drop(left.length)))\n        ]\n      })\n    )\n)\n\n/** @internal */\nexport const zipRight: {\n  <AR, ER, RR>(\n    right: Stream.Stream<AR, ER, RR>\n  ): <AL, EL, RL>(left: Stream.Stream<AL, EL, RL>) => Stream.Stream<AR, ER | EL, RR | RL>\n  <AL, EL, RL, AR, ER, RR>(\n    left: Stream.Stream<AL, EL, RL>,\n    right: Stream.Stream<AR, ER, RR>\n  ): Stream.Stream<AR, EL | ER, RL | RR>\n} = dual(\n  2,\n  <AL, EL, RL, AR, ER, RR>(\n    left: Stream.Stream<AL, EL, RL>,\n    right: Stream.Stream<AR, ER, RR>\n  ): Stream.Stream<AR, EL | ER, RL | RR> =>\n    pipe(\n      left,\n      zipWithChunks(right, (left, right) => {\n        if (left.length > right.length) {\n          return [\n            right,\n            Either.left(pipe(left, Chunk.take(right.length)))\n          ] as const\n        }\n        return [\n          pipe(right, Chunk.take(left.length)),\n          Either.right(pipe(right, Chunk.drop(left.length)))\n        ]\n      })\n    )\n)\n\n/** @internal */\nexport const zipWith: {\n  <AR, ER, RR, AL, A>(\n    right: Stream.Stream<AR, ER, RR>,\n    f: (left: AL, right: AR) => A\n  ): <EL, RL>(left: Stream.Stream<AL, EL, RL>) => Stream.Stream<A, EL | ER, RL | RR>\n  <AL, EL, RL, AR, ER, RR, A>(\n    left: Stream.Stream<AL, EL, RL>,\n    right: Stream.Stream<AR, ER, RR>,\n    f: (left: AL, right: AR) => A\n  ): Stream.Stream<A, EL | ER, RL | RR>\n} = dual(\n  3,\n  <AL, EL, RL, AR, ER, RR, A>(\n    left: Stream.Stream<AL, EL, RL>,\n    right: Stream.Stream<AR, ER, RR>,\n    f: (left: AL, right: AR) => A\n  ): Stream.Stream<A, EL | ER, RL | RR> =>\n    pipe(left, zipWithChunks(right, (leftChunk, rightChunk) => zipChunks(leftChunk, rightChunk, f)))\n)\n\n/** @internal */\nexport const zipWithChunks = dual<\n  <A2, E2, R2, A, A3>(\n    that: Stream.Stream<A2, E2, R2>,\n    f: (\n      left: Chunk.Chunk<A>,\n      right: Chunk.Chunk<A2>\n    ) => readonly [Chunk.Chunk<A3>, Either.Either<Chunk.Chunk<A2>, Chunk.Chunk<A>>]\n  ) => <E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<A3, E2 | E, R2 | R>,\n  <A, E, R, A2, E2, R2, A3>(\n    self: Stream.Stream<A, E, R>,\n    that: Stream.Stream<A2, E2, R2>,\n    f: (\n      left: Chunk.Chunk<A>,\n      right: Chunk.Chunk<A2>\n    ) => readonly [Chunk.Chunk<A3>, Either.Either<Chunk.Chunk<A2>, Chunk.Chunk<A>>]\n  ) => Stream.Stream<A3, E2 | E, R2 | R>\n>(3, <A, E, R, A2, E2, R2, A3>(\n  self: Stream.Stream<A, E, R>,\n  that: Stream.Stream<A2, E2, R2>,\n  f: (\n    left: Chunk.Chunk<A>,\n    right: Chunk.Chunk<A2>\n  ) => readonly [Chunk.Chunk<A3>, Either.Either<Chunk.Chunk<A2>, Chunk.Chunk<A>>]\n): Stream.Stream<A3, E2 | E, R2 | R> => {\n  const pull = (\n    state: ZipChunksState.ZipChunksState<A, A2>,\n    pullLeft: Effect.Effect<Chunk.Chunk<A>, Option.Option<E>, R>,\n    pullRight: Effect.Effect<Chunk.Chunk<A2>, Option.Option<E2>, R2>\n  ): Effect.Effect<\n    Exit.Exit<readonly [Chunk.Chunk<A3>, ZipChunksState.ZipChunksState<A, A2>], Option.Option<E | E2>>,\n    never,\n    R | R2\n  > => {\n    switch (state._tag) {\n      case ZipChunksState.OP_PULL_BOTH: {\n        return pipe(\n          unsome(pullLeft),\n          Effect.zip(unsome(pullRight), { concurrent: true }),\n          Effect.matchEffect({\n            onFailure: (error) => Effect.succeed(Exit.fail(Option.some(error))),\n            onSuccess: ([leftOption, rightOption]) => {\n              if (Option.isSome(leftOption) && Option.isSome(rightOption)) {\n                if (Chunk.isEmpty(leftOption.value) && Chunk.isEmpty(rightOption.value)) {\n                  return pull(ZipChunksState.PullBoth, pullLeft, pullRight)\n                }\n                if (Chunk.isEmpty(leftOption.value)) {\n                  return pull(ZipChunksState.PullLeft(rightOption.value), pullLeft, pullRight)\n                }\n                if (Chunk.isEmpty(rightOption.value)) {\n                  return pull(ZipChunksState.PullRight(leftOption.value), pullLeft, pullRight)\n                }\n                return Effect.succeed(Exit.succeed(zip(leftOption.value, rightOption.value)))\n              }\n              return Effect.succeed(Exit.fail(Option.none()))\n            }\n          })\n        )\n      }\n      case ZipChunksState.OP_PULL_LEFT: {\n        return Effect.matchEffect(pullLeft, {\n          onFailure: (error) => Effect.succeed(Exit.fail(error)),\n          onSuccess: (leftChunk) => {\n            if (Chunk.isEmpty(leftChunk)) {\n              return pull(ZipChunksState.PullLeft(state.rightChunk), pullLeft, pullRight)\n            }\n            if (Chunk.isEmpty(state.rightChunk)) {\n              return pull(ZipChunksState.PullRight(leftChunk), pullLeft, pullRight)\n            }\n            return Effect.succeed(Exit.succeed(zip(leftChunk, state.rightChunk)))\n          }\n        })\n      }\n      case ZipChunksState.OP_PULL_RIGHT: {\n        return Effect.matchEffect(pullRight, {\n          onFailure: (error) => Effect.succeed(Exit.fail(error)),\n          onSuccess: (rightChunk) => {\n            if (Chunk.isEmpty(rightChunk)) {\n              return pull(ZipChunksState.PullRight(state.leftChunk), pullLeft, pullRight)\n            }\n            if (Chunk.isEmpty(state.leftChunk)) {\n              return pull(ZipChunksState.PullLeft(rightChunk), pullLeft, pullRight)\n            }\n            return Effect.succeed(Exit.succeed(zip(state.leftChunk, rightChunk)))\n          }\n        })\n      }\n    }\n  }\n  const zip = (\n    leftChunk: Chunk.Chunk<A>,\n    rightChunk: Chunk.Chunk<A2>\n  ): readonly [Chunk.Chunk<A3>, ZipChunksState.ZipChunksState<A, A2>] => {\n    const [output, either] = f(leftChunk, rightChunk)\n    switch (either._tag) {\n      case \"Left\": {\n        if (Chunk.isEmpty(either.left)) {\n          return [output, ZipChunksState.PullBoth] as const\n        }\n        return [output, ZipChunksState.PullRight(either.left)] as const\n      }\n      case \"Right\": {\n        if (Chunk.isEmpty(either.right)) {\n          return [output, ZipChunksState.PullBoth] as const\n        }\n        return [output, ZipChunksState.PullLeft(either.right)] as const\n      }\n    }\n  }\n  return pipe(\n    self,\n    combineChunks(that, ZipChunksState.PullBoth, pull)\n  )\n})\n\n/** @internal */\nexport const zipWithIndex = <A, E, R>(self: Stream.Stream<A, E, R>): Stream.Stream<[A, number], E, R> =>\n  pipe(self, mapAccum(0, (index, a) => [index + 1, [a, index]]))\n\n/** @internal */\nexport const zipWithNext = <A, E, R>(\n  self: Stream.Stream<A, E, R>\n): Stream.Stream<[A, Option.Option<A>], E, R> => {\n  const process = (\n    last: Option.Option<A>\n  ): Channel.Channel<Chunk.Chunk<readonly [A, Option.Option<A>]>, Chunk.Chunk<A>, never, never, void, unknown> =>\n    core.readWithCause({\n      onInput: (input: Chunk.Chunk<A>) => {\n        const [newLast, chunk] = Chunk.mapAccum(\n          input,\n          last,\n          (prev, curr) => [Option.some(curr), pipe(prev, Option.map((a) => [a, curr] as const))] as const\n        )\n        const output = Chunk.filterMap(\n          chunk,\n          (option) =>\n            Option.isSome(option) ?\n              Option.some([option.value[0], Option.some(option.value[1])] as const) :\n              Option.none()\n        )\n        return core.flatMap(\n          core.write(output),\n          () => process(newLast)\n        )\n      },\n      onFailure: core.failCause,\n      onDone: () =>\n        Option.match(last, {\n          onNone: () => core.void,\n          onSome: (value) =>\n            channel.zipRight(\n              core.write(Chunk.of<readonly [A, Option.Option<A>]>([value, Option.none()])),\n              core.void\n            )\n        })\n    })\n  return new StreamImpl(pipe(toChannel(self), channel.pipeToOrFail(process(Option.none()))))\n}\n\n/** @internal */\nexport const zipWithPrevious = <A, E, R>(\n  self: Stream.Stream<A, E, R>\n): Stream.Stream<[Option.Option<A>, A], E, R> =>\n  pipe(\n    self,\n    mapAccum<Option.Option<A>, A, [Option.Option<A>, A]>(\n      Option.none(),\n      (prev, curr) => [Option.some(curr), [prev, curr]]\n    )\n  )\n\n/** @internal */\nexport const zipWithPreviousAndNext = <A, E, R>(\n  self: Stream.Stream<A, E, R>\n): Stream.Stream<[Option.Option<A>, A, Option.Option<A>], E, R> =>\n  pipe(\n    zipWithNext(zipWithPrevious(self)),\n    map(([[prev, curr], next]) => [prev, curr, pipe(next, Option.map((tuple) => tuple[1]))])\n  )\n\n/** @internal */\nconst zipChunks = <A, B, C>(\n  left: Chunk.Chunk<A>,\n  right: Chunk.Chunk<B>,\n  f: (a: A, b: B) => C\n): [Chunk.Chunk<C>, Either.Either<Chunk.Chunk<B>, Chunk.Chunk<A>>] => {\n  if (left.length > right.length) {\n    return [\n      pipe(left, Chunk.take(right.length), Chunk.zipWith(right, f)),\n      Either.left(pipe(left, Chunk.drop(right.length)))\n    ]\n  }\n  return [\n    pipe(left, Chunk.zipWith(pipe(right, Chunk.take(left.length)), f)),\n    Either.right(pipe(right, Chunk.drop(left.length)))\n  ]\n}\n\n// Do notation\n\n/** @internal */\nexport const Do: Stream.Stream<{}> = succeed({})\n\n/** @internal */\nexport const bind = dual<\n  <N extends string, A, B, E2, R2>(\n    tag: Exclude<N, keyof A>,\n    f: (_: Types.NoInfer<A>) => Stream.Stream<B, E2, R2>,\n    options?: {\n      readonly concurrency?: number | \"unbounded\" | undefined\n      readonly bufferSize?: number | undefined\n    }\n  ) => <E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<\n    { [K in keyof A | N]: K extends keyof A ? A[K] : B },\n    E | E2,\n    R | R2\n  >,\n  <A, E, R, N extends string, B, E2, R2>(\n    self: Stream.Stream<A, E, R>,\n    tag: Exclude<N, keyof A>,\n    f: (_: Types.NoInfer<A>) => Stream.Stream<B, E2, R2>,\n    options?: {\n      readonly concurrency?: number | \"unbounded\" | undefined\n      readonly bufferSize?: number | undefined\n    }\n  ) => Stream.Stream<\n    { [K in keyof A | N]: K extends keyof A ? A[K] : B },\n    E | E2,\n    R | R2\n  >\n>((args) => typeof args[0] !== \"string\", <A, E, R, N extends string, B, E2, R2>(\n  self: Stream.Stream<A, E, R>,\n  tag: Exclude<N, keyof A>,\n  f: (_: A) => Stream.Stream<B, E2, R2>,\n  options?: {\n    readonly concurrency?: number | \"unbounded\" | undefined\n    readonly bufferSize?: number | undefined\n  }\n) =>\n  flatMap(self, (k) =>\n    map(\n      f(k),\n      (a) => ({ ...k, [tag]: a } as { [K in keyof A | N]: K extends keyof A ? A[K] : B })\n    ), options))\n\n/* @internal */\nexport const bindTo: {\n  <N extends string>(name: N): <A, E, R>(self: Stream.Stream<A, E, R>) => Stream.Stream<{ [K in N]: A }, E, R>\n  <A, E, R, N extends string>(self: Stream.Stream<A, E, R>, name: N): Stream.Stream<{ [K in N]: A }, E, R>\n} = doNotation.bindTo<Stream.StreamTypeLambda>(map)\n\n/* @internal */\nexport const let_: {\n  <N extends string, A extends object, B>(\n    name: Exclude<N, keyof A>,\n    f: (a: Types.NoInfer<A>) => B\n  ): <E, R>(\n    self: Stream.Stream<A, E, R>\n  ) => Stream.Stream<{ [K in N | keyof A]: K extends keyof A ? A[K] : B }, E, R>\n  <A extends object, E, R, N extends string, B>(\n    self: Stream.Stream<A, E, R>,\n    name: Exclude<N, keyof A>,\n    f: (a: Types.NoInfer<A>) => B\n  ): Stream.Stream<{ [K in N | keyof A]: K extends keyof A ? A[K] : B }, E, R>\n} = doNotation.let_<Stream.StreamTypeLambda>(map)\n\n// Circular with Channel\n\n/** @internal */\nexport const channelToStream = <OutElem, OutErr, OutDone, Env>(\n  self: Channel.Channel<Chunk.Chunk<OutElem>, unknown, OutErr, unknown, OutDone, unknown, Env>\n): Stream.Stream<OutElem, OutErr, Env> => {\n  return new StreamImpl(self)\n}\n\n// =============================================================================\n// encoding\n// =============================================================================\n\n/** @internal */\nexport const decodeText = dual<\n  (encoding?: string) => <E, R>(self: Stream.Stream<Uint8Array, E, R>) => Stream.Stream<string, E, R>,\n  <E, R>(self: Stream.Stream<Uint8Array, E, R>, encoding?: string) => Stream.Stream<string, E, R>\n>((args) => isStream(args[0]), (self, encoding = \"utf-8\") =>\n  suspend(() => {\n    const decoder = new TextDecoder(encoding)\n    return map(self, (s) => decoder.decode(s))\n  }))\n\n/** @internal */\nexport const encodeText = <E, R>(self: Stream.Stream<string, E, R>): Stream.Stream<Uint8Array, E, R> =>\n  suspend(() => {\n    const encoder = new TextEncoder()\n    return map(self, (s) => encoder.encode(s))\n  })\n\n/** @internal */\nexport const fromEventListener = <A = unknown>(\n  target: Stream.EventListener<A>,\n  type: string,\n  options?: boolean | {\n    readonly capture?: boolean\n    readonly passive?: boolean\n    readonly once?: boolean\n    readonly bufferSize?: number | \"unbounded\" | undefined\n  } | undefined\n): Stream.Stream<A> =>\n  asyncPush<A>((emit) =>\n    Effect.acquireRelease(\n      Effect.sync(() => target.addEventListener(type, emit.single as any, options)),\n      () => Effect.sync(() => target.removeEventListener(type, emit.single, options))\n    ), { bufferSize: typeof options === \"object\" ? options.bufferSize : undefined })\n"],"names":["Cause","Chunk","Clock","Context","Deferred","Duration","Effect","Either","Equal","Exit","Fiber","FiberRef","constTrue","dual","identity","pipe","internalExecutionPlan","Layer","MergeDecision","Option","pipeArguments","hasProperty","PubSub","Queue","RcRef","Ref","Runtime","Schedule","HaltStrategy","TPubSub","TQueue","Tuple","channel","channelExecutor","MergeStrategy","core","doNotation","RingBuffer","InternalSchedule","sink_","DebounceState","emit","haltStrategy","Handoff","HandoffSignal","pull","SinkEndReason","ZipAllState","ZipChunksState","InternalTake","InternalTracer","StreamSymbolKey","StreamTypeId","Symbol","for","streamVariance","_R","_","_E","_A","StreamImpl","constructor","arguments","isStream","u","isEffect","DefaultChunkSize","accumulate","self","chunks","accumulateChunks","accumulator","s","readWith","onInput","input","next","appendAll","flatMap","write","onFailure","fail","onDone","void","pipeTo","toChannel","empty","acquireRelease","acquire","release","scoped","aggregate","sink","aggregateWithin","forever","schedule","filterMap","aggregateWithinEither","match","onLeft","none","onRight","some","layer","all","make","ScheduleEnd","driver","fromEffect","handoff","sinkEndReason","sinkLeftovers","scheduleDriver","consumed","endAfterEmit","handoffProducer","readWithCause","offer","when","isNonEmpty","cause","halt","end","UpstreamEnd","handoffConsumer","getAndSet","leftovers","set","zipRight","succeed","take","map","signal","_tag","OP_EMIT","elements","get","bool","OP_HALT","failCause","OP_END","reason","OP_SCHEDULE_END","unwrap","timeout","lastB","scheduledAggregator","sinkFiber","scheduleFiber","scope","forkSink","pipeToOrFail","collectElements","run","forkIn","handleSide","b","c","flatten","wasConsumed","toWrite","onNone","of","right","onSome","left","OP_UPSTREAM_END","raceWith","join","onSelfDone","sinkExit","interrupt","suspend","onOtherDone","scheduleExit","matchCauseEffect","failureOrCause","forkDaemon","onSuccess","unwrapScopedWith","as","value","queueFromBufferOptions","bufferSize","unbounded","undefined","bounded","strategy","dropping","sliding","_async","register","queue","shutdown","output","runtime","sync","runPromiseExit","canceler","resume","fromPull","asVoid","then","exit","isFailure","isInterrupted","squash","loop","done","maybeError","error","chunk","fromChannel","ensuring","unwrapScoped","asyncEffect","k","queueFromBufferOptionsPush","options","asyncPush","tap","getWith","currentScheduler","scheduler","makePush","item","isExit","isSuccess","unsafeFromArray","asyncScoped","ref","isDone","onError","repeatEffectChunkOption","branchAfter","n","f","buffering","acc","nextSize","length","b1","b2","splitAt","running","prefix","leftover","identityChannel","broadcast","maximumLag","broadcastedQueues","tuple","flattenTake","fromQueue","broadcastDynamic","toPubSub","pubsub","fromPubSub","share","idleTimeToLive","rcRef","pubsubFromOptions","Array","from","subscribe","forkScoped","runIntoPubSubScoped","broadcastedQueuesDynamic","buffer","capacity","bufferUnbounded","bufferDropping","bufferSliding","toQueueOfElements","process","flipCauseOption","bufferChunks","bufferChunksDropping","bufferChunksSliding","toQueue","onEnd","bufferSignal","rechunk","bufferChannel","producer","terminate","await","deferred","added","consumer","start","runScoped","catchAll","catchAllCause","catchSome","pf","getOrElse","catchSomeCause","catchTag","e","catchTags","cases","keys","Object","includes","changes","changesWith","x","y","equals","writer","last","newLast","newChunk","reduce","option","outputs","isSome","append","changesWithEffect","mapChunks","chunksWith","flattenChunks","unsome","effect","asSome","o","succeedNone","combine","that","latch","latchL","concatMap","writeChunk","runIn","rightL","latchR","pullLeft","pullRight","unfoldEffect","combineChunks","__","unfoldChunkEffect","concat","concatAll","streams","cross","crossWith","a","a2","crossLeft","crossRight","debounce","duration","gen","enqueue","sleep","fiber","previous","elem","state","OP_NOT_STARTED","OP_PREVIOUS","handoffFiber","leftExit","current","rightExit","OP_CURRENT","scopedWith","notStarted","die","defect","dieSync","evaluate","dieMessage","message","distributedWith","distributedWithDynamic","decide","range","size","id","key","entries","mappings","queues","reduceRight","Map","mapping","prepend","distributedWithDynamicId","newDistributedWithDynamicId","distributedWithDynamicCallback","values","forEach","queuesRef","shouldProcess","ids","update","delete","queuesLock","makeSemaphore","newQueue","finalize","endTake","withPermits","fromIterable","runForEachScoped","drain","drainFork","backgroundDied","interruptWhenDeferred","drop","r","dropped","Math","max","more","isEmpty","dropRight","identityStream","reader","head","put","dropUntil","predicate","dropWhile","dropUntilEffect","succeedNow","dropWhileEffect","either","finalizer","ensuringWith","context","contextWith","contextWithEffect","mapEffectSequential","contextWithStream","execute","fromEffectOption","failSync","failCauseSync","filter","filterEffect","iterator","filterMapEffect","filterMapWhile","mapped","filterMapWhileEffect","find","findFirst","findEffect","args","switch","matchConcurrency","concurrency","flatMapParSwitchBuffer","mergeMap","out","sequential","Number","MAX_SAFE_INTEGER","mergeStrategy","BufferSliding","flattenEffect","unordered","mapOutEffectPar","mapOut","flattenExitOption","processChunk","cont","toEmit","rest","splitWhere","flattenIterables","repeated","fromAsyncIterable","iterable","asyncIterator","return","promise","repeatEffectOption","tryPromise","try","catch","result","stream","TypeError","fromChunk","fromChunkPubSub","fromChunkQueue","isShutdown","fromChunks","mapError","maxChunkSize","fromTPubSub","subscribeScoped","fromTQueue","isChunk","fromIteratorSucceed","fromIterableEffect","builder","count","push","takeBetween","fromSchedule","fromReadableStream","releaseLockOnEnd","getReader","releaseLock","cancel","read","fromReadableStreamByob","allocSize","mode","readChunkStreamByobReader","EOF","ArrayBuffer","paginateEffect","offset","Uint8Array","byteLength","newOffset","groupAdjacentBy","groupAdjacentByChunk","until","previousChunk","unsafeGet","updatedKey","additionalChunk","slice","group","nonEmptyChunk","groupAdjacent","updatedState","grouped","chunkSize","groupedWithin","collectAllN","spaced","haltWhen","poll","haltAfter","haltWhenDeferred","interleave","interleaveWith","decider","zip","leftDone","rightDone","intersperse","element","isFirst","flagResult","intersperseAffixes","middle","interruptAfter","interruptWhen","iterate","unfold","mapAccum","nextS","mapAccumEffect","mapBoth","mapChunksEffect","mapOutEffect","mapConcat","mapConcatChunk","mapConcatChunkEffect","mapConcatEffect","mapEffectPar","mapErrorCause","merge","mergeWith","onSelf","onOther","mergeAll","mergeWithTag","mergeEither","mergeLeft","mergeRight","other","fromInput","Both","handler","Done","Await","mkString","never","cleanup","onStart","orDie","orDieWith","orElse","orElseEither","orElseFail","orElseIfEmpty","orElseIfEmptyChunk","orElseIfEmptyStream","orElseSucceed","paginate","paginateChunk","page","paginateChunkEffect","peel","foldSink","collectLeftover","z","tapErrorCause","partition","partitionEither","queue1","queue2","pipeThrough","pipeThroughChannel","pipeThroughChannelOrFail","chan","provideContext","provideSomeContext","mapInputContext","provideLayer","buildWithScope","env","provideService","tag","resource","provideServiceEffect","provideServiceStream","service","add","provideSomeLayer","min","go","remaining","race","raceAll","winner","index","takeWhile","unsafeDone","target","rechunkProcess","StreamRechunker","rechunker","writeAll","emitIfNotEmpty","pos","refineOrDie","refineOrDieWith","repeat","repeatEither","repeatEffect","repeatEffectChunk","repeatWith","onElement","onSchedule","repeatElements","repeatElementsWith","feed","step","advance","reset","repeatValue","provideLastIterationInfo","CurrentIterationMetadata","iterationMeta","repeatWithSchedule","repeatEffectWithSchedule","matchEffect","nextA","retry","policy","withExecutionPlan","preventFallbackOnPartialStream","i","lastError","steps","getOrThrow","nextStream","isContext","provide","receivedElements","attempted","wrapped","scheduleDefectRefail","scheduleFromStep","scheduleDefectRefailCause","runDrain","runCollect","collectAll","runCount","runFold","runFoldWhile","runFoldEffect","runFoldWhileEffect","runFoldScoped","runFoldWhileScoped","runFoldScopedEffect","runFoldWhileScopedEffect","fold","foldEffect","runForEach","runForEachChunk","forEachChunk","runForEachChunkScoped","runForEachWhile","forEachWhile","runForEachWhileScoped","runHead","runIntoPubSub","runIntoQueue","runIntoQueueScoped","runIntoQueueElementsScoped","offerAll","runLast","runSum","sum","scan","scanEffect","scanReduce","scanReduceEffect","scheduleWith","zipLeft","someOrFail","someOrElse","fallback","slidingSize","stepSize","IllegalArgumentException","emitOnStreamEnd","queueSize","channelEnd","items","toChunk","lastEmitIndex","lastItems","takeRight","currentIndex","split","isNone","splitOnChunk","delimiter","delimiterIndex","inputChunk","carry","delimiterCursor","concatenated","splitLines","isInteger","taken","POSITIVE_INFINITY","takeUntil","takeUntilEffect","tapBoth","tapError","tapSink","foldCauseChannel","throttle","throttleEffect","cost","throttleEnforceEffect","units","burst","throttleShapeEffect","tokens","timestampMillis","currentTimeMillis","weight","elapsed","cycles","toMillis","available","throttled","costFn","waitCycles","delay","millis","greaterThan","zero","tick","interval","toPull","timeoutFail","onTimeout","timeoutTo","timeoutFailCause","StreamTimeout","RuntimeException","isDieType","isRuntimeException","replay","toReadableStream","toReadableStreamRuntime","defaultRuntime","toReadableStreamEffect","runFork","currentResolve","unsafeMakeLatch","ReadableStream","controller","whenOpen","unsafeClose","addObserver","close","Promise","resolve","runSync","open","runPromise","transduce","newChannel","upstreamDone","concatAndGet","upstreamMarker","transducer","newLeftovers","nextChannel","toAsyncIterableRuntime","currentReject","reject","unsafeOpen","toAsyncIterable","toAsyncIterableEffect","unfoldChunk","void_","updateService","test","whenEffect","whenCase","whenCaseEffect","withSpan","dataFirst","name","addSpanStackTrace","zipWith","zipFlatten","zipAll","zipAllWith","defaultOther","defaultSelf","onBoth","zipAllLeft","zipAllRight","defaultRight","zipAllSortedByKey","zipAllSortedByKeyWith","order","zipAllSortedByKeyLeft","zipAllSortedByKeyRight","OP_DRAIN_LEFT","leftChunk","DrainLeft","OP_DRAIN_RIGHT","rightChunk","DrainRight","OP_PULL_BOTH","concurrent","leftOption","rightOption","PullBoth","PullLeft","PullRight","OP_PULL_LEFT","OP_PULL_RIGHT","hasNext","leftIndex","rightIndex","leftTuple","rightTuple","k1","k2","compare","rightBuilder","leftBuilder","zipChunks","zipLatest","zipLatestWith","zipLatestAll","tail","first","second","pullNonEmpty","rightFiber","l","leftFiber","leftFirst","unsafeLast","latest","modify","rightLatest","leftLatest","zipWithChunks","zipWithIndex","zipWithNext","prev","curr","zipWithPrevious","zipWithPreviousAndNext","Do","bind","bindTo","let_","channelToStream","decodeText","encoding","decoder","TextDecoder","decode","encodeText","encoder","TextEncoder","encode","fromEventListener","type","addEventListener","single","removeEventListener"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,OAAO,KAAKA,KAAK,MAAM,aAAa;AAEpC,OAAO,KAAKC,KAAK,MAAM,aAAa;AACpC,OAAO,KAAKC,KAAK,MAAM,aAAa;AACpC,OAAO,KAAKC,OAAO,MAAM,eAAe;AACxC,OAAO,KAAKC,QAAQ,MAAM,gBAAgB;AAC1C,OAAO,KAAKC,QAAQ,MAAM,gBAAgB;AAC1C,OAAO,KAAKC,MAAM,MAAM,cAAc;AACtC,OAAO,KAAKC,MAAM,MAAM,cAAc;AACtC,OAAO,KAAKC,KAAK,MAAM,aAAa;AAEpC,OAAO,KAAKC,IAAI,MAAM,YAAY;AAClC,OAAO,KAAKC,KAAK,MAAM,aAAa;AACpC,OAAO,KAAKC,QAAQ,MAAM,gBAAgB;AAE1C,SAASC,SAAS,EAAEC,IAAI,EAAEC,QAAQ,EAAEC,IAAI,QAAQ,gBAAgB;AAChE,OAAO,KAAKC,qBAAqB,MAAM,8BAA8B;AACrE,OAAO,KAAKC,KAAK,MAAM,aAAa;AACpC,OAAO,KAAKC,aAAa,MAAM,qBAAqB;AACpD,OAAO,KAAKC,MAAM,MAAM,cAAc;AAEtC,SAASC,aAAa,QAAQ,gBAAgB;AAC9C,SAASC,WAAW,QAAyC,iBAAiB;AAC9E,OAAO,KAAKC,MAAM,MAAM,cAAc;AACtC,OAAO,KAAKC,KAAK,MAAM,aAAa;AACpC,OAAO,KAAKC,KAAK,MAAM,aAAa;AACpC,OAAO,KAAKC,GAAG,MAAM,WAAW;AAChC,OAAO,KAAKC,OAAO,MAAM,eAAe;AACxC,OAAO,KAAKC,QAAQ,MAAM,gBAAgB;AAK1C,OAAO,KAAKC,YAAY,MAAM,0BAA0B;AAExD,OAAO,KAAKC,OAAO,MAAM,eAAe;AACxC,OAAO,KAAKC,MAAM,MAAM,cAAc;AAEtC,OAAO,KAAKC,KAAK,MAAM,aAAa;AAEpC,OAAO,KAAKC,OAAO,MAAM,cAAc;AACvC,OAAO,KAAKC,eAAe,MAAM,8BAA8B;AAC/D,OAAO,KAAKC,aAAa,MAAM,4BAA4B;AAC3D,OAAO,KAAKC,IAAI,MAAM,kBAAkB;AACxC,OAAO,KAAKC,UAAU,MAAM,iBAAiB;AAC7C,SAASC,UAAU,QAAQ,iBAAiB;AAC5C,OAAO,KAAKC,gBAAgB,MAAM,eAAe;AACjD,OAAO,KAAKC,KAAK,MAAM,WAAW;AAClC,OAAO,KAAKC,aAAa,MAAM,2BAA2B;AAC1D,OAAO,KAAKC,IAAI,MAAM,kBAAkB;AACxC,OAAO,KAAKC,YAAY,MAAM,0BAA0B;AACxD,OAAO,KAAKC,OAAO,MAAM,qBAAqB;AAC9C,OAAO,KAAKC,aAAa,MAAM,2BAA2B;AAC1D,OAAO,KAAKC,IAAI,MAAM,kBAAkB;AACxC,OAAO,KAAKC,aAAa,MAAM,2BAA2B;AAC1D,OAAO,KAAKC,WAAW,MAAM,yBAAyB;AACtD,OAAO,KAAKC,cAAc,MAAM,4BAA4B;AAC5D,OAAO,KAAKC,YAAY,MAAM,WAAW;AACzC,OAAO,KAAKC,cAAc,MAAM,aAAa;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAE7C,cAAA,GACA,MAAMC,eAAe,GAAG,eAAe;AAGhC,MAAMC,YAAY,GAAA,WAAA,GAAwBC,MAAM,CAACC,GAAG,CACzDH,eAAe,CACO;AAExB,cAAA,GACA,MAAMI,cAAc,GAAG;IACrBC,EAAE,GAAGC,CAAQ,GAAKA,CAAC;IACnBC,EAAE,GAAGD,CAAQ,GAAKA,CAAC;IACnBE,EAAE,GAAGF,CAAQ,GAAKA;CACnB;AAGK,MAAOG,UAAU;IAGV5B,OAAA,CAAA;IAFF,CAACoB,YAAY,CAAA,GAAIG,cAAc,CAAA;IACxCM,YACW7B,OAAkF,CAAA;QAAlF,IAAA,CAAAA,OAAO,GAAPA,OAAO;IAElB;IAEAjB,IAAIA,CAAA,EAAA;QACF,+JAAOK,gBAAAA,AAAa,EAAC,IAAI,EAAE0C,SAAS,CAAC;IACvC;;AAIK,MAAMC,QAAQ,IAAIC,CAAU,GACjC3C,uKAAAA,AAAW,EAAC2C,CAAC,EAAEZ,YAAY,CAAC,IAAI9C,MAAM,CAAC2D,0JAAAA,AAAQ,EAACD,CAAC,CAAC;AAG7C,MAAME,gBAAgB,GAAG,IAAI;AAG7B,MAAMC,UAAU,IAAaC,IAA4B,GAC9DC,MAAM,CAACC,gBAAgB,CAACF,IAAI,CAAC,CAAC;AAGzB,MAAME,gBAAgB,IAAaF,IAA4B,IAA4B;IAChG,MAAMG,WAAW,IACfC,CAAiB,4KAEjBrC,IAAI,CAACsC,OAAAA,AAAQ,EAAC;YACZC,OAAO,GAAGC,KAAqB,IAAI;gBACjC,MAAMC,IAAI,uJAAG3E,KAAK,CAAC4E,OAAAA,AAAS,EAACL,CAAC,EAAEG,KAAK,CAAC;gBACtC,iLAAOxC,IAAI,CAAC2C,KAAAA,AAAO,4KACjB3C,IAAI,CAAC4C,GAAAA,AAAK,EAACH,IAAI,CAAC,EAChB,IAAML,WAAW,CAACK,IAAI,CAAC,CACxB;YACH,CAAC;YACDI,SAAS,wKAAE7C,IAAI,CAAC8C,EAAI;YACpBC,MAAM,EAAEA,CAAA,yKAAM/C,IAAI,CAACgD,EAAAA;SACpB,CAAC;IACJ,OAAO,IAAIvB,UAAU,CAACzB,IAAI,CAACiD,8KAAAA,AAAM,EAACC,SAAS,CAACjB,IAAI,CAAC,EAAEG,WAAW,sJAACtE,KAAK,CAACqF,EAAAA,AAAK,EAAE,CAAC,CAAC,CAAC;AACjF,CAAC;AAGM,MAAMC,cAAc,GAAGA,CAC5BC,OAA+B,EAC/BC,OAAwF,GACxDC,MAAM,uJAACpF,MAAM,CAACiF,UAAAA,AAAc,EAACC,OAAO,EAAEC,OAAO,CAAC,CAAC;AAG1E,MAAME,SAAS,GAAA,WAAA,2JAAG9E,OAAAA,AAAI,EAS3B,CAAC,EACD,CACEuD,IAA4B,EAC5BwB,IAAsC,GACDC,eAAe,CAACzB,IAAI,EAAEwB,IAAI,sJAAEjE,QAAQ,CAACmE,CAAO,CAAC,CACrF;AAGM,MAAMD,eAAe,GAAA,WAAA,2JAAGhF,OAAI,AAAJA,EAW7B,CAAC,EACD,CACEuD,IAA4B,EAC5BwB,IAAsC,EACtCG,QAAoD,GAEpDC,SAAS,CACPC,qBAAqB,CAAC7B,IAAI,EAAEwB,IAAI,EAAEG,QAAQ,CAAC,GAC1CtC,CAAC,yJACAlD,MAAM,CAAC2F,CAAAA,AAAK,EAACzC,CAAC,EAAE;YACd0C,MAAM,oJAAEhF,MAAM,CAACiF,AAAI;YACnBC,OAAO,oJAAElF,MAAM,CAACmF;SACjB,CAAC,CACL,CACJ;AAGM,MAAML,qBAAqB,GAAA,WAAA,2JAAGpF,OAAAA,AAAI,EAWvC,CAAC,EACD,CACEuD,IAA4B,EAC5BwB,IAAsC,EACtCG,QAAoD,KACO;IAC3D,MAAMQ,KAAK,yJAAGjG,MAAM,AAACkG,AAAG,CAAHA,CAAI;qLACvB7D,OAAO,AAAC8D,AAAI,CAAJA,CAA8C;2JACtDhF,GAAG,CAACgF,GAAAA,AAAI,iLAA8B3D,aAAa,CAAC4D,AAAW,CAAC;YAChEjF,GAAG,CAACgF,kJAAAA,AAAI,uJAACxG,KAAK,CAACqF,EAAAA,AAAK,EAAU,CAAC;gKAC/B3D,QAAQ,CAACgF,AAAM,AAANA,EAAOZ,QAAQ,CAAC;2JACzBtE,GAAG,CAACgF,GAAAA,AAAI,EAAC,KAAK,CAAC;2JACfhF,GAAG,CAACgF,GAAAA,AAAI,EAAC,KAAK,CAAC;KAChB,CAAC;IACF,OAAOG,UAAU,CAACL,KAAK,CAAC,CAACxF,IAAI,CAC3B+D,OAAO,CAAC,CAAC,CAAC+B,OAAO,EAAEC,aAAa,EAAEC,aAAa,EAAEC,cAAc,EAAEC,QAAQ,EAAEC,YAAY,CAAC,KAAI;QAC1F,MAAMC,eAAe,4KAA4EhF,IAAI,CAClGiF,YAAAA,AAAa,EAAC;YACb1C,OAAO,GAAGC,KAAqB,6KAC7BxC,IAAI,CAAC2C,KAAAA,AAAO,4KACV3C,IAAI,CAACyE,QAAAA,AAAU,0JAAC7F,OAAAA,AAAI,EAClB8F,OAAO,EACPlE,OAAO,CAAC0E,6KAAAA,AAAK,oLAAyCzE,QAAcH,AAAI,EAACkC,GAAN,CAAClC,CAAU,CAAC,CAAC,wJAChFnC,MAAM,CAACgH,AAAI,EAAC,yJAAMrH,KAAK,CAACsH,OAAAA,AAAU,EAAC5C,KAAK,CAAC,CAAC,CAC3C,CAAC,EACF,IAAMwC,eAAe,CACtB;YACHnC,SAAS,GAAGwC,KAAK,GACfrF,IAAI,CAACyE,kLAAAA,AAAU,+KACbjE,OAAO,CAAC0E,AAAK,AAALA,EACNR,OAAO,qLACPjE,OAAc6E,AAAI,EAACD,IAAN,CAACC,AAAU,CAAC,CAC1B,CACF;YACHvC,MAAM,EAAEA,CAAA,6KACN/C,IAAI,CAACyE,QAAAA,AAAU,8KACbjE,OAAO,CAAC0E,CAAAA,AAAK,EACXR,OAAO,qLACPjE,MAAc8E,AAAG,OAAJ,CAACA,yKAAI5E,aAAa,CAAC6E,AAAW,CAAC,CAC7C;SAEN,CAAC;QACJ,MAAMC,eAAe,2JAAkF7G,OAAAA,AAAI,qJACzGU,GAAG,CAACoG,QAAAA,AAAS,EAACd,aAAa,uJAAE9G,KAAK,CAACqF,EAAAA,AAAK,EAAE,CAAC,yJAC3ChF,MAAM,CAACwE,GAAAA,AAAO,EAAEgD,SAAS,IAAI;YAC3B,yJAAI7H,KAAK,CAACsH,OAAAA,AAAU,EAACO,SAAS,CAAC,EAAE;gBAC/B,+JAAO/G,OAAI,AAAJA,qJACLU,GAAG,CAACsG,EAAG,AAAHA,EAAId,QAAQ,EAAE,IAAI,CAAC,wJACvB3G,MAAM,CAAC0H,IAAAA,AAAQ,wJAAC1H,MAAM,CAAC2H,GAAAA,AAAO,EAAClH,+JAAAA,AAAI,EACjCoB,IAAI,CAAC4C,6KAAAA,AAAK,EAAC+C,SAAS,CAAC,4KACrB3F,IAAI,CAAC2C,KAAAA,AAAO,EAAC,IAAM8C,eAAe,CAAC,CACpC,CAAC,CAAC,CACJ;YACH;YACA,+JAAO7G,OAAAA,AAAI,MACT4B,OAAO,CAACuF,wKAAAA,AAAI,EAACrB,OAAO,CAAC,uJACrBvG,MAAM,CAAC6H,AAAG,GAAEC,MAAM,IAAI;gBACpB,OAAQA,MAAM,CAACC,IAAI;oBACjB,oLAAKzF,UAAqB,GAAR,CAAC0F;wBAAS;4BAC1B,+JAAOvH,OAAAA,AAAI,MACToB,IAAI,CAACyE,8KAAAA,AAAU,qJAACnF,GAAG,CAACsG,EAAAA,AAAG,EAACd,QAAQ,EAAE,IAAI,CAAC,CAAC,qKACxCjF,OAAO,CAACgG,GAAAA,AAAQ,4KAAC7F,IAAI,CAAC4C,GAAK,AAALA,EAAMqD,MAAM,CAACG,QAAQ,CAAC,CAAC,qKAC7CvG,OAAO,CAACgG,GAAAA,AAAQ,4KAAC7F,IAAI,CAACyE,QAAAA,AAAU,qJAACnF,GAAG,CAAC+G,EAAAA,AAAG,EAACtB,YAAY,CAAC,CAAC,CAAC,EACxD/E,IAAI,CAAC2C,+KAAAA,AAAO,GAAE2D,IAAI,GAAKA,IAAI,yKAAGtG,IAAI,CAACgD,EAAI,GAAGyC,eAAe,CAAC,CAC3D;wBACH;oBACA,oLAAKhF,UAAqB,GAAR,CAAC8F;wBAAS;4BAC1B,iLAAOvG,IAAI,CAACwG,OAAAA,AAAS,EAACP,MAAM,CAACZ,KAAK,CAAC;wBACrC;oBACA,mLAAK5E,UAAoB,GAAP,CAACgG;wBAAQ;4BACzB,IAAIR,MAAM,CAACS,MAAM,CAACR,IAAI,oLAAKvF,aAAa,CAACgG,IAAe,EAAE;gCACxD,+JAAO/H,OAAAA,AAAI,qJACTU,GAAG,CAAC+G,EAAAA,AAAG,EAACvB,QAAQ,CAAC,wJACjB3G,MAAM,AAAC6H,AAAG,CAAHA,EAAKM,IAAI,GACdA,IAAI,6KACFtG,IAAI,CAACyE,QAAAA,AAAU,0JACb7F,OAAAA,AAAI,EACFU,GAAG,CAACsG,qJAAAA,AAAG,EAACjB,aAAa,iLAAEhE,aAAa,CAAC4D,AAAW,CAAC,wJACjDpG,MAAM,CAAC0H,IAAQ,AAARA,GAASvG,GAAG,CAACsG,oJAAAA,AAAG,EAACb,YAAY,EAAE,IAAI,CAAC,CAAC,CAC7C,CACF,2JACDnG,OAAAA,AAAI,4KACFoB,IAAI,CAACyE,QAAAA,AAAU,EACb7F,+JAAAA,AAAI,qJACFU,GAAG,CAACsG,EAAAA,AAAG,EAACjB,aAAa,EAAEhE,aAAa,CAAC4D,+KAAW,CAAC,wJACjDpG,MAAM,CAAC0H,IAAAA,AAAQ,qJAACvG,GAAG,CAACsG,EAAAA,AAAG,EAACb,YAAY,EAAE,IAAI,CAAC,CAAC,CAC7C,CACF,4KACD/E,IAAI,CAAC2C,KAAAA,AAAO,EAAC,IAAM8C,eAAe,CAAC,CACpC,CACJ,iKACD5F,OAAO,CAAC+G,CAAM,CACf;4BACH;4BACA,WAAOhI,2JAAAA,AAAI,qJACTU,GAAG,CAACsG,EAAAA,AAAG,EAA8BjB,aAAa,EAAEsB,MAAM,CAACS,MAAM,CAAC,wJAClEvI,MAAM,CAAC0H,IAAAA,AAAQ,EAACvG,GAAG,CAACsG,qJAAG,AAAHA,EAAIb,YAAY,EAAE,IAAI,CAAC,CAAC,wKAC5C/E,IAAI,CAACyE,QAAU,CAChB;wBACH;gBACF;YACF,CAAC,CAAC,CACH;QACH,CAAC,CAAC,iKACF5E,OAAO,CAAC+G,CAAM,CACf;QACD,MAAMC,OAAO,IAAIC,KAAuB,GACtCjC,cAAc,CAACpC,IAAI,CAACqE,KAAK,CAAC;QAC5B,MAAMC,mBAAmB,GAAGA,CAC1BC,SAAqF,EACrFC,aAA0D,EAC1DC,KAAkB,KACwF;YAC1G,MAAMC,QAAQ,2JAAGvI,OAAAA,AAAI,qJACnBU,GAAG,CAACsG,EAAAA,AAAG,EAACd,QAAQ,EAAE,KAAK,CAAC,wJACxB3G,MAAM,CAAC0H,IAAAA,AAAQ,qJAACvG,GAAG,CAACsG,EAAAA,AAAG,EAACb,YAAY,EAAE,KAAK,CAAC,CAAC,wJAC7C5G,MAAM,CAAC0H,IAAAA,AAAQ,EACbjH,+JAAAA,AAAI,EACF6G,eAAe,qKACf5F,OAAO,CAACuH,OAAAA,AAAY,kKAAChH,KAAK,CAAC8C,MAAAA,AAAS,EAACO,IAAI,CAAC,CAAC,wKAC3CzD,IAAI,CAACqH,aAAe,iKACpBxH,MAAW,CAAJ,CAACyH,sJACRnJ,MAAM,CAACoJ,EAAAA,AAAM,EAACL,KAAK,CAAC,CACrB,CACF,CACF;YACD,MAAMM,UAAU,GAAGA,CACjB7B,SAA2C,EAC3C8B,CAAI,EACJC,CAAmB,2JAEnB9I,OAAAA,AAAI,EACFU,GAAG,CAACsG,qJAAAA,AAAG,EAAChB,aAAa,uJAAE9G,KAAK,CAAC6J,IAAO,AAAPA,EAAQhC,SAAS,CAAC,CAAC,MAChDxH,MAAM,CAAC0H,sJAAAA,AAAQ,MACb1H,MAAM,CAAC6H,iJAAAA,AAAG,qJAAC1G,GAAG,CAAC+G,EAAAA,AAAG,EAAC1B,aAAa,CAAC,GAAG+B,MAAM,IAAI;oBAC5C,OAAQA,MAAM,CAACR,IAAI;wBACjB,oLAAKvF,aAAa,CAACgG,IAAe;4BAAE;gCAClC,+JAAO/H,OAAAA,AAAI,MACTT,MAAM,CAACkG,iJAAAA,AAAG,EAAC;wCACT/E,GAAG,CAAC+G,iJAAAA,AAAG,EAACvB,QAAQ,CAAC;oCACjBqC,QAAQ;4LACRvI,OAAAA,AAAI,EAACiI,OAAO,uJAAC7H,MAAM,CAACmF,AAAI,EAACsD,CAAC,CAAC,CAAC,wJAAEtJ,MAAM,CAACoJ,EAAAA,AAAM,EAACL,KAAK,CAAC,CAAC;iCACpD,CAAC,wJACF/I,MAAM,AAAC6H,AAAG,CAAHA,CAAI,CAAC,CAAC4B,WAAW,EAAEZ,SAAS,EAAEC,aAAa,CAAC,KAAI;oCACrD,MAAMY,OAAO,2JAAGjJ,OAAAA,AAAI,EAClB8I,CAAC,wJACD1I,MAAM,CAAC+E,CAAAA,AAAK,EAAC;wCACX+D,MAAM,EAAEA,CAAA,wJAAwChK,KAAK,AAACiK,AAAE,CAAFA,uJAAG3J,MAAM,CAAC4J,CAAAA,AAAK,EAACP,CAAC,CAAC,CAAC;wCACzEQ,MAAM,GAAGP,CAAC,wJACR5J,KAAK,CAACwG,CAAAA,AAAI,EAAClG,MAAM,CAAC4J,uJAAAA,AAAK,EAACP,CAAC,CAAC,MAAErJ,MAAM,CAAC8J,kJAAI,AAAJA,EAAKR,CAAC,CAAC;qCAC7C,CAAC,CACH;oCACD,IAAIE,WAAW,EAAE;wCACf,+JAAOhJ,OAAAA,AAAI,4KACToB,IAAI,CAAC4C,GAAAA,AAAK,EAACiF,OAAO,CAAC,EACnB7H,IAAI,CAAC2C,+KAAAA,AAAO,EAAC,IAAMoE,mBAAmB,CAACC,SAAS,EAAEC,aAAa,EAAEC,KAAK,CAAC,CAAC,CACzE;oCACH;oCACA,OAAOH,mBAAmB,CAACC,SAAS,EAAEC,aAAa,EAAEC,KAAK,CAAC;gCAC7D,CAAC,CAAC,EACFrH,OAAO,CAAC+G,gKAAM,CACf;4BACH;wBACA,mLAAKjG,aAAa,CAACwH,KAAe;4BAAE;gCAClC,+JAAOvJ,OAAAA,AAAI,qJACTU,GAAG,CAAC+G,EAAG,AAAHA,EAAIvB,QAAQ,CAAC,wJACjB3G,MAAM,AAAC6H,AAAG,CAAHA,CAAK4B,WAAW,IACrBA,WAAW,6KACT5H,IAAI,CAAC4C,GAAAA,AAAK,uJAAC9E,KAAK,AAACiK,AAAE,CAAFA,CAAwB3J,MAAM,CAAC4J,uJAAAA,AAAK,EAACP,CAAC,CAAC,CAAC,CAAC,yKAC1DzH,IAAI,CAACgD,EAAI,CACZ,gKACDnD,OAAO,CAAC+G,EAAM,CACf;4BACH;oBACF;gBACF,CAAC,CAAC,CACH,iKACD/G,OAAO,CAAC+G,CAAM,CACf;YACH,0KAAO/G,OAAO,CAAC+G,CAAAA,AAAM,wJACnBzI,MAAM,CAACiK,IAAAA,AAAQ,uJAAC7J,KAAK,CAAC8J,CAAAA,AAAI,EAACrB,SAAS,CAAC,EAAEzI,KAAK,CAAC8J,sJAAAA,AAAI,EAACpB,aAAa,CAAC,EAAE;gBAChEqB,UAAU,EAAEA,CAACC,QAAQ,EAAEjH,CAAC,2JACtB1C,OAAAA,AAAI,MACFL,KAAK,CAACiK,uJAAAA,AAAS,EAACvB,aAAa,CAAC,wJAC9B9I,MAAM,CAAC0H,IAAAA,AAAQ,0JAACjH,OAAAA,AAAI,wJAClBT,MAAM,CAACsK,GAAAA,AAAO,EAAC,IAAMF,QAAQ,CAAC,uJAC9BpK,MAAM,CAAC6H,AAAG,EAAC,CAAC,CAACL,SAAS,EAAE8B,CAAC,CAAC,GAAKD,UAAU,CAAC7B,SAAS,EAAE8B,CAAC,MAAEzI,MAAM,CAACiF,kJAAI,AAAJA,EAAM,CAAC,CAAC,CACxE,CAAC,CACH;gBACHyE,WAAW,EAAEA,CAACC,YAAY,EAAErH,CAAC,yJAC3BnD,MAAM,CAACyK,YAAAA,AAAgB,wJAACzK,MAAM,CAACsK,GAAAA,AAAO,EAAC,IAAME,YAAY,CAAC,EAAE;wBAC1D9F,SAAS,GAAGwC,KAAK,yJACfjH,MAAM,CAAC2F,CAAAA,AAAK,uJACVlG,KAAK,CAACgL,WAAAA,AAAc,EAACxD,KAAK,CAAC,EAC3B;gCACErB,MAAM,EAAEA,CAAA,2JACNpF,OAAI,AAAJA,EACE8F,OAAO,+KACPlE,OAAO,CAAC0E,AAAK,qLACXzE,MAAc8E,AAAG,OAAJ,CAACA,yKAAI5E,aAAa,CAAC4D,AAAW,CAAC,CAC7C,oJACDpG,MAAM,CAAC2K,MAAU,wJACjB3K,MAAM,CAAC0H,IAAQ,AAARA,EACLjH,+JAAAA,AAAI,sJACFL,KAAK,CAAC8J,EAAAA,AAAI,EAACrB,SAAS,CAAC,wJACrB7I,MAAM,AAAC6H,AAAG,CAAHA,CAAI,CAAC,CAACL,SAAS,EAAE8B,CAAC,CAAC,GAAKD,UAAU,CAAC7B,SAAS,EAAE8B,CAAC,wJAAEzI,MAAM,CAACiF,AAAI,EAAE,CAAC,CAAC,CACxE,CACF,CACF;gCACHC,OAAO,EAAGmB,KAAK,4JACbzG,OAAAA,AAAI,EACF8F,OAAO,+KACPlE,OAAO,CAAM,AAAL0E,qLACNzE,OAAc6E,AAAI,EAACD,IAAN,CAACC,AAAU,CAAC,CAC1B,oJACDnH,MAAM,CAAC2K,MAAU,wJACjB3K,MAAM,CAAC0H,IAAAA,AAAQ,GACbjH,8JAAAA,AAAI,uJACFL,KAAK,CAAC8J,CAAAA,AAAI,EAACrB,SAAS,CAAC,wJACrB7I,MAAO6H,AAAG,AAAJ,CAACA,CAAI,CAAC,CAACL,SAAS,EAAE8B,CAAC,CAAC,GAAKD,UAAU,CAAC7B,SAAS,EAAE8B,CAAC,EAAEzI,MAAM,CAACiF,sJAAAA,AAAI,EAAE,CAAC,CAAC,CACxE,CACF;6BAEN,CACF;wBACH8E,SAAS,GAAGrB,CAAC,2JACX9I,OAAAA,AAAI,EACF8F,OAAO,+KACPlE,OAAO,CAAC0E,AAAK,qLACXzE,MAAc8E,AAAG,EAAC5E,KAAL,CAAC4E,OAAiB,CAAChB,+KAAW,CAAC,CAC7C,oJACDpG,MAAM,CAAC2K,MAAU,wJACjB3K,MAAM,CAAC0H,IAAQ,AAARA,0JACLjH,OAAI,AAAJA,EACEL,KAAK,CAAC8J,sJAAAA,AAAI,EAACrB,SAAS,CAAC,wJACrB7I,MAAM,AAAC6H,AAAG,CAAHA,CAAI,CAAC,CAACL,SAAS,EAAE8B,CAAC,CAAC,GAAKD,UAAU,CAAC7B,SAAS,EAAE8B,CAAC,wJAAEzI,MAAM,CAAK,AAAJmF,EAAKuD,CAAC,CAAC,CAAC,CAAC,CACzE,CACF;qBAEN;aACJ,CAAC,CACH;QACH,CAAC;QACD,OAAOsB,gBAAgB,CAAE9B,KAAK,8KAC5BlH,IAAI,CAACiD,IAAM,AAANA,EAAOC,SAAS,CAACjB,IAAI,CAAC,EAAE+C,eAAe,CAAC,CAACpG,IAAI,gKAChDiB,MAAW,CAAJ,CAACyH,sJACRnJ,MAAM,CAACoJ,EAAAA,AAAM,EAACL,KAAK,CAAC,EACpB/I,MAAM,CAAC0H,0JAAAA,AAAQ,EACbhG,OAAO,CAACuH,0KAAAA,AAAY,EAAC3B,eAAe,kKAAErF,KAAK,CAAC8C,MAAS,AAATA,EAAUO,IAAI,CAAC,CAAC,CAAC7E,IAAI,sKAC/DoB,IAAI,CAACqH,cAAe,iKACpBxH,MAAW,CAAJ,CAACyH,sJACRnJ,MAAM,CAACoJ,EAAM,AAANA,EAAOL,KAAK,CAAC,wJACpB/I,MAAM,CAACwE,GAAAA,AAAO,GAAEqE,SAAS,GACvBH,OAAO,uJAAC7H,MAAM,CAACiF,AAAI,EAAE,CAAC,EAACrF,IAAI,KACzBT,MAAM,CAACoJ,oJAAAA,AAAM,EAACL,KAAK,CAAC,wJACpB/I,MAAM,AAAC6H,AAAG,CAAHA,EAAKiB,aAAa,GACvB,IAAIxF,UAAU,CACZsF,mBAAmB,CAACC,SAAS,EAAEC,aAAa,EAAEC,KAAK,CAAC,CACrD,CACF,CACF,CACF,CACF,CACF,CACF,CACF;IACH,CAAC,CAAC,CACH;AACH,CAAC,CACF;AAGM,MAAM+B,EAAE,GAAA,WAAA,2JAAGvK,OAAAA,AAAI,EAGpB,CAAC,EAAE,CAAauD,IAA4B,EAAEiH,KAAQ,GAA6BlD,GAAG,CAAC/D,IAAI,EAAE,IAAMiH,KAAK,CAAC,CAAC;AAE5G,MAAMC,sBAAsB,IAC1BC,UAGa,IACkC;IAC/C,IAAIA,UAAU,KAAK,WAAW,EAAE;QAC9B,4JAAOhK,KAAK,CAACiK,MAAAA,AAAS,EAAE;IAC1B,CAAC,MAAM,IAAI,OAAOD,UAAU,KAAK,QAAQ,IAAIA,UAAU,KAAKE,SAAS,EAAE;QACrE,OAAOlK,KAAK,CAACmK,yJAAAA,AAAO,EAACH,UAAU,IAAI,EAAE,CAAC;IACxC;IACA,OAAQA,UAAU,CAACI,QAAQ;QACzB,KAAK,UAAU;YACb,4JAAOpK,KAAK,CAACqK,KAAQ,AAARA,EAASL,UAAU,CAACA,UAAU,IAAI,EAAE,CAAC;QACpD,KAAK,SAAS;YACZ,4JAAOhK,KAAK,CAACsK,IAAAA,AAAO,EAACN,UAAU,CAACA,UAAU,IAAI,EAAE,CAAC;QACnD;YACE,4JAAOhK,KAAK,CAACmK,IAAAA,AAAO,EAACH,UAAU,CAACA,UAAU,IAAI,EAAE,CAAC;IACrD;AACF,CAAC;AAGM,MAAMO,MAAM,GAAGA,CACpBC,QAEyC,EACzCR,UAGa,yJAEbjL,MAAM,CAACiF,UAAAA,AAAc,EACnB+F,sBAAsB,CAAOC,UAAU,CAAC,GACvCS,KAAK,wJAAKzK,KAAK,CAAC0K,KAAAA,AAAQ,EAACD,KAAK,CAAC,CACjC,CAACjL,IAAI,uJACJT,MAAM,CAACwE,GAAAA,AAAO,GAAEoH,MAAM,GACpB5L,MAAM,CAAC6L,yJAAO,AAAPA,EAAY,EAACpL,IAAI,uJACtBT,MAAM,CAACwE,GAAAA,AAAO,GAAEqH,OAAO,yJACrB7L,MAAM,CAAC8L,AAAI,EAAC,MAAK;gBACf,MAAMC,cAAc,0JAAG3K,OAAO,CAAC2K,SAAAA,AAAc,EAACF,OAAO,CAAC;gBACtD,MAAMG,QAAQ,GAAGP,QAAQ,CAACtJ,IAAI,CAACgE,4KAAAA,AAAI,GAAiB8F,MAAM,mKACxDtJ,WAAqB,AAARuJ,CAAD,CAAUD,AAATC,MAAe,CAAC,CAACzL,IAAI,uJAChCT,MAAM,CAACwE,GAAAA,AAAO,GAAEoD,IAAI,IAAK3G,KAAK,CAAC8F,sJAAAA,AAAK,EAAC6E,MAAM,EAAEhE,IAAI,CAAC,CAAC,oJACnD5H,MAAM,CAACmM,EAAM,EACbJ,cAAc,CACf,CAACK,IAAI,EAAEC,IAAI,IAAI;wBACd,wJAAIlM,IAAI,CAACmM,OAAAA,AAAS,EAACD,IAAI,CAAC,EAAE;4BACxB,IAAI,sJAAC3M,KAAK,CAAC6M,UAAAA,AAAa,EAACF,IAAI,CAACnF,KAAK,CAAC,EAAE;gCACpC,2JAAMxH,KAAK,CAAC8M,GAAAA,AAAM,EAACH,IAAI,CAACnF,KAAK,CAAC;4BAChC;wBACF;oBACF,CAAC,CAAC,CACH,CAAC;gBACF,OAAO8E,QAAQ;YACjB,CAAC,CAAC,CACH,wJACDhM,MAAM,AAAC6H,AAAG,CAAHA,EAAKkD,KAAK,IAAI;YACnB,MAAM0B,IAAI,wJAAwExL,KAAK,CAAC2G,CAAAA,AAAI,EAACgE,MAAM,CAAC,CAACnL,IAAI,uJACvGT,MAAM,CAACwE,GAAAA,AAAO,GAAEoD,IAAI,mKAAKjF,OAAa+J,AAAI,EAAC9E,GAAN,CAAC8E,AAAS,CAAC,CAAC,EACjD1M,MAAM,CAAC4F,uJAAAA,AAAK,EAAC;gBACXlB,SAAS,GAAGiI,UAAU,4KACpB9K,IAAI,CAACyE,SAAAA,AAAU,uJAACrF,KAAK,CAAC0K,KAAAA,AAAQ,EAACC,MAAM,CAAC,CAAC,CAACnL,IAAI,oKAC1CiB,OAAO,CAACgG,GAAAA,AAAQ,EAAC7G,MAAM,CAAC+E,uJAAAA,AAAK,EAAC+G,UAAU,EAAE;wBACxChD,MAAM,EAAEA,CAAA,yKAAM9H,IAAI,CAACgD,EAAI;wBACvBiF,MAAM,GAAG8C,KAAK,6KAAK/K,IAAI,CAAC8C,EAAAA,AAAI,EAACiI,KAAK;qBACnC,CAAC,CAAC,CACJ;gBACHhC,SAAS,GAAGiC,KAAK,OAAKhL,IAAI,CAAC4C,yKAAAA,AAAK,EAACoI,KAAK,CAAC,CAACpM,IAAI,2KAACoB,IAAI,CAAC2C,KAAAA,AAAO,EAAC,IAAMiI,IAAI,CAAC;aACtE,CAAC,iKACF/K,OAAO,CAAC+G,CAAM,CACf;YACD,OAAOqE,WAAW,CAACL,IAAI,CAAC,CAAChM,IAAI,CAACsM,QAAQ,CAAChC,KAAK,sJAAI/K,MAAM,CAAC6E,AAAI,CAAC,CAAC;QAC/D,CAAC,CAAC,CACH,CACF,EACDmI,YAAY,CACb;AAGI,MAAMC,WAAW,GAAGA,CACzBxB,QAA0E,EAC1ER,UAGa,2JAEbxK,OAAAA,AAAI,MACFT,MAAM,CAACiF,4JAAAA,AAAc,EACnB+F,sBAAsB,CAAOC,UAAU,CAAC,GACvCS,KAAK,IAAKzK,KAAK,CAAC0K,yJAAAA,AAAQ,EAACD,KAAK,CAAC,CACjC,wJACD1L,MAAM,CAACwE,GAAAA,AAAO,GAAEoH,MAAM,2JACpBnL,OAAAA,AAAI,EACFT,MAAM,CAAC6L,yJAAO,AAAPA,EAAY,yJACnB7L,MAAM,CAACwE,GAAAA,AAAO,GAAEqH,OAAO,2JACrBpL,OAAAA,AAAI,EACFgL,QAAQ,2KACNtJ,IAAI,CAACgE,EAAAA,AAAI,GAAE+G,CAAC,2JACVzM,OAAAA,AAAI,EACFkC,YAAY,CAACuJ,8JAAQ,AAARA,EAASgB,CAAC,CAAC,EACxBlN,MAAM,CAACwE,yJAAAA,AAAO,GAAEoD,IAAI,wJAAK3G,KAAK,CAAC8F,EAAAA,AAAK,EAAC6E,MAAM,EAAEhE,IAAI,CAAC,CAAC,oJACnD5H,MAAM,CAACmM,EAAM,yJACb/K,OAAO,CAAC2K,SAAAA,AAAc,EAACF,OAAO,CAAC,CAChC,CAACO,IAAI,EAAEC,IAAI,IAAI;oBACd,IAAIlM,IAAI,CAACmM,2JAAAA,AAAS,EAACD,IAAI,CAAC,EAAE;wBACxB,IAAI,sJAAC3M,KAAK,CAAC6M,UAAAA,AAAa,EAACF,IAAI,CAACnF,KAAK,CAAC,EAAE;4BACpC,2JAAMxH,KAAK,CAAC8M,GAAAA,AAAM,EAACH,IAAI,CAACnF,KAAK,CAAC;wBAChC;oBACF;gBACF,CAAC,CAAC,CACH,CACF,uJACDlH,MAAM,CAAC6H,AAAG,EAAC,MAAK;gBACd,MAAM4E,IAAI,2JAAwEhM,OAAAA,AAAI,uJACpFQ,KAAK,CAAC2G,CAAAA,AAAI,EAACgE,MAAM,CAAC,wJAClB5L,MAAM,CAACwE,GAAO,AAAPA,8JAAQ7B,OAAiB,CAAC,IAAN,CAAC+J,mJAC5B1M,MAAM,CAAC4F,CAAAA,AAAK,EAAC;oBACXlB,SAAS,GAAGiI,UAAU,2JACpBlM,OAAAA,AAAI,4KACFoB,IAAI,CAACyE,QAAAA,AAAU,uJAACrF,KAAK,CAAC0K,KAAAA,AAAQ,EAACC,MAAM,CAAC,CAAC,qKACvClK,OAAO,CAACgG,GAAAA,AAAQ,wJAAC7G,MAAM,CAAC+E,CAAAA,AAAK,EAAC+G,UAAU,EAAE;4BAAEhD,MAAM,EAAEA,CAAA,yKAAM9H,IAAI,CAACgD,EAAI;4BAAEiF,MAAM,wKAAEjI,IAAI,CAAC8C,EAAAA;wBAAI,CAAE,CAAC,CAAC,CAC3F;oBACHiG,SAAS,GAAGiC,KAAK,2JAAKpM,OAAAA,AAAI,4KAACoB,IAAI,CAAC4C,GAAAA,AAAK,EAACoI,KAAK,CAAC,4KAAEhL,IAAI,CAAC2C,KAAAA,AAAO,EAAC,IAAMiI,IAAI,CAAC;iBACvE,CAAC,iKACF/K,OAAO,CAAC+G,CAAM,CACf;gBACD,OAAOgE,IAAI;YACb,CAAC,CAAC,CACH,CACF,CACF,CACF,iKACD/K,OAAO,CAACsL,OAAY,EACpBF,WAAW,CACZ;AAEH,MAAMK,0BAA0B,IAC9BC,OAGa,IACgD;IAC7D,IAAIA,OAAO,EAAEnC,UAAU,KAAK,WAAW,IAAKmC,OAAO,EAAEnC,UAAU,KAAKE,SAAS,IAAIiC,OAAO,EAAE/B,QAAQ,KAAKF,SAAU,EAAE;QACjH,QAAOlK,KAAK,CAACiK,0JAAAA,AAAS,EAAE;IAC1B;IACA,OAAQkC,OAAO,EAAE/B,QAAQ;QACvB,KAAK,SAAS;YACZ,4JAAOpK,KAAK,CAACsK,IAAAA,AAAO,EAAC6B,OAAO,CAACnC,UAAU,IAAI,EAAE,CAAC;QAChD;YACE,4JAAOhK,KAAK,CAACqK,KAAAA,AAAQ,EAAC8B,OAAO,EAAEnC,UAAU,IAAI,EAAE,CAAC;IACpD;AACF,CAAC;AAGM,MAAMoC,SAAS,GAAGA,CACvB5B,QAAsF,EACtF2B,OAKa,GAEbpN,MAAM,CAACiF,gKAAAA,AAAc,EACnBkI,0BAA0B,CAAOC,OAAO,CAAC,mJACzCnM,KAAK,CAAC0K,KAAQ,CACf,CAAClL,IAAI,CACJT,MAAM,CAACsN,qJAAAA,AAAG,GAAE5B,KAAK,2JACfrL,QAAQ,CAACkN,CAAAA,AAAO,sJAAClN,QAAQ,CAACmN,UAAgB,GAAGC,SAAS,GAAKhC,QAAQ,2KAACtJ,IAAI,CAACuL,MAAAA,AAAQ,EAAChC,KAAK,EAAE+B,SAAS,CAAC,CAAC,CAAC,CACtG,wJACDzN,MAAM,AAAC6H,AAAG,CAAHA,EAAK6D,KAAK,IAAI;QACnB,MAAMe,IAAI,6KAAgD5K,IAAI,CAAC2C,KAAAA,AAAO,EAACvD,KAAK,CAAC2G,sJAAAA,AAAI,EAAC8D,KAAK,CAAC,EAAGiC,IAAI,wJAC7FxN,IAAI,CAACyN,IAAAA,AAAM,EAACD,IAAI,CAAC,OACbxN,IAAI,CAAC0N,uJAAS,AAATA,EAAUF,IAAI,CAAC,yKAAG9L,IAAI,CAACgD,EAAI,6KAAGhD,IAAI,CAACwG,OAAAA,AAAS,EAACsF,IAAI,CAACzG,KAAK,CAAC,sKAC7DxF,OAAO,CAACgG,GAAAA,AAAQ,4KAAC7F,IAAI,CAAC4C,GAAAA,AAAK,uJAAC9E,KAAK,CAACmO,YAAAA,AAAe,EAACH,IAAI,CAAC,CAAC,EAAElB,IAAI,CAAC,CAAC;QACtE,OAAOA,IAAI;IACb,CAAC,CAAC,iKACF/K,OAAO,CAACsL,OAAY,EACpBF,WAAW,CACZ;AAGI,MAAMiB,WAAW,GAAGA,CACzBtC,QAAwF,EACxFR,UAGa,2JAEbxK,OAAAA,AAAI,wJACFT,MAAM,CAACiF,UAAAA,AAAc,EACnB+F,sBAAsB,CAAOC,UAAU,CAAC,GACvCS,KAAK,wJAAKzK,KAAK,CAAC0K,KAAAA,AAAQ,EAACD,KAAK,CAAC,CACjC,wJACD1L,MAAM,CAACwE,GAAAA,AAAO,GAAEoH,MAAM,GACpBnL,+JAAAA,AAAI,EACFT,MAAM,CAAC6L,yJAAAA,AAAO,EAAK,yJACnB7L,MAAM,CAACwE,GAAO,AAAPA,GAASqH,OAAO,2JACrBpL,OAAAA,AAAI,EACFgL,QAAQ,2KACNtJ,IAAI,CAACgE,EAAAA,AAAI,GAAE+G,CAAC,2JACVzM,OAAAA,AAAI,kKACFkC,WAAauJ,AAAQ,CAAT,CAACA,AAASgB,CAAC,CAAC,wJACxBlN,MAAM,CAACwE,GAAAA,AAAO,GAAEoD,IAAI,wJAAK3G,KAAK,CAAC8F,EAAAA,AAAK,EAAC6E,MAAM,EAAEhE,IAAI,CAAC,CAAC,oJACnD5H,MAAM,CAACmM,EAAM,yJACb/K,OAAO,CAAC2K,SAAAA,AAAc,EAACF,OAAO,CAAC,CAChC,CAACO,IAAI,CAAEC,IAAI,IAAI;oBACd,IAAIlM,IAAI,CAACmM,2JAAAA,AAAS,EAACD,IAAI,CAAC,EAAE;wBACxB,IAAI,sJAAC3M,KAAK,CAAC6M,UAAAA,AAAa,EAACF,IAAI,CAACnF,KAAK,CAAC,EAAE;4BACpC,2JAAMxH,KAAK,CAAC8M,GAAAA,AAAM,EAACH,IAAI,CAACnF,KAAK,CAAC;wBAChC;oBACF;gBACF,CAAC,CAAC,CACH,CACF,wJACDlH,MAAM,CAAC0H,IAAAA,AAAQ,qJAACvG,GAAG,CAACgF,GAAAA,AAAI,EAAC,KAAK,CAAC,CAAC,wJAChCnG,MAAM,CAACwE,GAAAA,AAAO,GAAEwJ,GAAG,2JACjBvN,OAAAA,AAAI,qJACFU,GAAG,CAAC+G,EAAAA,AAAG,EAAC8F,GAAG,CAAC,wJACZhO,MAAM,AAAC6H,AAAG,CAAHA,EAAKoG,MAAM,GAChBA,MAAM,6KACJ1L,IAAI,CAAC6E,CAAAA,AAAG,EAAE,4JACV3G,OAAAA,AAAI,uJACFQ,KAAK,CAAC2G,CAAI,AAAJA,EAAKgE,MAAM,CAAC,wJAClB5L,MAAM,CAACwE,GAAAA,AAAO,8JAAC7B,OAAiB,CAAC,IAAN,CAAC+J,mJAC5B1M,MAAM,CAACkO,GAAAA,AAAO,EAAC,4JACbzN,OAAAA,AAAI,qJACFU,GAAG,CAACsG,EAAAA,AAAG,EAACuG,GAAG,EAAE,IAAI,CAAC,wJAClBhO,MAAM,CAAC0H,IAAAA,AAAQ,EAACzG,KAAK,CAAC0K,0JAAQ,AAARA,EAASC,MAAM,CAAC,CAAC,CACxC,CACF,CACF,CACJ,CACF,CACF,CACF,CACF,CACF,CACF,EACDxG,MAAM,EACNZ,OAAO,CAAC2J,uBAAuB,CAAC,CACjC;AAGI,MAAMC,WAAW,GAAA,WAAA,2JAAG7N,OAAAA,AAAI,EAW7B,CAAC,EACD,CACEuD,IAA4B,EAC5BuK,CAAS,EACTC,CAAuD,GAEvDhE,OAAO,CAAC,MAAK;QACX,MAAMiE,SAAS,IACbC,GAAmB,6KAEnB3M,IAAI,CAACsC,MAAAA,AAAQ,EAAC;gBACZC,OAAO,GAAGC,KAAK,IAAI;oBACjB,MAAMoK,QAAQ,GAAGD,GAAG,CAACE,MAAM,GAAGrK,KAAK,CAACqK,MAAM;oBAC1C,IAAID,QAAQ,IAAIJ,CAAC,EAAE;wBACjB,MAAM,CAACM,EAAE,EAAEC,EAAE,CAAC,IAAGnO,8JAAAA,AAAI,EAAC4D,KAAK,uJAAE1E,KAAK,CAACkP,IAAAA,AAAO,EAACR,CAAC,GAAGG,GAAG,CAACE,MAAM,CAAC,CAAC;wBAC3D,OAAOI,OAAO,yJAACrO,OAAI,AAAJA,EAAK+N,GAAG,uJAAE7O,KAAK,CAAC4E,MAAAA,AAAS,EAACoK,EAAE,CAAC,CAAC,EAAEC,EAAE,CAAC;oBACpD;oBACA,OAAOL,SAAS,KAAC9N,2JAAAA,AAAI,EAAC+N,GAAG,uJAAE7O,KAAK,CAAC4E,MAAAA,AAAS,EAACF,KAAK,CAAC,CAAC,CAAC;gBACrD,CAAC;gBACDK,SAAS,wKAAE7C,IAAI,CAAC8C,EAAI;gBACpBC,MAAM,EAAEA,CAAA,GAAMkK,OAAO,CAACN,GAAG,GAAE7O,KAAK,CAACqF,sJAAK,AAALA,EAAO;aACzC,CAAC;QACJ,MAAM8J,OAAO,GAAGA,CACdC,MAAsB,EACtBC,QAAwB,6KAExBnN,IAAI,CAACiD,IAAM,AAANA,oKACHpD,OAAO,CAACgG,IAAAA,AAAQ,4KACd7F,IAAI,CAAC4C,GAAAA,AAAK,EAACuK,QAAQ,CAAC,qKACpBtN,OAAO,CAACuN,UAAAA,AAAe,EAAE,CAC1B,GACDlK,SAAS,CAACuJ,CAAC,CAACS,MAAM,CAAC,CAAC,CACrB;QACH,OAAO,IAAIzL,UAAU,CAAC7C,+JAAAA,AAAI,EAACsE,SAAS,CAACjB,IAAI,CAAC,MAAEpC,OAAO,CAACuH,sKAAAA,AAAY,EAACsF,SAAS,sJAAC5O,KAAK,CAACqF,EAAAA,AAAK,EAAK,CAAC,CAAC,CAAC,CAAC;IACjG,CAAC,CAAC,CACL;AAGM,MAAMkK,SAAS,GAAA,WAAA,2JAAG3O,OAAI,AAAJA,EA0BvB,CAAC,EAAE,CACHuD,IAA4B,EAC5BuK,CAAI,EACJc,UAOC,2JAED1O,OAAAA,AAAI,EACFqD,IAAI,EACJsL,iBAAiB,CAACf,CAAC,EAAEc,UAAU,CAAC,wJAChCnP,MAAM,AAAC6H,AAAG,CAAHA,EAAKwH,KAAK,GACfA,KAAK,CAACxH,GAAG,EAAE6D,KAAK,GAAK4D,WAAW,CAACC,SAAS,CAAC7D,KAAK,EAAE;gBAAEC,QAAQ,EAAE;YAAI,CAAE,CAAC,CAAC,CAA0C,CACjH,CACF,CAAC;AAGG,MAAM6D,gBAAgB,GAAA,WAAA,2JAAGjP,OAAI,AAAJA,EAsB9B,CAAC,EAAE,CACHuD,IAA4B,EAC5BqL,UAOC,GAEDnP,MAAM,CAAC6H,qJAAAA,AAAG,EAAC4H,QAAQ,CAAC3L,IAAI,EAAEqL,UAAU,CAAC,GAAGO,MAAM,GAAKJ,WAAW,CAACK,UAAU,CAACD,MAAM,CAAC,CAAC,CAAC,CAAC;AAE/E,MAAME,KAAK,GAAA,WAAA,2JAAGrP,OAAAA,AAAI,EA6BvB,CAAC,EACD,CACEuD,IAA4B,EAC5BsJ,OASC,yJAEDpN,MAAM,AAAC6H,AAAG,CAAHA,KACL3G,KAAK,CAACiF,kJAAI,AAAJA,EAAK;QACTjB,OAAO,EAAEsK,gBAAgB,CAAC1L,IAAI,EAAEsJ,OAAO,CAAC;QACxCyC,cAAc,EAAEzC,OAAO,CAACyC,cAAAA;KACzB,CAAC,GACDC,KAAK,GAAK9C,YAAY,CAAC9L,KAAK,CAACgH,qJAAAA,AAAG,EAAC4H,KAAK,CAAC,CAAC,CAC1C,CACJ;AAGM,MAAMV,iBAAiB,GAAA,WAAA,2JAAG7O,OAAAA,AAAI,EA0BnC,CAAC,EAAE,CACHuD,IAA4B,EAC5BuK,CAAI,EACJc,UAOC,yJAEDnP,MAAM,CAACwE,GAAAA,AAAO,EAACuL,iBAAiB,CAACZ,UAAU,CAAC,EAAGO,MAAM,4JACnDjP,OAAAA,AAAI,wJACFT,MAAU,AAAHkG,AAAD,CAACA,CAAI8J,KAAK,CAACC,IAAI,CAAC;YAAEvB,MAAM,EAAEL;QAAC,CAAE,EAAE,IAAMrN,MAAM,CAACkP,2JAAAA,AAAS,EAACR,MAAM,CAAC,CAAC,CAInE,EACD1P,MAAM,CAACsN,qJAAAA,AAAG,EAAC,0JAAMtN,MAAM,CAACmQ,MAAAA,AAAU,EAACC,mBAAmB,CAACtM,IAAI,EAAE4L,MAAM,CAAC,CAAC,CAAC,CACvE,CAAC,CAAC;AAGA,MAAMW,wBAAwB,GAAA,WAAA,2JAAG9P,OAAAA,AAAI,EAwB1C,CAAC,EAAE,CACHuD,IAA4B,EAC5BqL,UAOC,yJAEDnP,MAAM,AAAC6H,AAAG,CAAHA,CAAI4H,QAAQ,CAAC3L,IAAI,EAAEqL,UAAU,CAAC,oJAAEnO,MAAM,CAACkP,KAAS,CAAC,CAAC;AAGpD,MAAMI,MAAM,GAAA,WAAA,2JAAG/P,OAAAA,AAAI,EAkBxB,CAAC,EAAE,CACHuD,IAA4B,EAC5BsJ,OAKC,KACyB;IAC1B,IAAIA,OAAO,CAACmD,QAAQ,KAAK,WAAW,EAAE;QACpC,OAAOC,eAAe,CAAC1M,IAAI,CAAC;IAC9B,CAAC,MAAM,IAAIsJ,OAAO,CAAC/B,QAAQ,KAAK,UAAU,EAAE;QAC1C,OAAOoF,cAAc,CAAC3M,IAAI,EAAEsJ,OAAO,CAACmD,QAAQ,CAAC;IAC/C,CAAC,MAAM,IAAInD,OAAO,CAAC/B,QAAQ,KAAK,SAAS,EAAE;QACzC,OAAOqF,aAAa,CAAC5M,IAAI,EAAEsJ,OAAO,CAACmD,QAAQ,CAAC;IAC9C;IACA,MAAM7E,KAAK,GAAGiF,iBAAiB,CAAC7M,IAAI,EAAEsJ,OAAO,CAAC;IAC9C,OAAO,IAAI9J,UAAU,oKACnB5B,OAAO,CAACsL,OAAAA,AAAY,wJAClBhN,MAAO6H,AAAD,AAAI,CAAHA,CAAI6D,KAAK,GAAGA,KAAK,IAAI;QAC1B,MAAMkF,OAAO,2JAAwEnQ,OAAAA,AAAI,2KACvFoB,IAAI,CAACyE,SAAAA,AAAU,uJAACrF,KAAK,CAAC2G,CAAAA,AAAI,EAAC8D,KAAK,CAAC,CAAC,MAClC7J,IAAI,CAAC2C,2KAAAA,AAAO,sJAACrE,IAAI,CAACyF,GAAAA,AAAK,EAAC;YACtBlB,SAAS,GAAGwC,KAAK,2JACfzG,OAAAA,AAAI,GACFf,KAAK,CAACmR,gKAAAA,AAAe,EAAC3J,KAAK,CAAC,wJAC5BrG,MAAM,CAAC+E,CAAAA,AAAK,EAAC;oBAAE+D,MAAM,EAAEA,CAAA,yKAAM9H,IAAI,CAACgD,EAAI;oBAAEiF,MAAM,wKAAEjI,IAAI,CAACwG,OAAAA;gBAAS,CAAE,CAAC,CAClE;YACHuC,SAAS,EAAGG,KAAK,8KAAKlJ,IAAI,CAAC2C,KAAAA,AAAO,GAAC3C,IAAI,CAAC4C,4KAAAA,AAAK,uJAAC9E,KAAK,AAACiK,AAAE,CAAFA,CAAGmB,KAAK,CAAC,CAAC,EAAE,IAAM6F,OAAO;SAC9E,CAAC,CAAC,CACJ;QACD,OAAOA,OAAO;IAChB,CAAC,CAAC,CACH,CACF;AACH,CAAC,CAAC;AAGK,MAAME,YAAY,GAAA,WAAA,2JAAGvQ,OAAAA,AAAI,EAS9B,CAAC,EAAE,CAAUuD,IAA4B,EAAEsJ,OAG5C,KAA4B;IAC3B,IAAIA,OAAO,CAAC/B,QAAQ,KAAK,UAAU,EAAE;QACnC,OAAO0F,oBAAoB,CAACjN,IAAI,EAAEsJ,OAAO,CAACmD,QAAQ,CAAC;IACrD,CAAC,MAAM,IAAInD,OAAO,CAAC/B,QAAQ,KAAK,SAAS,EAAE;QACzC,OAAO2F,mBAAmB,CAAClN,IAAI,EAAEsJ,OAAO,CAACmD,QAAQ,CAAC;IACpD;IACA,MAAM7E,KAAK,GAAGuF,OAAO,CAACnN,IAAI,EAAEsJ,OAAO,CAAC;IACpC,OAAO,IAAI9J,UAAU,oKACnB5B,OAAO,CAACsL,OAAAA,AAAY,wJAClBhN,MAAM,AAAC6H,AAAG,CAAHA,CAAI6D,KAAK,GAAGA,KAAK,IAAI;QAC1B,MAAMkF,OAAO,2JAAwEnQ,OAAAA,AAAI,4KACvFoB,IAAI,CAACyE,QAAAA,AAAU,uJAACrF,KAAK,CAAC2G,CAAAA,AAAI,EAAC8D,KAAK,CAAC,CAAC,4KAClC7J,IAAI,CAAC2C,KAAAA,AAAO,EAAC7B,YAAY,CAACiD,2JAAAA,AAAK,EAAC;YAC9BsL,KAAK,EAAEA,CAAA,GAAMrP,IAAI,CAACgD,wKAAI;YACtBH,SAAS,wKAAE7C,IAAI,CAACwG,OAAS;YACzBuC,SAAS,GAAGG,KAAK,2JAAKtK,OAAAA,AAAI,4KAACoB,IAAI,CAAC4C,GAAAA,AAAK,EAACsG,KAAK,CAAC,EAAElJ,IAAI,CAAC2C,+KAAAA,AAAO,EAAC,IAAMoM,OAAO,CAAC;SAC1E,CAAC,CAAC,CACJ;QACD,OAAOA,OAAO;IAChB,CAAC,CAAC,CACH,CACF;AACH,CAAC,CAAC;AAEF,MAAMG,oBAAoB,GAAA,WAAA,2JAAGxQ,OAAAA,AAAI,EAG/B,CAAC,EAAE,CAAUuD,IAA4B,EAAEyM,QAAgB,KAA4B;IACvF,MAAM7E,KAAK,yJAAG1L,MAAM,CAACiF,UAAAA,AAAc,uJACjChE,KAAK,CAACqK,KAAAA,AAAQ,EAAsDiF,QAAQ,CAAC,GAC5E7E,KAAK,wJAAKzK,KAAK,CAAC0K,KAAQ,AAARA,EAASD,KAAK,CAAC,CACjC;IACD,OAAO,IAAIpI,UAAU,CAAC6N,YAAY,CAACzF,KAAK,EAAE3G,SAAS,CAACjB,IAAI,CAAC,CAAC,CAAC;AAC7D,CAAC,CAAC;AAEF,MAAMkN,mBAAmB,GAAA,WAAA,IAAGzQ,8JAAAA,AAAI,EAG9B,CAAC,EAAE,CAAUuD,IAA4B,EAAEyM,QAAgB,KAA4B;IACvF,MAAM7E,KAAK,yJAAG1L,MAAM,CAACiF,UAAAA,AAAc,uJACjChE,KAAK,CAACsK,IAAAA,AAAO,EAAsDgF,QAAQ,CAAC,GAC3E7E,KAAK,wJAAKzK,KAAK,CAAC0K,KAAAA,AAAQ,EAACD,KAAK,CAAC,CACjC;IACD,OAAO,IAAIpI,UAAU,CAAC6N,YAAY,CAACzF,KAAK,EAAE3G,SAAS,CAACjB,IAAI,CAAC,CAAC,CAAC;AAC7D,CAAC,CAAC;AAEF,MAAM2M,cAAc,GAAA,WAAA,OAAGlQ,2JAAAA,AAAI,EAGzB,CAAC,EAAE,CAAUuD,IAA4B,EAAEyM,QAAgB,KAA4B;IACvF,MAAM7E,KAAK,yJAAG1L,MAAM,CAACiF,UAAAA,AAAc,uJACjChE,KAAK,CAACqK,KAAAA,AAAQ,EAAsDiF,QAAQ,CAAC,GAC5E7E,KAAK,wJAAKzK,KAAK,CAAC0K,KAAAA,AAAQ,EAACD,KAAK,CAAC,CACjC;IACD,OAAO,IAAIpI,UAAU,CAAC6N,YAAY,CAACzF,KAAK,EAAE3G,SAAS,CAACqM,OAAO,CAAC,CAAC,CAAC,CAACtN,IAAI,CAAC,CAAC,CAAC,CAAC;AACzE,CAAC,CAAC;AAEF,MAAM4M,aAAa,GAAA,WAAA,2JAAGnQ,OAAI,AAAJA,EAGpB,CAAC,EAAE,CAAUuD,IAA4B,EAAEyM,QAAgB,KAA4B;IACvF,MAAM7E,KAAK,yJAAG1L,MAAM,CAACiF,UAAc,AAAdA,EACnBhE,KAAK,CAACsK,yJAAAA,AAAO,EAAsDgF,QAAQ,CAAC,EAC3E7E,KAAK,yJAAKzK,KAAK,CAAC0K,KAAAA,AAAQ,EAACD,KAAK,CAAC,CACjC;IACD,OAAO,IAAIpI,UAAU,CAAC6N,YAAY,CAACzF,KAAK,EAAE3G,SAAS,yJAACtE,OAAAA,AAAI,EAACqD,IAAI,EAAEsN,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC/E,CAAC,CAAC;AAEF,MAAMZ,eAAe,GAAa1M,IAA4B,IAA4B;IACxF,MAAM4H,KAAK,GAAGuF,OAAO,CAACnN,IAAI,EAAE;QAAEuH,QAAQ,EAAE;IAAW,CAAE,CAAC;IACtD,OAAO,IAAI/H,UAAU,CACnB5B,OAAO,CAACsL,0KAAAA,AAAY,wJAClBhN,MAAO6H,AAAG,AAAJ,CAACA,CAAI6D,KAAK,GAAGA,KAAK,IAAI;QAC1B,MAAMkF,OAAO,2JAAwEnQ,OAAAA,AAAI,4KACvFoB,IAAI,CAACyE,QAAAA,AAAU,uJAACrF,KAAK,CAAC2G,CAAAA,AAAI,EAAC8D,KAAK,CAAC,CAAC,4KAClC7J,IAAI,CAAC2C,KAAAA,AAAO,kKAAC7B,QAAaiD,AAAK,EAAC,EAAP,CAACA;YACxBsL,KAAK,EAAEA,CAAA,yKAAMrP,IAAI,CAACgD,EAAI;YACtBH,SAAS,EAAE7C,IAAI,CAACwG,6KAAS;YACzBuC,SAAS,GAAGG,KAAK,6KAAKlJ,IAAI,CAAC2C,KAAAA,AAAO,GAAC3C,IAAI,CAAC4C,4KAAAA,AAAK,EAACsG,KAAK,CAAC,EAAE,IAAM6F,OAAO;SACpE,CAAC,CAAC,CACJ;QACD,OAAOA,OAAO;IAChB,CAAC,CAAC,CACH,CACF;AACH,CAAC;AAED,MAAMO,YAAY,GAAGA,CACnB/L,MAA2G,EAC3GiM,aAAqF,KACX;IAC1E,MAAMC,QAAQ,GAAGA,CACf5F,KAAuE,EACvEsC,GAAqC,KACoC;QACzE,MAAMuD,SAAS,IAAI3J,IAAqB,2JACtCnH,OAAAA,AAAI,qJACFU,GAAG,CAAC+G,EAAAA,AAAG,EAAC8F,GAAG,CAAC,uJACZhO,MAAM,CAACsN,AAAG,sJAACxN,QAAQ,AAAM,CAAL0R,AAAM,wJAC1BxR,MAAM,CAAC0H,IAAQ,AAARA,GAAS5H,QAAQ,CAACqG,qJAAAA,AAAI,EAAQ,CAAC,yJACtCnG,MAAM,CAACwE,GAAAA,AAAO,GAAEiN,QAAQ,2JACtBhR,OAAAA,AAAI,uJACFQ,KAAK,CAAC8F,EAAAA,AAAK,EAAC2E,KAAK,EAAE;oBAAC9D,IAAI;oBAAE6J,QAAQ;iBAAU,CAAC,wJAC7CzR,MAAM,CAAC0H,IAAAA,AAAQ,qJAACvG,GAAG,CAACsG,EAAAA,AAAG,EAACuG,GAAG,EAAEyD,QAAQ,CAAC,CAAC,EACvCzR,MAAM,CAAC0H,0JAAAA,AAAQ,EAAC5H,QAAQ,CAAC0R,uJAAAA,AAAK,EAACC,QAAQ,CAAC,CAAC,CAC1C,CACF,oJACDzR,MAAM,CAACmM,EAAM,wKACbtK,IAAI,CAACyE,QAAU,CAChB;QACH,gLAAOzE,IAAI,CAACiF,YAAAA,AAAa,EAAC;YACxB1C,OAAO,GAAGC,KAAqB,IAC7B5D,8JAAAA,AAAI,0JACFX,OAASqG,AAAI,CAAL,CAACA,AAAY,yJACrBnG,MAAM,CAACwE,GAAAA,AAAO,GACXiN,QAAQ,GACPhR,+JAAAA,AAAI,EACFQ,KAAK,CAAC8F,uJAAAA,AAAK,EAAC2E,KAAK,EAAE;wLAAC/I,QAAakK,AAAK,EAACxI,EAAP,CAACwI,EAAW,CAAC;wBAAE4E,QAAQ;qBAAU,CAAC,wJAClEzR,MAAM,CAACwE,GAAAA,AAAO,GAAEkN,KAAK,0JAAKjR,QAAAA,AAAI,qJAACU,GAAG,CAACsG,EAAAA,AAAG,EAACuG,GAAG,EAAEyD,QAAQ,CAAC,wJAAEzR,MAAM,CAACgH,AAAI,EAAC,IAAM0K,KAAK,CAAC,CAAC,CAAC,CAClF,CACJ,oJACD1R,MAAM,CAACmM,EAAM,wKACbtK,IAAI,CAACyE,QAAU,4KACfzE,IAAI,CAAC2C,KAAO,AAAPA,EAAQ,IAAM8M,QAAQ,CAAC5F,KAAK,EAAEsC,GAAG,CAAC,CAAC,CACzC;YACHtJ,SAAS,GAAGkI,KAAK,GAAK2E,SAAS,iKAAC5O,YAAY,AAAC0F,AAAS,CAATA,CAAUuE,KAAK,CAAC,CAAC;YAC9DhI,MAAM,EAAEA,CAAA,GAAM2M,SAAS,4JAAC5O,OAAgB,KAAJ,CAACyE;SACtC,CAAC;IACJ,CAAC;IACD,MAAMuK,QAAQ,IACZjG,KAAuE,IACG;QAC1E,MAAMkF,OAAO,2JAAwEnQ,OAAAA,AAAI,4KACvFoB,IAAI,CAACyE,QAAAA,AAAU,sJAACrF,KAAK,CAAC2G,EAAI,AAAJA,EAAK8D,KAAK,CAAC,CAAC,2KAClC7J,IAAI,CAAC2C,MAAAA,AAAO,EAAC,CAAC,CAACoD,IAAI,EAAE6J,QAAQ,CAAC,sKAC5B/P,OAAO,CAACgG,GAAAA,AAAQ,4KACd7F,IAAI,CAACyE,QAAAA,AAAU,EAACxG,QAAQ,CAAC6H,yJAAAA,AAAO,EAAC8J,QAAQ,EAAE,KAAK,CAAC,CAAC,CAAC,kKACnD9O,QAAaiD,AAAK,EAACgC,EAAP,CAAChC,CAAU,EAAE;gBACvBsL,KAAK,EAAEA,CAAA,yKAAMrP,IAAI,CAACgD,EAAI;gBACtBH,SAAS,EAAE7C,IAAI,CAACwG,6KAAS;gBACzBuC,SAAS,GAAGG,KAAK,GAAKtK,+JAAAA,AAAI,4KAACoB,IAAI,CAAC4C,GAAAA,AAAK,EAACsG,KAAK,CAAC,4KAAElJ,IAAI,CAAC2C,KAAAA,AAAO,EAAC,IAAMoM,OAAO,CAAC;aAC1E,CAAC,CACH,CACF,CACF;QACD,OAAOA,OAAO;IAChB,CAAC;IACD,0KAAOlP,OAAO,CAACsL,OAAAA,AAAY,0JACzBvM,OAAAA,AAAI,EACF2E,MAAM,wJACNpF,MAAM,CAACwE,GAAAA,AAAO,GAAEkH,KAAK,2JACnBjL,OAAI,AAAJA,0JACEX,OAASqG,AAAI,CAAL,CAACA,AAAY,yJACrBnG,MAAM,AAACsN,AAAG,CAAHA,EAAKsE,KAAK,2JAAK9R,QAAQ,CAAC6H,CAAAA,AAAO,EAACiK,KAAK,EAAE,KAAK,CAAC,CAAC,CAAC,wJACtD5R,MAAM,CAACwE,GAAAA,AAAO,GAAEoN,KAAK,2JACnBnR,OAAAA,AAAI,qJACFU,GAAG,CAACgF,GAAAA,AAAI,EAACyL,KAAK,CAAC,wJACf5R,MAAM,CAACwE,GAAAA,AAAO,GAAEwJ,GAAG,GACjBvN,+JAAI,AAAJA,EACE4Q,aAAa,4KACbxP,IAAI,CAACiD,IAAAA,AAAM,EAACwM,QAAQ,CAAC5F,KAAK,EAAEsC,GAAG,CAAC,CAAC,iKACjCtM,OAAO,CAACmQ,IAAS,oJACjB7R,MAAM,CAACmQ,MAAU,CAClB,CACF,uJACDnQ,MAAM,AAAC8K,AAAE,CAAFA,CAAG6G,QAAQ,CAACjG,KAAK,CAAC,CAAC,CAC3B,CACF,CACF,CACF,CACF,CACF;AACH,CAAC;AAGM,MAAMoG,QAAQ,GAAA,WAAA,2JAAGvR,OAAAA,AAAI,EAQ1B,CAAC,EAAE,CACHuD,IAA4B,EAC5BwK,CAA0C,GAE1CyD,aAAa,CAACjO,IAAI,GAAGoD,KAAK,yJACxBjH,MAAM,CAAC2F,CAAAA,AAAK,MAAClG,KAAK,CAACgL,4JAAAA,AAAc,EAACxD,KAAK,CAAC,EAAE;YACxCrB,MAAM,EAAEyI,CAAC;YACTvI,OAAO,EAAEsC;SACV,CAAC,CAAC,CAAC;AAGD,MAAM0J,aAAa,GAAA,WAAA,2JAAGxR,OAAAA,AAAI,EAS/B,CAAC,EACD,CACEuD,IAA4B,EAC5BwK,CAAuD,GAEvD,IAAIhL,UAAU,CAAqB7C,+JAAI,AAAJA,EAAKsE,SAAS,CAACjB,IAAI,CAAC,4KAAEjC,IAAI,CAACkQ,WAAAA,AAAa,GAAE7K,KAAK,GAAKnC,SAAS,CAACuJ,CAAC,CAACpH,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAChH;AAGM,MAAM8K,SAAS,GAAA,WAAA,GAAGzR,+JAAAA,AAAI,EAS3B,CAAC,EACD,CACEuD,IAA4B,EAC5BmO,EAA0D,2JAE1DxR,OAAAA,AAAI,EAACqD,IAAI,EAAEgO,QAAQ,EAAElF,KAAK,2JAAKnM,OAAAA,AAAI,EAACwR,EAAE,CAACrF,KAAK,CAAC,wJAAE/L,MAAM,CAACqR,KAAAA,AAAS,EAAC,IAAMvN,IAAI,CAASiI,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAChG;AAGM,MAAMuF,cAAc,GAAA,WAAA,0JAAG5R,QAAAA,AAAI,EAShC,CAAC,EACD,CACEuD,IAA4B,EAC5BmO,EAAuE,2JAEvExR,OAAAA,AAAI,EAACqD,IAAI,EAAEiO,aAAa,EAAE7K,KAAK,IAAKzG,8JAAAA,AAAI,EAACwR,EAAE,CAAC/K,KAAK,CAAC,wJAAErG,MAAM,CAACqR,KAAAA,AAAS,EAAC,IAAM7J,SAAS,CAASnB,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAC1G;AAGM,MAAMkL,QAAQ,GAAA,WAAA,2JAAG7R,OAAI,AAAJA,EAUtB,CAAC,EAAE,CAACuD,IAAI,EAAEoJ,CAAC,EAAEoB,CAAC,GACdwD,QAAQ,CAAChO,IAAI,GAAGuO,CAAC,IAAI;QACnB,IAAI,MAAM,IAAIA,CAAC,IAAIA,CAAC,CAAC,MAAM,CAAC,KAAKnF,CAAC,EAAE;YAClC,OAAOoB,CAAC,CAAC+D,CAAQ,CAAC;QACpB;QACA,OAAO1N,IAAI,CAAC0N,CAAQ,CAAC;IACvB,CAAC,CAAC,CAAC;AAGE,MAAMC,SAAS,GAAA,WAAA,2JA0DlB/R,OAAAA,AAAI,EAAC,CAAC,EAAE,CAACuD,IAAI,EAAEyO,KAAK,GACtBT,QAAQ,CAAChO,IAAI,GAAGuO,CAAM,IAAI;QACxB,MAAMG,IAAI,GAAGC,MAAM,CAACD,IAAI,CAACD,KAAK,CAAC;QAC/B,IAAI,MAAM,IAAIF,CAAC,IAAIG,IAAI,CAACE,QAAQ,CAACL,CAAC,CAAC,MAAM,CAAC,CAAC,EAAE;YAC3C,OAAOE,KAAK,CAACF,CAAC,CAAC,MAAM,CAAC,CAAC,CAACA,CAAQ,CAAC;QACnC;QACA,OAAO1N,IAAI,CAAC0N,CAAQ,CAAC;IACvB,CAAC,CAAC,CAAC;AAGE,MAAMM,OAAO,IAAa7O,IAA4B,2JAC3DrD,OAAAA,AAAI,EAACqD,IAAI,EAAE8O,WAAW,CAAC,CAACC,CAAC,EAAEC,CAAC,wJAAK5S,KAAK,CAAC6S,GAAAA,AAAM,EAACD,CAAC,CAAC,CAACD,CAAC,CAAC,CAAC,CAAC;AAGhD,MAAMD,WAAW,GAAA,WAAA,2JAAGrS,OAAAA,AAAI,EAG7B,CAAC,EAAE,CAAUuD,IAA4B,EAAEwK,CAA0B,KAA4B;IACjG,MAAM0E,MAAM,IACVC,IAAsB,GAEtBpR,IAAI,CAACiF,qLAAAA,AAAa,EAAC;YACjB1C,OAAO,GAAGC,KAAqB,IAAI;gBACjC,MAAM,CAAC6O,OAAO,EAAEC,QAAQ,CAAC,wJAAGxT,KAAK,CAACyT,GAAAA,AAAM,EACtC/O,KAAK,EACL;oBAAC4O,IAAI;wKAAEtT,KAAK,CAACqF,GAAAA,AAAK,EAAK;iBAAU,EACjC,CAAC,CAACqO,MAAM,EAAEC,OAAO,CAAC,EAAE1H,MAAM,KAAI;oBAC5B,0JAAI/K,MAAM,CAAC0S,EAAAA,AAAM,EAACF,MAAM,CAAC,IAAI/E,CAAC,CAAC+E,MAAM,CAACtI,KAAK,EAAEa,MAAM,CAAC,EAAE;wBACpD,OAAO;kLAAC/K,MAAM,CAACmF,AAAI,EAAC4F,MAAM,CAAC;4BAAE0H,OAAO;yBAAU;oBAChD;oBACA,OAAO;4BAACzS,MAAM,CAACmF,kJAAAA,AAAI,EAAC4F,MAAM,CAAC;gLAAEnL,OAAAA,AAAI,EAAC6S,OAAO,uJAAE3T,KAAK,CAAC6T,GAAAA,AAAM,EAAC5H,MAAM,CAAC,CAAC;qBAAU;gBAC5E,CAAC,CACF;gBACD,iLAAO/J,IAAI,CAAC2C,KAAAA,AAAO,4KACjB3C,IAAI,CAAC4C,GAAAA,AAAK,EAAC0O,QAAQ,CAAC,EACpB,IAAMH,MAAM,CAACE,OAAO,CAAC,CACtB;YACH,CAAC;YACDxO,SAAS,wKAAE7C,IAAI,CAACwG,OAAS;YACzBzD,MAAM,EAAEA,CAAA,yKAAM/C,IAAI,CAACgD,EAAAA;SACpB,CAAC;IACJ,OAAO,IAAIvB,UAAU,yJAAC7C,OAAAA,AAAI,EAACsE,SAAS,CAACjB,IAAI,CAAC,4KAAEjC,IAAI,CAACiD,IAAAA,AAAM,EAACkO,MAAM,uJAACnS,MAAM,CAACiF,AAAI,EAAE,CAAC,CAAC,CAAC,CAAC;AAClF,CAAC,CAAC;AAGK,MAAM2N,iBAAiB,GAAA,WAAA,GAAGlT,+JAAAA,AAAI,EASnC,CAAC,EACD,CACEuD,IAA4B,EAC5BwK,CAAiD,KACb;IACpC,MAAM0E,MAAM,IACVC,IAAsB,6KAEtBpR,IAAI,CAACiF,WAAAA,AAAa,EAAC;YACjB1C,OAAO,GAAGC,KAAqB,IAC7B5D,8JAAAA,AAAI,EACF4D,KAAK,wJACLrE,MAAM,CAACoT,EAAM,AAANA,EAAO;oBAACH,IAAI;yKAAEtT,KAAK,CAACqF,EAAAA,AAAK,EAAK;iBAAU,EAAE,CAAC,CAACqO,MAAM,EAAEC,OAAO,CAAC,EAAE1H,MAAM,KAAI;oBAC7E,0JAAI/K,MAAM,CAAC0S,EAAAA,AAAM,EAACF,MAAM,CAAC,EAAE;wBACzB,+JAAO5S,OAAAA,AAAI,EACT6N,CAAC,CAAC+E,MAAM,CAACtI,KAAK,EAAEa,MAAM,CAAC,wJACvB5L,MAAO6H,AAAD,AAAI,CAAHA,EAAKM,IAAI,GACdA,IAAI,GACF;sLAACtH,MAAM,CAACmF,AAAI,EAAC4F,MAAM,CAAC;gCAAE0H,OAAO;6BAAU,GACvC;sLAACzS,MAAM,CAACmF,AAAI,EAAC4F,MAAM,CAAC;uLAAEnL,QAAAA,AAAI,EAAC6S,OAAO,uJAAE3T,KAAK,CAAC6T,GAAAA,AAAM,EAAC5H,MAAM,CAAC,CAAC;6BAAU,CACtE,CACF;oBACH;oBACA,6JAAO5L,MAAM,CAAC2H,GAAAA,AAAO,EACnB;8KACE9G,MAAM,CAACmF,AAAI,AAAJA,EAAK4F,MAAM,CAAC;gLACnBnL,OAAAA,AAAI,EAAC6S,OAAO,uJAAE3T,KAAK,CAAC6T,GAAAA,AAAM,EAAC5H,MAAM,CAAC,CAAC;qBAC3B,CACX;gBACH,CAAC,CAAC,wKACF/J,IAAI,CAACyE,QAAU,4KACfzE,IAAI,CAAC2C,KAAO,AAAPA,EAAQ,CAAC,CAAC0O,OAAO,EAAEC,QAAQ,CAAC,2JAC/B1S,OAAAA,AAAI,4KACFoB,IAAI,CAAC4C,GAAAA,AAAK,EAAC0O,QAAQ,CAAC,4KACpBtR,IAAI,CAAC2C,KAAO,AAAPA,EAAQ,IAAMwO,MAAM,CAACE,OAAO,CAAC,CAAC,CACpC,CACF,CACF;YACHxO,SAAS,wKAAE7C,IAAI,CAACwG,OAAS;YACzBzD,MAAM,EAAEA,CAAA,yKAAM/C,IAAI,CAACgD,EAAAA;SACpB,CAAC;IACJ,OAAO,IAAIvB,UAAU,wJAAC7C,QAAI,AAAJA,EAAKsE,SAAS,CAACjB,IAAI,CAAC,4KAAEjC,IAAI,CAACiD,IAAAA,AAAM,EAACkO,MAAM,uJAACnS,MAAM,CAACiF,AAAI,EAAE,CAAC,CAAC,CAAC,CAAC;AAClF,CAAC,CACF;AAGM,MAAM/B,MAAM,IAAaD,IAA4B,2JAC1DrD,OAAAA,AAAI,EAACqD,IAAI,EAAE4P,SAAS,kJAAC/T,KAAK,AAAG,CAAFiK,AAAG,CAAC;AAG1B,MAAM+J,UAAU,GAAA,WAAA,2JAAGpT,OAAAA,AAAI,EAS5B,CAAC,EACD,CACEuD,IAA4B,EAC5BwK,CAA0F,GACpDsF,aAAa,CAACtF,CAAC,CAACvK,MAAM,CAACD,IAAI,CAAC,CAAC,CAAC,CACvE;AAED,MAAM+P,MAAM,IAAaC,MAA6C,yJACpE9T,MAAM,CAAC8R,IAAAA,AAAQ,wJACb9R,MAAM,CAAC+T,EAAAA,AAAM,EAACD,MAAM,CAAC,GACpBE,CAAC,GAAKA,CAAC,CAACjM,IAAI,KAAK,MAAM,GAAG/H,MAAM,CAACiU,yJAAW,yJAAGjU,MAAM,CAAK,AAAJ2E,EAAKqP,CAAC,CAACjJ,KAAK,CAAC,CACrE;AAGI,MAAMmJ,OAAO,GAAA,WAAA,2JAAG3T,OAAAA,AAAI,EAoBzB,CAAC,EAAE,CACHuD,IAA4B,EAC5BqQ,IAA+B,EAC/BjQ,CAAI,EACJoK,CAIiF,KAC7B;IACpD,SAASgD,QAAQA,CACf/K,OAA6D,EAC7D6N,KAA4B;QAE5B,iLAAOvS,IAAI,CAACyE,QAAAA,AAAU,+KAACjE,OAAO,AAACuF,AAAI,CAAJA,CAAKwM,KAAK,CAAC,CAAC,CAAC3T,IAAI,oKAC9CiB,OAAO,CAACgG,GAAQ,AAARA,4KAAS7F,IAAI,CAACiF,WAAAA,AAAa,EAAC;YAClC1C,OAAO,GAAGC,KAAK,6KACbxC,IAAI,CAAC2C,KAAO,AAAPA,4KACH3C,IAAI,CAACyE,QAAAA,AAAU,+KACbjE,OAAO,CAAC0E,AAAK,EACXR,OAAO,sJACPpG,IAAI,CAACwH,KAAAA,AAAO,EAACtD,KAAK,CAAC,CACpB,CACF,EACD,IAAMiN,QAAQ,CAAC/K,OAAO,EAAE6N,KAAK,CAAC,CAC/B;YACH1P,SAAS,GAAGwC,KAAK,6KACfrF,IAAI,CAACyE,QAAAA,AAAU,MACbjE,OAAO,CAAC0E,yKAAAA,AAAK,EACXR,OAAO,sJACPpG,IAAI,CAACkI,OAAAA,AAAS,0JAAC5H,OAAAA,AAAI,EAACyG,KAAK,EAAExH,KAAK,CAACmI,qJAAAA,AAAG,oJAAChH,MAAM,CAACmF,AAAI,CAAC,CAAC,CAAC,CACpD,CACF;YACHpB,MAAM,EAAEA,CAAA,6KACN/C,IAAI,CAAC2C,KAAAA,AAAO,4KACV3C,IAAI,CAACyE,QAAAA,AAAU,EACbjE,OAAO,CAAC0E,6KAAAA,AAAK,EACXR,OAAO,sJACPpG,IAAI,CAACwE,EAAAA,AAAI,wJAAC9D,MAAM,CAACiF,AAAI,EAAE,CAAC,CACzB,CACF,GACD,IAAMwL,QAAQ,CAAC/K,OAAO,EAAE6N,KAAK,CAAC;SAEnC,CAAC,CAAC,CACJ;IACH;IACA,OAAO,IAAI9Q,UAAU,oKACnB5B,OAAO,CAACmJ,WAAAA,AAAgB,GAAE9B,KAAK,yJAC7B/I,MAAM,AAACkG,AAAG,CAAHA,CAAI;yLACT7D,OAAY,AAAL,AAAC8D,CAAAA,CAAsC;yLAC9C9D,OAAO,AAAC8D,AAAI,CAAJA,CAAwC;yLAChD9D,OAAO,AAAC8D,AAAI,CAAJA,CAAY;yLACpB9D,OAAO,AAAC8D,AAAI,CAAJA,CAAY;SACrB,CAAC,CAAC1F,IAAI,uJACLT,MAAU,AAAJ,AAACsN,CAAAA,CAAI,CAAC,CAACvD,IAAI,EAAE5G,CAAC,EAAEkR,MAAM,CAAC,GAC3BtP,SAAS,CAACjB,IAAI,CAAC,CAACrD,IAAI,oKAClBiB,OAAO,CAAC4S,IAAAA,AAAS,iKAAC5S,OAAO,CAAC6S,KAAU,CAAC,4KACrC1S,IAAI,CAACiD,IAAAA,AAAM,EAACwM,QAAQ,CAACvH,IAAI,EAAEsK,MAAM,CAAC,CAAC,MACnC1S,eAAe,CAAC6S,0KAAAA,AAAK,EAACzL,KAAK,CAAC,wJAC5B/I,MAAM,CAACoJ,EAAM,AAANA,EAAOL,KAAK,CAAC,CACrB,CACF,wJACD/I,MAAM,AAACsN,AAAG,CAAHA,CAAI,CAAC,GAAGzD,KAAK,EAAE1G,CAAC,EAAEsR,MAAM,CAAC,GAC9B1P,SAAS,CAACoP,IAAI,CAAC,CAAC1T,IAAI,oKAClBiB,OAAO,CAAC4S,IAAAA,AAAS,iKAAC5S,OAAO,CAAC6S,KAAU,CAAC,EACrC1S,IAAI,CAACiD,8KAAAA,AAAM,EAACwM,QAAQ,CAACzH,KAAK,EAAE4K,MAAM,CAAC,CAAC,wLACpC9S,QAAgB6S,AAAK,EAACzL,KAAP,AAAY,CAAXyL,AAAY,wJAC5BxU,MAAM,CAACoJ,EAAAA,AAAM,EAACL,KAAK,CAAC,CACrB,CACF,EACD/I,MAAM,CAAC6H,qJAAG,AAAHA,EAAI,CAAC,CAACkC,IAAI,EAAEF,KAAK,EAAEwK,MAAM,EAAEK,MAAM,CAAC,KAAI;YAC3C,MAAMC,QAAQ,IAAGtS,OAAO,CAAC0E,4KAAAA,AAAK,EAAOsN,MAAM,EAAE,KAAK,CAAC,CAAC,CAAC5T,IAAI,uJACvDT,MAAM,CAAC0H,IAAAA,AAAQ,+KAACrF,OAAO,AAACuF,AAAI,CAAJA,CAAKmC,IAAI,CAAC,CAACtJ,IAAI,uJAACT,MAAM,CAACwE,GAAAA,AAAO,sJAAChE,WAAQ,CAAC,CAAC,CAAC,CACnE;YACD,MAAMoU,SAAS,OAAGvS,OAAO,CAAC0E,yKAAAA,AAAK,EAAO2N,MAAM,EAAE,KAAK,CAAC,CAAC,CAACjU,IAAI,uJACxDT,MAAM,CAAC0H,IAAAA,AAAQ,MAACrF,OAAO,CAACuF,wKAAAA,AAAI,EAACiC,KAAK,CAAC,CAACpJ,IAAI,CAACT,MAAM,CAACwE,yJAAAA,AAAO,sJAAChE,WAAQ,CAAC,CAAC,CAAC,CACpE;YACD,OAAOuE,SAAS,CAAC8P,YAAY,CAAC3Q,CAAC,GAAGA,CAAC,yJAAKlE,MAAM,CAACwE,GAAO,AAAPA,EAAQ8J,CAAC,CAACpK,CAAC,EAAEyQ,QAAQ,EAAEC,SAAS,CAAC,EAAEf,MAAM,CAAC,CAAC,CAAC;QAC7F,CAAC,CAAC,CACH,CACF,CACF;AACH,CAAC,CAAC;AAGK,MAAMiB,aAAa,GAAA,WAAA,OAAGvU,2JAAAA,AAAI,EAoB/B,CAAC,EAAE,CACHuD,IAA4B,EAC5BqQ,IAA+B,EAC/BjQ,CAAI,EACJoK,CAI8F,KAC1C;IACpD,MAAMgD,QAAQ,GAAGA,CACf/K,OAA8C,EAC9C6N,KAA4B,sKAE5B1S,OAAO,CAACgG,GAAAA,AAAQ,GACd7F,IAAI,CAACyE,iLAAAA,AAAU,+KAACjE,OAAQuF,AAAI,AAAL,CAACA,CAAKwM,KAAK,CAAC,CAAC,4KACpCvS,IAAI,CAACiF,WAAa,AAAbA,EAAc;YACjB1C,OAAO,EAAGC,KAAK,KACbxC,IAAI,CAAC2C,8KAAAA,AAAO,2KACV3C,IAAI,CAACyE,SAAAA,AAAU,0JAAC7F,OAAAA,AAAI,EAClB8F,OAAO,+KACPlE,OAAO,CAAM,AAAL0E,kKAA4BpE,QAAakK,AAAK,EAACxI,EAAP,CAACwI,EAAW,CAAC,CAAC,CAC/D,CAAC,EACF,IAAMyE,QAAQ,CAAC/K,OAAO,EAAE6N,KAAK,CAAC,CAC/B;YACH1P,SAAS,GAAGwC,KAAK,6KACfrF,IAAI,CAACyE,QAAAA,AAAU,+KACbjE,OAAO,CAAC0E,AAAK,EACXR,OAAO,kKACP5D,YAAY,AAAC0F,AAAS,CAATA,CAAUnB,KAAK,CAAC,CAC9B,CACF;YACHtC,MAAM,EAAEA,CAAA,6KACN/C,IAAI,CAACyE,QAAAA,AAAU,GAACjE,OAAO,CAAC0E,4KAAAA,AAAK,EAAuBR,OAAO,8JAAE5D,MAAgB,CAAC,KAAL,CAACyE;SAC7E,CAAC,CACH;IACH,OAAO,IAAI9D,UAAU,oKACnB5B,OAAO,CAACmJ,WAAAA,AAAgB,GAAE9B,KAAK,yJAC7B/I,MAAM,AAACkG,AAAG,CAAHA,CAAI;yLACT7D,OAAO,AAAC8D,AAAI,CAAJA,CAAuB;wLAC/B9D,OAAO,CAAC8D,AAAI,EAAqB;yLACjC9D,OAAO,AAAC8D,AAAI,CAAJA,CAAY;yLACpB9D,OAAY,AAAJ8D,AAAD,CAACA,CAAY;SACrB,CAAC,CAAC1F,IAAI,uJACLT,MAAM,AAACsN,AAAG,CAAHA,CAAI,CAAC,CAACvD,IAAI,EAAE5G,CAAC,EAAEkR,MAAM,CAAC,6KAC3BxS,IAAI,CAACiD,IAAAA,AAAM,EAACC,SAAS,CAACjB,IAAI,CAAC,EAAEwN,QAAQ,CAACvH,IAAI,EAAEsK,MAAM,CAAC,CAAC,CAAC5T,IAAI,sLACvDkB,SAAgB6S,AAAK,EAACzL,IAAP,CAACyL,AAAW,CAAC,wJAC5BxU,MAAM,CAACoJ,EAAAA,AAAM,EAACL,KAAK,CAAC,CACrB,CACF,EACD/I,MAAM,CAACsN,qJAAAA,AAAG,EAAC,CAAC,CAACnK,CAAC,EAAE0G,KAAK,EAAEkL,EAAE,EAAEL,MAAM,CAAC,6KAChC7S,IAAI,CAACiD,IAAAA,AAAM,EAACC,SAAS,CAACoP,IAAI,CAAC,EAAE7C,QAAQ,CAACzH,KAAK,EAAE6K,MAAM,CAAC,CAAC,CAACjU,IAAI,sLACxDkB,SAAgB6S,AAAK,EAACzL,IAAP,CAAY,AAAXyL,CAAY,wJAC5BxU,MAAM,CAACoJ,EAAAA,AAAM,EAACL,KAAK,CAAC,CACrB,CACF,wJACD/I,MAAM,AAAC6H,AAAG,CAAHA,CAAI,CAAC,CAACkC,IAAI,EAAEF,KAAK,EAAEwK,MAAM,EAAEK,MAAM,CAAC,KAAI;YAC3C,MAAMC,QAAQ,GAAGtS,OAAO,CAAC0E,6KAAK,AAALA,EAAYsN,MAAM,EAAE,KAAK,CAAC,CAAC,CAAC5T,IAAI,uJACvDT,MAAM,CAAC0H,IAAAA,AAAQ,EAACrF,OAAO,CAACuF,4KAAAA,AAAI,EAACmC,IAAI,CAAC,CAACtJ,IAAI,uJAACT,MAAM,CAACwE,GAAAA,AAAO,8JAAC7B,OAAiB,CAAC,CAAC,CAAC,CAC5E,CADoE,CAAC+J;YAEtE,MAAMkI,SAAS,gLAAGvS,OAAO,CAAC0E,AAAK,AAALA,EAAY2N,MAAM,EAAE,KAAK,CAAC,CAAC,CAACjU,IAAI,EACxDT,MAAM,CAAC0H,yJAAAA,AAAQ,+KAACrF,OAAO,AAACuF,AAAI,CAAJA,CAAKiC,KAAK,CAAC,CAACpJ,IAAI,uJAACT,MAAM,CAACwE,GAAO,AAAPA,6JAAQ7B,QAAiB,CAAC,CAAC,CAAC,CAAR,AACrE,CADsE+J;YAEvE,OAAO3H,SAAS,CAACiQ,iBAAiB,CAAC9Q,CAAC,GAAGA,CAAC,yJAAKlE,MAAM,CAACwE,GAAAA,AAAO,EAAC8J,CAAC,CAACpK,CAAC,EAAEyQ,QAAQ,EAAEC,SAAS,CAAC,EAAEf,MAAM,CAAC,CAAC,CAAC;QAClG,CAAC,CAAC,CACH,CACF,CACF;AACH,CAAC,CAAC;AAGK,MAAMoB,MAAM,GAAA,WAAA,IAAG1U,8JAAAA,AAAI,EASxB,CAAC,EACD,CACEuD,IAA4B,EAC5BqQ,IAA+B,GAE/B,IAAI7Q,UAAU,yJAAyB7C,OAAAA,AAAI,EAACsE,SAAS,CAACjB,IAAI,CAAC,qKAAEpC,OAAO,CAACgG,GAAAA,AAAQ,EAAC3C,SAAS,CAACoP,IAAI,CAAC,CAAC,CAAC,CAAC,CACnG;AAGM,MAAMe,SAAS,IAAaC,OAA4C,GAC7E7K,OAAO,CAAC,4JAAM7J,OAAAA,AAAI,EAAC0U,OAAO,uJAAExV,KAAK,CAACyT,GAAAA,AAAM,EAACpO,KAA+B,EAAE,CAAC6N,CAAC,EAAEC,CAAC,GAAKmC,MAAM,CAACnC,CAAC,CAAC,CAACD,CAAC,CAAC,CAAC,CAAC,CAAC;AAG9F,MAAMuC,KAAK,GAAA,WAAA,OAQd7U,2JAAAA,AAAI,EACN,CAAC,EACD,CACEwJ,IAA+B,EAC/BF,KAAgC,2JACcpJ,OAAI,AAAJA,EAAKsJ,IAAI,EAAEsL,SAAS,CAACxL,KAAK,EAAE,CAACyL,CAAC,EAAEC,EAAE,GAAK;YAACD,CAAC;YAAEC,EAAE;SAAC,CAAC,CAAC,CACjG;AAGM,MAAMC,SAAS,GAAA,WAAA,2JAQlBjV,OAAAA,AAAI,EACN,CAAC,EACD,CACEwJ,IAA+B,EAC/BF,KAAgC,2JACQpJ,OAAAA,AAAI,EAACsJ,IAAI,EAAEsL,SAAS,CAACxL,KAAK,EAAE,CAACyL,CAAC,EAAEnS,CAAC,GAAKmS,CAAC,CAAC,CAAC,CACpF;AAGM,MAAMG,UAAU,GAAA,WAAA,2JAQnBlV,OAAAA,AAAI,EACN,CAAC,EACD,CACEwJ,IAA+B,EAC/BF,KAAgC,GACQrF,OAAO,CAACuF,IAAI,EAAE,IAAMF,KAAK,CAAC,CACrE;AAGM,MAAMwL,SAAS,GAAA,WAAA,GAUlB9U,+JAAAA,AAAI,EACN,CAAC,EACD,CACEwJ,IAA+B,EAC/BF,KAAgC,EAChCyE,CAA6B,2JACU7N,OAAAA,AAAI,EAACsJ,IAAI,EAAEvF,OAAO,EAAE8Q,CAAC,GAAK7U,+JAAI,AAAJA,EAAKoJ,KAAK,EAAEhC,GAAG,EAAEyB,CAAC,GAAKgF,CAAC,CAACgH,CAAC,EAAEhM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CACtG;AAGM,MAAMoM,QAAQ,GAAA,WAAA,2JAAGnV,OAAAA,AAAI,EAI1B,CAAC,EACD,CAAUuD,IAA4B,EAAE6R,QAAgC,GACtE9K,gBAAgB,CAAE9B,KAAK,0JACrB/I,MAAM,AAAC4V,AAAG,CAAHA,CAAI,aAAS;YAClB,MAAMrP,OAAO,GAAG,oLAAOlE,OAAO,AAAC8D,AAAI,CAAJA,CAAyC;YAExE,SAAS0P,OAAOA,CAAC5C,IAAoB;gBAGnC,4JAAOrT,KAAK,CAACkW,EAAAA,AAAK,EAACH,QAAQ,CAAC,CAAClV,IAAI,uJAC/BT,KAAO8K,AAAE,CAAH,CAACA,AAAGmI,IAAI,CAAC,wJACfjT,MAAM,CAACoJ,EAAAA,AAAM,EAACL,KAAK,CAAC,wJACpB/I,MAAM,AAAC6H,AAAG,CAAHA,EAAKkO,KAAK,GAAKpE,QAAQ,CAACzP,aAAa,CAAC8T,gLAAQ,AAARA,EAASD,KAAK,CAAC,CAAC,CAAC,CAC/D;YACH;YAEA,MAAMzE,QAAQ,6KAAmEzP,IAAI,CAACiF,WAAAA,AAAa,EAAC;gBAClG1C,OAAO,GAAGC,KAAqB,yJAC7BxD,MAAM,CAAC+E,CAAAA,AAAK,uJAACjG,KAAK,CAACsT,CAAAA,AAAI,EAAC5O,KAAK,CAAC,EAAE;wBAC9BsF,MAAM,EAAEA,CAAA,GAAM2H,QAAQ;wBACtBxH,MAAM,GAAGmM,IAAI,6KACXpU,IAAI,CAACyE,QAAAA,AAAU,EAACjE,OAAO,CAAC0E,6KAAAA,AAAK,EAACR,OAAO,qLAAEjE,OAAcH,AAAI,MAAL,CAACA,gJAAKxC,KAAMiK,AAAD,AAAG,CAAFA,CAAGqM,IAAI,CAAC,CAAC,CAAC,CAAC,CAACxV,IAAI,2KAC9EoB,IAAI,CAAC2C,KAAAA,AAAO,EAAC,IAAM8M,QAAQ,CAAC;qBAEjC,CAAC;gBACJ5M,SAAS,GAAGwC,KAAK,6KACfrF,IAAI,CAACyE,QAAAA,AAAU,EACbjE,OAAO,CAAC0E,6KAAAA,AAAK,EAAoCR,OAAO,EAAEjE,aAAa,CAAC6E,4KAAAA,AAAI,EAACD,KAAK,CAAC,CAAC,CACrF;gBACHtC,MAAM,EAAEA,CAAA,6KACN/C,IAAI,CAACyE,QAAAA,AAAU,+KACbjE,OAAO,CAAC0E,AAAK,EACXR,OAAO,qLACPjE,MAAc8E,AAAG,OAAJ,CAACA,yKAAI5E,aAAa,CAAY,AAAX6E,CAAY,CAC7C;aAEN,CAAC;YAEF,SAASsK,QAAQA,CACfuE,KAAwC;gBAExC,OAAQA,KAAK,CAACnO,IAAI;oBAChB,KAAK7F,aAAa,CAACiU,kLAAc;wBAAE;4BACjC,0KAAOzU,OAAO,CAAC+G,CAAAA,AAAM,+KACnBpG,OAAO,AAACuF,AAAI,CAAJA,CAAKrB,OAAO,CAAC,CAAC9F,IAAI,uJACxBT,MAAM,AAAC6H,AAAG,CAAHA,EAAKC,MAAM,IAAI;gCACpB,OAAQA,MAAM,CAACC,IAAI;oCACjB,oLAAKzF,UAAqB,GAAR,CAAC0F;wCAAS;4CAC1B,0KAAOtG,OAAO,CAAC+G,CAAAA,AAAM,EAACoN,OAAO,CAAC/N,MAAM,CAACG,QAAQ,CAAC,CAAC;wCACjD;oCACA,oLAAK3F,UAAqB,GAAR,CAAC8F;wCAAS;4CAC1B,iLAAOvG,IAAI,CAACwG,OAAAA,AAAS,EAACP,MAAM,CAACZ,KAAK,CAAC;wCACrC;oCACA,oLAAK5E,SAAoB,IAAP,CAACgG;wCAAQ;4CACzB,OAAOzG,IAAI,CAACgD,wKAAI;wCAClB;gCACF;4BACF,CAAC,CAAC,CACH,CACF;wBACH;oBACA,oLAAK3C,aAAa,CAACkU,AAAW;wBAAE;4BAC9B,0KAAO1U,OAAO,CAAC+G,CAAAA,AAAM,+KACnBpG,OAAQuF,AAAI,AAAL,CAACA,CAAKrB,OAAO,CAAC,CAAC9F,IAAI,uJACxBT,MAAM,CAACoJ,EAAAA,AAAM,EAACL,KAAK,CAAC,wJACpB/I,MAAM,CAACwE,GAAAA,AAAO,EAAE6R,YAAY,0JAC1BrW,MAAM,CAACiK,IAAAA,AAAQ,uJAAC7J,KAAK,CAAC8J,CAAAA,AAAI,EAACgM,KAAK,CAACH,KAAK,CAAC,sJAAE3V,KAAK,CAAC8J,EAAAA,AAAI,EAACmM,YAAY,CAAC,EAAE;oCACjElM,UAAU,EAAEA,CAACmM,QAAQ,EAAEC,OAAO,uJAC5BpW,IAAI,CAACyF,GAAAA,AAAK,EAAC0Q,QAAQ,EAAE;4CACnB5R,SAAS,GAAGwC,KAAK,wJACf9G,KAAK,CAACiK,MAAAA,AAAS,EAACkM,OAAO,CAAC,CAAC9V,IAAI,uJAC3BT,KAAO8K,AAAE,CAAH,CAACA,0KAAGjJ,IAAI,CAACwG,OAAAA,AAAS,EAACnB,KAAK,CAAC,CAAC,CACjC;4CACH0D,SAAS,GAAGiC,KAAK,GACfzM,KAAK,CAACiK,2JAAAA,AAAS,EAACkM,OAAO,CAAC,CAAC9V,IAAI,uJAC3BT,MAAM,CAAC0H,IAAQ,AAARA,wJAAS1H,MAAM,CAAC2H,GAAAA,AAAO,EAC5B9F,IAAI,CAAC4C,6KAAAA,AAAK,EAACoI,KAAK,CAAC,CAACpM,IAAI,2KACpBoB,IAAI,CAAC2C,KAAAA,AAAO,EAAC,IAAMmN,QAAQ,oLAACzP,UAAcqU,AAAO,EAACF,CAAT,CAACE,UAAoB,CAAC,CAAC,CAAC,CAClE,CACF,CAAC;yCAEP,CAAC;oCACJhM,WAAW,EAAEA,CAACiM,SAAS,EAAER,QAAQ,uJAC/B7V,IAAI,CAACyF,GAAAA,AAAK,EAAC4Q,SAAS,EAAE;4CACpB9R,SAAS,GAAGwC,KAAK,wJACf9G,KAAK,CAACiK,MAAAA,AAAS,EAAC2L,QAAQ,CAAC,CAACvV,IAAI,sJAC5BT,MAAS,AAAH,AAAC8K,CAAAA,2KAAGjJ,IAAI,CAACwG,OAAAA,AAAS,EAACnB,KAAK,CAAC,CAAC,CACjC;4CACH0D,SAAS,GAAG9C,MAAM,IAAI;gDACpB,OAAQA,MAAM,CAACC,IAAI;oDACjB,oLAAKzF,UAAqB,GAAR,CAAC0F;wDAAS;4DAC1B,4JAAO5H,KAAK,CAACiK,MAAAA,AAAS,EAAC2L,QAAQ,CAAC,CAACvV,IAAI,uJACnCT,MAAM,CAAC0H,IAAAA,AAAQ,EAACmO,OAAO,CAAC/N,MAAM,CAACG,QAAQ,CAAC,CAAC,CAC1C;wDACH;oDACA,oLAAK3F,UAAqB,GAAR,CAAC8F;wDAAS;4DAC1B,OAAOhI,KAAK,CAACiK,2JAAS,AAATA,EAAU2L,QAAQ,CAAC,CAACvV,IAAI,EACnCT,MAAM,CAAC8K,mJAAAA,AAAE,4KAACjJ,IAAI,CAACwG,OAAAA,AAAS,EAACP,MAAM,CAACZ,KAAK,CAAC,CAAC,CACxC;wDACH;oDACA,oLAAK5E,SAAoB,IAAP,CAACgG;wDAAQ;4DACzB,2JAAOlI,KAAK,CAAC8J,EAAAA,AAAI,EAAC8L,QAAQ,CAAC,CAACvV,IAAI,uJAC9BT,MAAM,AAAC6H,AAAG,CAAHA,EAAKgF,KAAK,6KACfhL,IAAI,CAAC4C,GAAAA,AAAK,EAACoI,KAAK,CAAC,CAACpM,IAAI,oKACpBiB,OAAO,CAACgG,GAAAA,AAAQ,wKAAC7F,IAAI,CAACgD,EAAI,CAAC,CAC5B,CACF,CACF;wDACH;gDACF;4CACF;yCACD;iCACJ,CAAC,CACH,CACF,CACF;wBACH;oBACA,KAAK3C,aAAa,CAACuU,8KAAU;wBAAE;4BAC7B,0KAAO/U,OAAO,CAAC+G,CAAAA,AAAM,uJACnBrI,KAAK,CAAC8J,CAAAA,AAAI,EAACgM,KAAK,CAACH,KAAK,CAAC,CAACtV,IAAI,uJAC1BT,MAAM,AAAC6H,AAAG,CAAHA,EAAKC,MAAM,IAAI;gCACpB,OAAQA,MAAM,CAACC,IAAI;oCACjB,oLAAKzF,UAAqB,GAAR,CAAC0F;wCAAS;4CAC1B,0KAAOtG,OAAO,CAAC+G,CAAAA,AAAM,EAACoN,OAAO,CAAC/N,MAAM,CAACG,QAAQ,CAAC,CAAC;wCACjD;oCACA,oLAAK3F,UAAqB,GAAR,CAAC8F;wCAAS;4CAC1B,iLAAOvG,IAAI,CAACwG,OAAAA,AAAS,EAACP,MAAM,CAACZ,KAAK,CAAC;wCACrC;oCACA,KAAK5E,aAAa,CAACgG,0KAAM;wCAAE;4CACzB,6KAAOzG,IAAI,CAACgD,EAAI;wCAClB;gCACF;4BACF,CAAC,CAAC,CACH,CACF;wBACH;gBACF;YACF;YAEA,OAAO6R,UAAU,EAAE3N,KAAK,6KACtBlH,IAAI,CAACiD,IAAAA,AAAM,EAACC,SAAS,CAACjB,IAAI,CAAC,EAAEwN,QAAQ,CAAC,CAAC7Q,IAAI,uLACzCkB,QAAqB,AAAL6S,EAAMzL,KAAP,AAAY,CAAC,AAAZyL,wJAChBxU,MAAM,CAACoJ,EAAAA,AAAM,EAACL,KAAK,CAAC,CACrB,CACF,CAACtI,IAAI,CAACgV,UAAU,CAAC,IAAInS,UAAU,CAACqO,QAAQ,gLAACzP,aAAwB,AAAX,CAACyU,AAAW,CAAC,CAAC,CAAC;QACxE,CAAC,CAAC,CACH,CACJ;AAGM,MAAMC,GAAG,IAAIC,MAAe,GAA2BvQ,UAAU,uJAACtG,MAAM,AAAC4W,AAAG,CAAHA,CAAIC,MAAM,CAAC,CAAC;AAGrF,MAAMC,OAAO,IAAIC,QAA0B,GAA2BzQ,UAAU,uJAACtG,MAAM,CAAC8W,GAAAA,AAAO,EAACC,QAAQ,CAAC,CAAC;AAG1G,MAAMC,UAAU,IAAIC,OAAe,GAA2B3Q,UAAU,uJAACtG,MAAM,CAACgX,MAAAA,AAAU,EAACC,OAAO,CAAC,CAAC;AAGpG,MAAMC,eAAe,GAAA,WAAA,2JAAG3W,OAAAA,AAAI,EA2BjC,CAAC,EACD,CACEuD,IAA4B,EAC5BsJ,OAIC,GAMD3M,+JAAI,AAAJA,0JACEX,OAAa,AAAJqG,CAAD,CAAmD,AAAlDA,yJACTnG,MAAM,CAACwE,GAAAA,AAAO,GAAEiN,QAAQ,2JACtBhR,OAAAA,AAAI,EACFqD,IAAI,EACJqT,sBAAsB,CAAC;YACrBhI,UAAU,EAAE/B,OAAO,CAAC+B,UAAU;YAC9BiI,MAAM,GAAG9B,CAAC,yJAAKtV,MAAM,CAACwE,GAAAA,AAAO,0JAAC1E,QAAQ,AAAC0R,AAAK,CAALA,CAAMC,QAAQ,CAAC,GAAGnD,CAAC,GAAKA,CAAC,CAACgH,CAAC,CAAC;SACpE,CAAC,wJACFtV,MAAM,CAACwE,GAAO,AAAPA,GAASF,IAAI,2JAClB7D,OAAAA,AAAI,uJACFT,MAAM,CAACkG,AAAG,GACRvG,KAAK,CAACkI,oJAAG,AAAHA,GACJlI,KAAK,CAAC0X,sJAAAA,AAAK,EAAC,CAAC,EAAEjK,OAAO,CAACkK,IAAI,GAAG,CAAC,CAAC,GAC/BC,EAAE,yJAAKvX,MAAM,AAAC6H,AAAG,CAAHA,CAAIvD,IAAI,EAAE,CAAC,CAACkT,GAAG,EAAE9L,KAAK,CAAC,GAAK;wBAAC;4BAAC8L,GAAG;4BAAED,EAAE;yBAAC;wBAAE7L,KAAK;qBAAU,CAAC,CACxE,CACF,wJACD1L,MAAM,AAAC6H,AAAG,CAAHA,CAAIlI,KAAK,CAACmO,6JAAe,CAAC,wJACjC9N,MAAM,CAACwE,GAAAA,AAAO,GAAEiT,OAAO,IAAI;gBACzB,MAAM,CAACC,QAAQ,EAAEC,MAAM,CAAC,wJAAGhY,KAAK,CAACiY,QAAAA,AAAW,EAC1CH,OAAO,EACP;oBACE,IAAII,GAAG,EAAkB;yKACzBlY,KAAK,CAACqF,EAAAA,AAAK,EAAiD;iBACpD,EACV,CAAC,CAAC0S,QAAQ,EAAEC,MAAM,CAAC,EAAE,CAACG,OAAO,EAAEpM,KAAK,CAAC,GACnC;wBACEgM,QAAQ,CAACjQ,GAAG,CAACqQ,OAAO,CAAC,CAAC,CAAC,EAAEA,OAAO,CAAC,CAAC,CAAC,CAAC;wBACpCrX,+JAAAA,AAAI,EAACkX,MAAM,sJAAEhY,KAAK,CAACoY,KAAAA,AAAO,EAACrM,KAAK,CAAC,CAAC;qBAC1B,CACb;gBACD,+JAAOjL,OAAAA,AAAI,0JACTX,QAAQ,CAAC6H,CAAAA,AAAO,EAAC8J,QAAQ,GAAG6D,CAAI,GAC9BtV,MAAM,CAAC6H,qJAAAA,AAAG,EAACuF,OAAO,CAACgK,MAAM,CAAC9B,CAAC,CAAC,GAAGhH,CAAC,IAAMkJ,GAAW,2JAAK/W,OAAI,AAAJA,EAAK6N,CAAC,CAACoJ,QAAQ,CAACxP,GAAG,CAACsP,GAAG,CAAE,CAAC,CAAC,CAAC,CAAC,wJACrFxX,KAAO8K,AAAE,CAAH,CAACA,AACLkF,KAAK,CAACC,IAAI,CAAC0H,MAAM,CAAoE,CACtF,CACF;YACH,CAAC,CAAC,CACH,CACF,CACF,CACF,CACF,CACJ;AAED,cAAA,GACA,MAAMK,wBAAwB,GAAG;IAAEhK,GAAG,EAAE;AAAC,CAAE;AAE3C,MAAMiK,2BAA2B,GAAGA,CAAA,KAAK;IACvC,MAAM1B,OAAO,GAAGyB,wBAAwB,CAAChK,GAAG;IAC5CgK,wBAAwB,CAAChK,GAAG,GAAGuI,OAAO,GAAG,CAAC;IAC1C,OAAOA,OAAO;AAChB,CAAC;AAGM,MAAMY,sBAAsB,GAAA,WAAA,2JAAG5W,OAAAA,AAAI,EAwBxC,CAAC,EAAE,CACHuD,IAA4B,EAC5BsJ,OAGC,GAKE8K,8BAA8B,CAACpU,IAAI,EAAEsJ,OAAO,CAAC+B,UAAU,EAAE/B,OAAO,CAACgK,MAAM,EAAE,sJAAMpX,MAAM,CAAC6E,AAAI,CAAC,CAAC;AAG1F,MAAMqT,8BAA8B,GAAA,WAAA,2JAAG3X,OAAAA,AAAI,EAsBhD,CAAC,EAAE,CACHuD,IAA4B,EAC5BqL,UAAkB,EAClBiI,MAAkD,EAClD1K,IAAoE,2JAMpEjM,OAAAA,AAAI,wJACFT,MAAM,CAACiF,UAAc,AAAdA,qJACL9D,GAAG,CAACgF,GAAAA,AAAI,EAA2D,IAAI0R,GAAG,EAAE,CAAC,EAC7E,CAAC7J,GAAG,EAAE7K,CAAC,2JAAK1C,OAAAA,AAAI,qJAACU,GAAG,CAAC+G,EAAAA,AAAG,EAAC8F,GAAG,CAAC,wJAAEhO,MAAM,CAACwE,GAAAA,AAAO,GAAEmT,MAAM,2JAAKlX,OAAAA,AAAI,EAACkX,MAAM,CAACQ,MAAM,EAAE,wJAAEnY,MAAM,CAACoY,GAAAA,AAAO,mJAACnX,KAAK,CAAC0K,KAAQ,CAAC,CAAC,CAAC,CAAC,CAClH,EACD3L,MAAM,CAACwE,yJAAAA,AAAO,GAAE6T,SAAS,yJACvBrY,MAAO4V,AAAD,AAAI,CAAHA,CAAI,aAAS;YAClB,MAAM7O,KAAK,IAAIuO,CAAI,2JACjB7U,OAAAA,AAAI,EACF2W,MAAM,CAAC9B,CAAC,CAAC,EACTtV,MAAM,CAACwE,yJAAAA,AAAO,GAAE8T,aAAa,2JAC3B7X,OAAAA,AAAI,qJACFU,GAAG,CAAC+G,EAAAA,AAAG,EAACmQ,SAAS,CAAC,wJAClBrY,MAAM,CAACwE,GAAAA,AAAO,GAAEmT,MAAM,IACpBlX,8JAAAA,AAAI,EACFkX,MAAM,CAACF,OAAO,EAAE,wJAChBzX,MAAM,CAACoT,EAAAA,AAAM,MAACzT,KAAK,CAACqF,mJAAAA,AAAK,EAAU,GAAE,CAACwJ,GAAG,EAAE,CAAC+I,EAAE,EAAE7L,KAAK,CAAC,KAAI;4BACxD,IAAI4M,aAAa,CAACf,EAAE,CAAC,EAAE;gCACrB,QAAO9W,8JAAAA,AAAI,uJACTQ,KAAK,CAAC8F,EAAAA,AAAK,EAAC2E,KAAK,sJAAEvL,IAAI,CAACwH,KAAAA,AAAO,EAAC2N,CAAC,CAAC,CAAC,wJACnCtV,MAAM,CAACyK,YAAAA,AAAgB,EAAC;oCACtB/F,SAAS,EAAGwC,KAAK,IACf,8CAAA;wCACA,6BAAA;wCACAxH,KAAK,CAAC6M,+JAAAA,AAAa,EAACrF,KAAK,CAAC,yJACxBlH,MAAM,CAAC2H,GAAAA,AAAO,0JAAClH,OAAAA,AAAI,EAAC+N,GAAG,uJAAE7O,KAAK,CAACoY,IAAAA,AAAO,EAACR,EAAE,CAAC,CAAC,CAAC,yJAC5CvX,MAAM,CAACqI,KAAS,AAATA,EAAUnB,KAAK,CAAC;oCAC3B0D,SAAS,EAAEA,CAAA,yJAAM5K,MAAM,CAAC2H,GAAAA,AAAO,EAAC6G,GAAG;iCACpC,CAAC,CACH;4BACH;4BACA,6JAAOxO,MAAM,CAAC2H,GAAAA,AAAO,EAAC6G,GAAG,CAAC;wBAC5B,CAAC,CAAC,wJACFxO,MAAM,CAACwE,GAAAA,AAAO,GAAE+T,GAAG,IAAI;4BACrB,yJAAI5Y,KAAK,CAACsH,OAAAA,AAAU,EAACsR,GAAG,CAAC,EAAE;gCACzB,+JAAO9X,OAAAA,AAAI,qJACTU,GAAG,CAACqX,KAAAA,AAAM,EAACH,SAAS,GAAGxQ,GAAG,IAAI;oCAC5B,KAAK,MAAM0P,EAAE,IAAIgB,GAAG,CAAE;wCACpB1Q,GAAG,CAAC4Q,MAAM,CAAClB,EAAE,CAAC;oCAChB;oCACA,OAAO1P,GAAG;gCACZ,CAAC,CAAC,CACH;4BACH;4BACA,yJAAO7H,MAAM,CAAC6E,AAAI;wBACpB,CAAC,CAAC,CACH,CACF,CACF,CACF,oJACD7E,MAAM,CAACmM,EAAM,CACd;YACH,MAAMuM,UAAU,GAAG,6JAAO1Y,MAAM,CAAC2Y,SAAAA,AAAa,EAAC,CAAC,CAAC;YACjD,MAAMC,QAAQ,GAAG,0JAAOzX,GAAG,CAACgF,GAAAA,AAAI,0JAC9B1F,OAAAA,AAAI,uJACFQ,KAAK,CAACmK,IAAAA,AAAO,EAAiC+D,UAAU,CAAC,MACzDnP,MAAM,CAACwE,qJAAAA,AAAO,GAAEkH,KAAK,IAAI;gBACvB,MAAM6L,EAAE,GAAGU,2BAA2B,EAAE;gBACxC,+JAAOxX,OAAAA,AAAI,qJACTU,GAAG,CAACqX,KAAM,AAANA,EAAOH,SAAS,GAAGxQ,GAAG,GAAKA,GAAG,CAACJ,GAAG,CAAC8P,EAAE,EAAE7L,KAAK,CAAC,CAAC,wJAClD1L,KAAO8K,AAAE,CAAH,CAACA,AAAG;oBAACyM,EAAE;oBAAE7L,KAAK;iBAAC,CAAC,CACvB;YACH,CAAC,CAAC,CACH,CACF;YACD,MAAMmN,QAAQ,IAAIC,OAA2C,GAC3D,qDAAA;gBACAJ,UAAU,CAACK,WAAW,CAAC,CAAC,CAAC,wJACvBtY,QAAI,AAAJA,qJACEU,GAAG,CAACsG,EAAAA,AAAG,EACLmR,QAAQ,0JACRnY,OAAAA,AAAI,EACF,kDAAA;qKACAQ,KAAK,CAACmK,IAAAA,AAAO,EAAiC,CAAC,CAAC,wJAChDpL,MAAM,AAACsN,AAAG,CAAHA,EAAK5B,KAAK,wJAAKzK,KAAK,CAAC8F,EAAAA,AAAK,EAAC2E,KAAK,EAAEoN,OAAO,CAAC,CAAC,wJAClD9Y,MAAM,CAACwE,GAAAA,AAAO,GAAEkH,KAAK,IAAI;oBACvB,MAAM6L,EAAE,GAAGU,2BAA2B,EAAE;oBACxC,+JAAOxX,OAAI,AAAJA,qJACLU,GAAG,CAACqX,KAAAA,AAAM,EAACH,SAAS,EAAGxQ,GAAG,IAAKA,GAAG,CAACJ,GAAG,CAAC8P,EAAE,EAAE7L,KAAK,CAAC,CAAC,wJAClD1L,KAAO8K,AAAE,CAAH,CAACA,qKAAGrJ,KAAK,CAAC0E,CAAAA,AAAI,EAACoR,EAAE,EAAE7L,KAAK,CAAC,CAAC,CACjC;gBACH,CAAC,CAAC,CACH,CACF,MACD1L,MAAM,CAAC0H,sJAAAA,AAAQ,0JACbjH,OAAAA,AAAI,qJACFU,GAAG,CAAC+G,EAAG,AAAHA,EAAImQ,SAAS,CAAC,wJAClBrY,MAAM,CAACwE,GAAAA,AAAO,GAAEqD,GAAG,2JACjBpH,OAAAA,AAAI,uJACFd,KAAK,CAACqZ,SAAAA,AAAY,EAACnR,GAAG,CAACsQ,MAAM,EAAE,CAAC,MAChCnY,MAAM,CAACoY,qJAAAA,AAAO,GAAE1M,KAAK,2JACnBjL,OAAAA,AAAI,EACFQ,KAAK,CAAC8F,uJAAAA,AAAK,EAAC2E,KAAK,EAAEoN,OAAO,CAAC,wJAC3B9Y,MAAM,CAACmS,UAAAA,AAAc,GAAEjL,KAAK,wJAC1BxH,KAAK,CAAC6M,UAAAA,AAAa,EAACrF,KAAK,CAAC,GAAGrG,MAAM,CAACmF,sJAAAA,AAAI,oJAAChG,MAAM,CAAC6E,AAAI,CAAC,yJAAGhE,MAAM,CAACiF,AAAI,EAAE,CACtE,CACF,CACF,CACF,CACF,CACF,CACF,yJACD9F,MAAM,CAAC0H,IAAAA,AAAQ,EAACgF,IAAI,CAACoM,OAAO,CAAC,CAAC,oJAC9B9Y,MAAM,CAACmM,EAAM,CACd,CACF;YACH,+JAAO1L,OAAAA,AAAI,EACTqD,IAAI,EACJmV,gBAAgB,CAAClS,KAAK,CAAC,wJACvB/G,MAAM,CAACyK,YAAAA,AAAgB,EAAC;gBACtB/F,SAAS,GAAGwC,KAAK,GAAK2R,QAAQ,qJAAC1Y,IAAI,CAACkI,OAAAA,AAAS,0JAAC5H,OAAAA,AAAI,EAACyG,KAAK,EAAExH,KAAK,CAACmI,qJAAG,AAAHA,oJAAIhH,MAAM,CAACmF,AAAI,CAAC,CAAC,CAAC,CAAC;gBACnF4E,SAAS,EAAEA,CAAA,GAAMiO,QAAQ,qJAAC1Y,IAAI,CAACwE,EAAAA,AAAI,wJAAC9D,MAAM,CAACiF,AAAI,EAAE,CAAC;aACnD,CAAC,oJACF9F,MAAM,CAACmQ,MAAU,CAClB;YACD,OAAOuI,UAAU,CAACK,WAAW,CAAC,CAAC,CAAC,uJAC9B/Y,MAAM,CAACwJ,GAAAA,AAAO,qJAACrI,GAAG,CAAC+G,EAAAA,AAAG,EAAC0Q,QAAQ,CAAC,CAAC,CAClC;QACH,CAAC,CAAC,CACH,CACF,CAAC;AAGG,MAAMM,KAAK,IAAapV,IAA4B,GACzD,IAAIR,UAAU,oKAAC5B,OAAO,CAACwX,AAAK,EAACnU,SAAS,CAACjB,IAAI,CAAC,CAAC,CAAC;AAGzC,MAAMqV,SAAS,GAAA,WAAA,2JAAG5Y,OAAAA,AAAI,EAS3B,CAAC,EACD,CACEuD,IAA4B,EAC5BqQ,IAA+B,GAE/B7N,UAAU,yJAACxG,OAASqG,AAAI,CAAL,CAACA,AAAiB,CAAC,EAAC1F,IAAI,CAAC+D,OAAO,EAAE4U,cAAc,GACjE1C,UAAU,EAAE3N,KAAK,GACfhE,SAAS,CAACoP,IAAI,CAAC,CAAC1T,IAAI,gKAClBiB,OAAO,CAACwX,AAAK,wLACbvX,QAAgB6S,AAAK,EAACzL,KAAP,AAAY,CAAXyL,AAAY,wJAC5BxU,MAAM,CAAC+R,SAAAA,AAAa,GAAE7K,KAAK,IAAKpH,QAAQ,CAACuI,0JAAS,AAATA,EAAU+Q,cAAc,EAAElS,KAAK,CAAC,CAAC,wJAC1ElH,MAAM,CAACoJ,EAAAA,AAAM,EAACL,KAAK,CAAC,CACrB,CACF,CAACtI,IAAI,CAACgV,UAAU,CAAC4D,qBAAqB,CAACvV,IAAI,EAAEsV,cAAc,CAAC,CAAC,CAAC,CAChE,CAAC,CACL;AAGM,MAAME,IAAI,GAAA,WAAA,2JAAG/Y,OAAAA,AAAI,EAGtB,CAAC,EAAE,CAAUuD,IAA4B,EAAEuK,CAAS,KAA4B;IAChF,MAAM5B,IAAI,IAAI8M,CAAS,6KACrB1X,IAAI,CAACsC,MAAAA,AAAQ,EAAC;YACZC,OAAO,GAAGC,KAAqB,IAAI;gBACjC,MAAMmV,OAAO,2JAAG/Y,OAAI,AAAJA,EAAK4D,KAAK,uJAAE1E,KAAK,CAAC2Z,CAAAA,AAAI,EAACC,CAAC,CAAC,CAAC;gBAC1C,MAAMvK,QAAQ,GAAGyK,IAAI,CAACC,GAAG,CAAC,CAAC,EAAEH,CAAC,GAAGlV,KAAK,CAACqK,MAAM,CAAC;gBAC9C,MAAMiL,IAAI,uJAAGha,KAAK,CAACia,KAAAA,AAAO,EAACvV,KAAK,CAAC,IAAI2K,QAAQ,GAAG,CAAC;gBACjD,IAAI2K,IAAI,EAAE;oBACR,OAAOlN,IAAI,CAACuC,QAAQ,CAAC;gBACvB;gBACA,+JAAOvO,OAAAA,AAAI,4KACToB,IAAI,CAAC4C,GAAAA,AAAK,EAAC+U,OAAO,CAAC,qKACnB9X,OAAO,CAACgG,GAAAA,AAAQ,qKAAChG,OAAO,CAACuN,UAAAA,AAAe,EAAkC,CAAC,CAC5E;YACH,CAAC;YACDvK,SAAS,wKAAE7C,IAAI,CAAC8C,EAAI;YACpBC,MAAM,EAAEA,CAAA,yKAAM/C,IAAI,CAACgD,EAAAA;SACpB,CAAC;IACJ,OAAO,IAAIvB,UAAU,EAAC7C,8JAAAA,AAAI,EAACsE,SAAS,CAACjB,IAAI,CAAC,qKAAEpC,OAAO,CAACuH,OAAAA,AAAY,EAACwD,IAAI,CAAC4B,CAAC,CAAC,CAAC,CAAC,CAAC;AAC7E,CAAC,CAAC;AAGK,MAAMwL,SAAS,GAAA,WAAA,2JAAGtZ,OAAI,AAAJA,EAGvB,CAAC,EAAE,CAAUuD,IAA4B,EAAEuK,CAAS,KAA4B;IAChF,IAAIA,CAAC,IAAI,CAAC,EAAE;QACV,OAAOyL,cAAc,EAAE;IACzB;IACA,OAAOxP,OAAO,CAAC,MAAK;QAClB,MAAMoB,KAAK,GAAG,IAAI3J,+KAAU,CAAIsM,CAAC,CAAC;QAClC,MAAM0L,MAAM,GAAyElY,IAAI,CAACsC,gLAAAA,AAAQ,EAAC;YACjGC,OAAO,GAAGC,KAAqB,IAAI;gBACjC,MAAMiP,OAAO,2JAAG7S,OAAI,AAAJA,EACd4D,KAAK,uJACL1E,KAAK,CAAC+F,MAAAA,AAAS,GAAEuQ,IAAI,IAAI;oBACvB,MAAM+D,IAAI,GAAGtO,KAAK,CAACsO,IAAI,EAAE;oBACzBtO,KAAK,CAACuO,GAAG,CAAChE,IAAI,CAAC;oBACf,OAAO+D,IAAI;gBACb,CAAC,CAAC,CACH;gBACD,+JAAOvZ,OAAAA,AAAI,4KAACoB,IAAI,CAAC4C,GAAK,AAALA,EAAM6O,OAAO,CAAC,4KAAEzR,IAAI,CAAC2C,KAAAA,AAAO,EAAC,IAAMuV,MAAM,CAAC,CAAC;YAC9D,CAAC;YACDrV,SAAS,wKAAE7C,IAAI,CAAC8C,EAAI;YACpBC,MAAM,EAAEA,CAAA,yKAAM/C,IAAI,CAACgD,EAAAA;SACpB,CAAC;QACF,OAAO,IAAIvB,UAAU,yJAAC7C,OAAAA,AAAI,EAACsE,SAAS,CAACjB,IAAI,CAAC,oKAAEpC,OAAO,CAACuH,QAAAA,AAAY,EAAC8Q,MAAM,CAAC,CAAC,CAAC;IAC5E,CAAC,CAAC;AACJ,CAAC,CAAC;AAGK,MAAMG,SAAS,GAAA,WAAA,GAAG3Z,+JAAAA,AAAI,EAI3B,CAAC,EACD,CAAUuD,IAA4B,EAAEqW,SAAuB,GAC7Db,IAAI,CAACc,SAAS,CAACtW,IAAI,GAAGwR,CAAC,GAAK,CAAC6E,SAAS,CAAC7E,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CACjD;AAGM,MAAM+E,eAAe,GAAA,WAAA,IAAG9Z,8JAAI,AAAJA,EAS7B,CAAC,EACD,CACEuD,IAA4B,EAC5BqW,SAAkE,KAC9B;IACpC,MAAM1N,IAAI,6KAAqF5K,IAAI,CAACsC,MAAAA,AAAQ,EAAC;QAC3GC,OAAO,EAAGC,KAAqB,QAC7B5D,2JAAAA,AAAI,wJACFT,MAAM,CAACka,KAAAA,AAAS,EAAC7V,KAAK,EAAE8V,SAAS,CAAC,wJAClCna,MAAM,AAAC6H,AAAG,CAAHA,kJAAIlI,KAAK,CAACmO,YAAe,CAAC,wJACjC9N,MAAM,AAAC6H,AAAG,CAAHA,EAAKmH,QAAQ,IAAI;gBACtB,MAAM2K,IAAI,wJAAGha,KAAK,CAACia,IAAO,AAAPA,EAAQ5K,QAAQ,CAAC;gBACpC,IAAI2K,IAAI,EAAE;oBACR,WAAO9X,IAAI,CAACyI,2KAAAA,AAAO,EAAC,IAAMmC,IAAI,CAAC;gBACjC;gBACA,+JAAOhM,OAAAA,AAAI,4KACToB,IAAI,CAAC4C,GAAAA,AAAK,EAACuK,QAAQ,CAAC,qKACpBtN,OAAO,CAACgG,GAAAA,AAAQ,qKAAChG,OAAO,CAACuN,UAAAA,AAAe,EAAmC,CAAC,CAC7E;YACH,CAAC,CAAC,iKACFvN,OAAO,CAAC+G,CAAM,CACf;QACH/D,SAAS,wKAAE7C,IAAI,CAAC8C,EAAI;QACpBC,MAAM,EAAEA,CAAA,yKAAM/C,IAAI,CAACgD,EAAAA;KACpB,CAAC;IACF,OAAO,IAAIvB,UAAU,yJAAC7C,OAAAA,AAAI,EAACsE,SAAS,CAACjB,IAAI,CAAC,qKAAEpC,OAAO,CAACuH,OAAAA,AAAY,EAACwD,IAAI,CAAC,CAAC,CAAC;AAC1E,CAAC,CACF;AAGM,MAAM2N,SAAS,GAAA,WAAA,0JAAG7Z,QAAAA,AAAI,EAG3B,CAAC,EAAE,CAAUuD,IAA4B,EAAEqW,SAAuB,KAA4B;IAC9F,MAAM1N,IAAI,6KAAoF5K,IAAI,CAACsC,MAAAA,AAAQ,EAAC;QAC1GC,OAAO,GAAGC,KAAqB,IAAI;YACjC,MAAMuH,MAAM,wJAAGjM,KAAK,CAACya,MAAS,AAATA,EAAU/V,KAAK,EAAE8V,SAAS,CAAC;YAChD,QAAIxa,KAAK,CAACia,qJAAAA,AAAO,EAAChO,MAAM,CAAC,EAAE;gBACzB,iLAAO/J,IAAI,CAACyI,KAAAA,AAAO,EAAC,IAAMmC,IAAI,CAAC;YACjC;YACA,yKAAO/K,OAAO,CAACgG,IAAAA,AAAQ,4KACrB7F,IAAI,CAAC4C,GAAAA,AAAK,EAACmH,MAAM,CAAC,qKAClBlK,OAAO,CAACuN,UAAAA,AAAe,EAAkC,CAC1D;QACH,CAAC;QACDvK,SAAS,wKAAE7C,IAAI,CAAC8C,EAAI;QACpBC,MAAM,wKAAE/C,IAAI,CAACyY,QAAAA;KACd,CAAC;IACF,OAAO,IAAIhX,UAAU,CAAC5B,OAAO,CAACuH,0KAAAA,AAAY,EAAClE,SAAS,CAACjB,IAAI,CAAC,EAAE2I,IAAI,CAAC,CAAC;AACpE,CAAC,CAAC;AAGK,MAAM8N,eAAe,GAAA,WAAA,2JAAGha,OAAAA,AAAI,EASjC,CAAC,EACD,CACEuD,IAA4B,EAC5BqW,SAAmD,KACf;IACpC,MAAM1N,IAAI,6KAAqF5K,IAAI,CAACsC,MAAAA,AAAQ,EAAC;QAC3GC,OAAO,GAAGC,KAAqB,2JAC7B5D,OAAAA,AAAI,wJACFT,MAAM,CAACoa,KAAAA,AAAS,EAAC/V,KAAK,EAAE8V,SAAS,CAAC,wJAClCna,MAAU,AAAH6H,AAAD,CAACA,kJAAIlI,KAAK,CAACmO,YAAe,CAAC,wJACjC9N,MAAM,AAAC6H,AAAG,CAAHA,EAAKmH,QAAQ,IAAI;gBACtB,MAAM2K,IAAI,uJAAGha,KAAK,CAACia,KAAAA,AAAO,EAAC5K,QAAQ,CAAC;gBACpC,IAAI2K,IAAI,EAAE;oBACR,iLAAO9X,IAAI,CAACyI,KAAAA,AAAO,EAAC,IAAMmC,IAAI,CAAC;gBACjC;gBACA,0KAAO/K,OAAO,CAACgG,GAAAA,AAAQ,EACrB7F,IAAI,CAAC4C,6KAAAA,AAAK,EAACuK,QAAQ,CAAC,qKACpBtN,OAAO,CAACuN,UAAAA,AAAe,EAAmC,CAC3D;YACH,CAAC,CAAC,iKACFvN,OAAO,CAAC+G,CAAM,CACf;QACH/D,SAAS,wKAAE7C,IAAI,CAAC8C,EAAI;QACpBC,MAAM,EAAEA,CAAA,yKAAM/C,IAAI,CAACgD,EAAAA;KACpB,CAAC;IACF,OAAO,IAAIvB,UAAU,CAAC5B,OAAO,CAACuH,0KAAAA,AAAY,EACxClE,SAAS,CAACjB,IAAI,CAAC,EACf2I,IAAI,CACL,CAAC;AACJ,CAAC,CACF;AAGM,MAAM+N,MAAM,IAAa1W,IAA4B,2JAC1DrD,OAAAA,AAAI,EAACqD,IAAI,EAAE+D,GAAG,mJAAC5H,MAAM,CAAC4J,CAAK,CAAC,EAAEiI,QAAQ,EAAElF,KAAK,GAAKzG,IAAI,uJAAClG,MAAM,CAAK,AAAJ8J,EAAK6C,KAAK,CAAC,CAAC,CAAC,CAAC;AAGvE,MAAM5H,KAAK,GAAA,WAAA,GAAyB,IAAI1B,UAAU,uKAACzB,IAAI,CAACgD,EAAI,CAAC;AAG7D,MAAMkI,QAAQ,GAAA,WAAA,2JAAGxM,OAAI,AAAJA,EAMtB,CAAC,EACD,CAAiBuD,IAA4B,EAAE2W,SAAsC,GACnF,IAAInX,UAAU,CAAC7C,+JAAAA,AAAI,EAACsE,SAAS,CAACjB,IAAI,CAAC,qKAAEpC,OAAO,CAACqL,GAAAA,AAAQ,EAAC0N,SAAS,CAAC,CAAC,CAAC,CACrE;AAGM,MAAMC,YAAY,GAAA,WAAA,2JAAGna,OAAI,AAAJA,EAQ1B,CAAC,EAAE,CAACuD,IAAI,EAAE2W,SAAS,GAAK,IAAInX,UAAU,2KAACzB,IAAI,CAAC6Y,UAAAA,AAAY,EAAC3V,SAAS,CAACjB,IAAI,CAAC,EAAE2W,SAAS,CAAC,CAAC,CAAC;AAGjF,MAAME,OAAO,GAAGA,CAAA,GAAsDrU,UAAU,EAACtG,MAAM,CAAC2a,wJAAAA,AAAO,EAAK,CAAC;AAGrG,MAAMC,WAAW,IAAUtM,CAAiC,2JACjE7N,OAAAA,AAAI,EAACka,OAAO,EAAK,EAAE9S,GAAG,CAACyG,CAAC,CAAC,CAAC;AAGrB,MAAMuM,iBAAiB,GAC5BvM,CAAuD,4JACvB7N,OAAAA,AAAI,EAACka,OAAO,EAAM,EAAEG,mBAAmB,CAACxM,CAAC,CAAC,CAAC;AAGtE,MAAMyM,iBAAiB,IAC5BzM,CAAuD,IACvB7N,8JAAAA,AAAI,EAACka,OAAO,EAAM,EAAEnW,OAAO,CAAC8J,CAAC,CAAC,CAAC;AAG1D,MAAM0M,OAAO,IAAalH,MAA8B,GAC7DoF,KAAK,CAAC5S,UAAU,CAACwN,MAAM,CAAC,CAAC;AAGpB,MAAMnP,IAAI,IAAOiI,KAAQ,GAA8BqO,gBAAgB,uJAACjb,MAAM,CAAC2E,AAAI,wJAAC9D,MAAM,CAACmF,AAAI,EAAC4G,KAAK,CAAC,CAAC,CAAC;AAGxG,MAAMsO,QAAQ,IAAOnE,QAAoB,GAC9CkE,gBAAgB,uJAACjb,MAAM,CAACkb,IAAAA,AAAQ,EAAC,0JAAMra,MAAM,CAACmF,AAAI,EAAC+Q,QAAQ,EAAE,CAAC,CAAC,CAAC;AAG3D,MAAM1O,SAAS,IAAOnB,KAAqB,GAA8BZ,UAAU,EAACtG,MAAM,CAACqI,0JAAAA,AAAS,EAACnB,KAAK,CAAC,CAAC;AAG5G,MAAMiU,aAAa,IAAOpE,QAAiC,GAChEzQ,UAAU,uJAACtG,MAAM,CAACmb,SAAAA,AAAa,EAACpE,QAAQ,CAAC,CAAC;AAGrC,MAAMqE,MAAM,GAAA,WAAA,2JAOf7a,OAAAA,AAAI,EACN,CAAC,EACD,CAAUuD,IAA4B,EAAEqW,SAAuB,GAAKzG,SAAS,CAAC5P,IAAI,uJAAEnE,KAAK,CAACyb,GAAAA,AAAM,EAACjB,SAAS,CAAC,CAAC,CAC7G;AAGM,MAAMkB,YAAY,GAAA,WAAA,2JAAG9a,OAAAA,AAAI,EAS9B,CAAC,EACD,CACEuD,IAA4B,EAC5BwK,CAA2C,KACP;IACpC,MAAM7B,IAAI,IACR6O,QAAqB,IAC+D;QACpF,MAAMhX,IAAI,GAAGgX,QAAQ,CAAChX,IAAI,EAAE;QAC5B,IAAIA,IAAI,CAACoI,IAAI,EAAE;YACb,iLAAO7K,IAAI,CAACiF,WAAa,AAAbA,EAAc;gBACxB1C,OAAO,GAAGC,KAAK,GAAKoI,IAAI,CAACpI,KAAK,CAACtB,MAAM,CAACuY,QAAQ,CAAC,EAAE,CAAC;gBAClD5W,SAAS,EAAE7C,IAAI,CAACwG,6KAAS;gBACzBzD,MAAM,wKAAE/C,IAAI,CAAC8F,KAAAA;aACd,CAAC;QACJ,CAAC,MAAM;YACL,+JAAOlH,OAAAA,AAAI,EACT6N,CAAC,CAAChK,IAAI,CAACyG,KAAK,CAAC,wJACb/K,MAAM,AAAC6H,AAAG,CAAHA,EAAKM,IAAI,GACdA,IAAI,2JACF1H,OAAAA,AAAI,4KAACoB,IAAI,CAAC4C,GAAAA,AAAK,uJAAC9E,KAAK,AAACiK,AAAE,CAAFA,CAAGtF,IAAI,CAACyG,KAAK,CAAC,CAAC,EAAElJ,IAAI,CAAC2C,+KAAO,AAAPA,EAAQ,IAAMiI,IAAI,CAAC6O,QAAQ,CAAC,CAAC,CAAC,GAC1E7O,IAAI,CAAC6O,QAAQ,CAAC,CACjB,iKACD5Z,OAAO,CAAC+G,CAAM,CACf;QACH;IACF,CAAC;IACD,OAAO,IAAInF,UAAU,CACnBzB,IAAI,CAACyI,+KAAAA,AAAO,EAAC,4JAAM7J,OAAAA,AAAI,EAACsE,SAAS,CAACjB,IAAI,CAAC,4KAAEjC,IAAI,CAACiD,IAAM,AAANA,EAAO2H,IAAI,sJAAC9M,KAAK,CAACqF,EAAK,AAALA,GAAU,CAACjC,MAAM,CAACuY,QAAQ,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAClG;AACH,CAAC,CACF;AAGM,MAAM5V,SAAS,GAAA,WAAA,2JAAGnF,OAAI,AAAJA,EAIvB,CAAC,EACD,CAAauD,IAA4B,EAAEmO,EAA8B,GACvEyB,SAAS,CAAC5P,IAAI,uJAAEnE,KAAK,CAAC+F,MAAS,AAATA,EAAUuM,EAAE,CAAC,CAAC,CACvC;AAGM,MAAMsJ,eAAe,GAAA,WAAA,2JAAGhb,OAAAA,AAAI,EASjC,CAAC,EACD,CACEuD,IAA4B,EAC5BmO,EAAsD,GAEtD3H,OAAO,CAAC,MAAK;QACX,MAAMmC,IAAI,IACR6O,QAAqB,IACoE;YACzF,MAAMhX,IAAI,GAAGgX,QAAQ,CAAChX,IAAI,EAAE;YAC5B,IAAIA,IAAI,CAACoI,IAAI,EAAE;gBACb,iLAAO7K,IAAI,CAACiF,WAAAA,AAAa,EAAC;oBACxB1C,OAAO,GAAGC,KAAK,GAAKoI,IAAI,CAACpI,KAAK,CAACtB,MAAM,CAACuY,QAAQ,CAAC,EAAE,CAAC;oBAClD5W,SAAS,wKAAE7C,IAAI,CAACwG,OAAS;oBACzBzD,MAAM,wKAAE/C,IAAI,CAAC8F,KAAAA;iBACd,CAAC;YACJ,CAAC,MAAM;gBACL,+JAAOlH,OAAI,AAAJA,EACLwR,EAAE,CAAC3N,IAAI,CAACyG,KAAK,CAAC,wJACdlK,MAAM,CAAC+E,CAAAA,AAAK,EAAC;oBACX+D,MAAM,EAAEA,CAAA,yJAAM3J,MAAM,CAAC8L,AAAI,EAAC,IAAMW,IAAI,CAAC6O,QAAQ,CAAC,CAAC;oBAC/CxR,MAAM,EAAE9J,MAAM,CAAC6H,qJAAAA,AAAG,GAAE0N,EAAE,6KAAK1T,IAAI,CAAC2C,KAAAA,AAAO,2KAAC3C,IAAI,CAAC4C,IAAAA,AAAK,uJAAC9E,KAAK,AAACiK,AAAE,CAAFA,CAAG2L,EAAE,CAAC,CAAC,EAAE,IAAM9I,IAAI,CAAC6O,QAAQ,CAAC,CAAC;iBACxF,CAAC,EACF5Z,OAAO,CAAC+G,gKAAM,CACf;YACH;QACF,CAAC;QACD,OAAO,IAAInF,UAAU,yJAAC7C,OAAAA,AAAI,EAACsE,SAAS,CAACjB,IAAI,CAAC,4KAAEjC,IAAI,CAACiD,IAAAA,AAAM,EAAC2H,IAAI,sJAAC9M,KAAK,CAACqF,EAAAA,AAAK,GAAK,CAACjC,MAAM,CAACuY,QAAQ,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;IACtG,CAAC,CAAC,CACL;AAGM,MAAME,cAAc,GAAA,WAAA,2JAAGjb,OAAAA,AAAI,EAMhC,CAAC,EACD,CAAcuD,IAA4B,EAAEmO,EAA+B,KAAI;IAC7E,MAAMxF,IAAI,6KAA6E5K,IAAI,CAACsC,MAAAA,AAAQ,EAAC;QACnGC,OAAO,GAAGC,KAAqB,IAAI;YACjC,MAAMoX,MAAM,wJAAG9b,KAAK,CAAC6b,WAAAA,AAAc,EAACnX,KAAK,EAAE4N,EAAE,CAAC;YAC9C,IAAIwJ,MAAM,CAAC/M,MAAM,KAAKrK,KAAK,CAACqK,MAAM,EAAE;gBAClC,OAAOjO,+JAAAA,AAAI,4KAACoB,IAAI,CAAC4C,GAAAA,AAAK,EAACgX,MAAM,CAAC,4KAAE5Z,IAAI,CAAC2C,KAAAA,AAAO,EAAC,IAAMiI,IAAI,CAAC,CAAC;YAC3D;YACA,WAAO5K,IAAI,CAAC4C,yKAAAA,AAAK,EAACgX,MAAM,CAAC;QAC3B,CAAC;QACD/W,SAAS,wKAAE7C,IAAI,CAAC8C,EAAI;QACpBC,MAAM,wKAAE/C,IAAI,CAAC8F,KAAAA;KACd,CAAC;IACF,OAAO,IAAIrE,UAAU,yJAAC7C,OAAI,AAAJA,EAAKsE,SAAS,CAACjB,IAAI,CAAC,qKAAEpC,OAAO,CAACuH,OAAAA,AAAY,EAACwD,IAAI,CAAC,CAAC,CAAC;AAC1E,CAAC,CACF;AAGM,MAAMiP,oBAAoB,GAAA,WAAA,0JAAGnb,QAAI,AAAJA,EASlC,CAAC,EACD,CACEuD,IAA4B,EAC5BmO,EAAsD,GAEtD3H,OAAO,CAAC,MAAK;QACX,MAAMmC,IAAI,IACR6O,QAAqB,IACoE;YACzF,MAAMhX,IAAI,GAAGgX,QAAQ,CAAChX,IAAI,EAAE;YAC5B,IAAIA,IAAI,CAACoI,IAAI,EAAE;gBACb,iLAAO7K,IAAI,CAACiF,WAAAA,AAAa,EAAC;oBACxB1C,OAAO,GAAGC,KAAK,GAAKoI,IAAI,CAACpI,KAAK,CAACtB,MAAM,CAACuY,QAAQ,CAAC,EAAE,CAAC;oBAClD5W,SAAS,wKAAE7C,IAAI,CAACwG,OAAS;oBACzBzD,MAAM,wKAAE/C,IAAI,CAAC8F,KAAAA;iBACd,CAAC;YACJ,CAAC,MAAM;gBACL,0KAAOjG,OAAO,CAAC+G,CAAAA,AAAM,wJACnB5H,MAAM,CAAC+E,CAAAA,AAAK,EAACqM,EAAE,CAAC3N,IAAI,CAACyG,KAAK,CAAC,EAAE;oBAC3BpB,MAAM,EAAEA,CAAA,wJAAM3J,MAAM,CAAC2H,IAAAA,AAAO,wKAAC9F,IAAI,CAACgD,EAAI,CAAC;oBACvCiF,MAAM,wJAAE9J,MAAU,AAAJ,AAAC6H,CAAAA,EACZ0N,EAAE,GAAK1T,IAAI,CAAC2C,+KAAAA,AAAO,4KAAC3C,IAAI,CAAC4C,GAAAA,AAAK,uJAAC9E,KAAK,AAACiK,AAAE,CAAFA,CAAG2L,EAAE,CAAC,CAAC,EAAE,IAAM9I,IAAI,CAAC6O,QAAQ,CAAC,CAAC;iBAEvE,CAAC,CACH;YACH;QACF,CAAC;QACD,OAAO,IAAIhY,UAAU,yJAAC7C,OAAAA,AAAI,EAACsE,SAAS,CAACjB,IAAI,CAAC,oKAAEpC,OAAO,CAACuH,QAAAA,AAAY,EAACwD,IAAI,sJAAC9M,KAAK,CAACqF,EAAK,AAALA,GAAU,CAACjC,MAAM,CAACuY,QAAQ,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;IAC/G,CAAC,CAAC,CACL;AAGM,MAAMb,SAAS,GAAUA,SAAqC,IACnExV,cAAc,mJAACjF,MAAM,CAAC6E,AAAI,EAAE,IAAM4V,SAAS,CAAC;AAGvC,MAAMkB,IAAI,GAAA,WAAA,2JAObpb,OAAAA,AAAI,EAAC,CAAC,EAAE,CAAUuD,IAA4B,EAAEqW,SAAuB,KAA4B;IACrG,MAAM1N,IAAI,GAA+E5K,IAAI,CAACsC,gLAAAA,AAAQ,EAAC;QACrGC,OAAO,EAAGC,KAAqB,0JAC7BxD,MAAM,CAAC+E,CAAAA,AAAK,uJAACjG,KAAK,CAACic,MAAAA,AAAS,EAACvX,KAAK,EAAE8V,SAAS,CAAC,EAAE;gBAC9CxQ,MAAM,EAAEA,CAAA,GAAM8C,IAAI;gBAClB3C,MAAM,GAAGuE,CAAC,6KAAKxM,IAAI,CAAC4C,GAAAA,AAAK,sJAAC9E,KAAK,CAACiK,AAAE,EAACyE,CAAC,CAAC;aACtC,CAAC;QACJ3J,SAAS,wKAAE7C,IAAI,CAAC8C,EAAI;QACpBC,MAAM,EAAEA,CAAA,yKAAM/C,IAAI,CAACgD,EAAAA;KACpB,CAAC;IACF,OAAO,IAAIvB,UAAU,yJAAC7C,OAAAA,AAAI,EAACsE,SAAS,CAACjB,IAAI,CAAC,4KAAEjC,IAAI,CAACiD,IAAAA,AAAM,EAAC2H,IAAI,CAAC,CAAC,CAAC;AACjE,CAAC,CAAC;AAGK,MAAMoP,UAAU,GAAA,WAAA,2JAQnBtb,OAAAA,AAAI,EACN,CAAC,EACD,CACEuD,IAA4B,EAC5BqW,SAAkE,KAC9B;IACpC,MAAM1N,IAAI,6KAAqF5K,IAAI,CAACsC,MAAAA,AAAQ,EAAC;QAC3GC,OAAO,GAAGC,KAAqB,2JAC7B5D,OAAAA,AAAI,wJACFT,MAAM,CAAC4b,KAAAA,AAAS,EAACvX,KAAK,EAAE8V,SAAS,CAAC,wJAClCna,MAAM,AAAC6H,AAAG,CAAHA,uJAAIhH,MAAM,CAAC+E,CAAAA,AAAK,EAAC;gBACtB+D,MAAM,EAAEA,CAAA,GAAM8C,IAAI;gBAClB3C,MAAM,GAAGuE,CAAC,GAAKxM,IAAI,CAAC4C,6KAAAA,AAAK,EAAC9E,KAAK,CAACiK,oJAAAA,AAAE,EAACyE,CAAC,CAAC;aACtC,CAAC,CAAC,gKACH3M,OAAO,CAAC+G,EAAM,CACf;QACH/D,SAAS,wKAAE7C,IAAI,CAAC8C,EAAI;QACpBC,MAAM,EAAEA,CAAA,yKAAM/C,IAAI,CAACgD,EAAAA;KACpB,CAAC;IACF,OAAO,IAAIvB,UAAU,yJAAC7C,OAAI,AAAJA,EAAKsE,SAAS,CAACjB,IAAI,CAAC,4KAAEjC,IAAI,CAACiD,IAAAA,AAAM,EAAC2H,IAAI,CAAC,CAAC,CAAC;AACjE,CAAC,CACF;AAGM,MAAMjI,OAAO,GAAA,WAAA,2JAAGjE,OAAAA,AAAI,GAmBxBub,IAAI,GAAKrY,QAAQ,CAACqY,IAAI,CAAC,CAAC,CAAC,CAAC,EAC3B,CACEhY,IAA4B,EAC5BwK,CAAsC,EACtClB,OAIC,KACoC;IACrC,MAAMnC,UAAU,GAAGmC,OAAO,EAAEnC,UAAU,IAAI,EAAE;IAE5C,IAAImC,OAAO,EAAE2O,MAAM,EAAE;QACnB,OAAOC,gBAAgB,CACrB5O,OAAO,EAAE6O,WAAW,EACpB,IAAMC,sBAAsB,CAACpY,IAAI,EAAE,CAAC,EAAEmH,UAAU,EAAEqD,CAAC,CAAC,GACnDD,CAAC,GAAK6N,sBAAsB,CAACpY,IAAI,EAAEuK,CAAC,EAAEpD,UAAU,EAAEqD,CAAC,CAAC,CACtD;IACH;IAEA,OAAO0N,gBAAgB,CACrB5O,OAAO,EAAE6O,WAAW,EACpB,IACE,IAAI3Y,UAAU,oKACZ5B,OAAO,CAAC4S,IAAAA,AAAS,EACfvP,SAAS,CAACjB,IAAI,CAAC,EACdgH,EAAE,4JACDrK,OAAAA,AAAI,EACFqK,EAAE,EACFnL,KAAK,CAACkI,qJAAAA,AAAG,GAAEyN,CAAC,GAAKvQ,SAAS,CAACuJ,CAAC,CAACgH,CAAC,CAAC,CAAC,CAAC,uJACjC3V,KAAK,CAACyT,GAAAA,AAAM,wKACVvR,IAAI,CAACgD,EAAoF,EACzF,CAACkF,IAAI,EAAEF,KAAK,2JAAKpJ,OAAAA,AAAI,EAACsJ,IAAI,qKAAErI,OAAO,CAACgG,GAAQ,AAARA,EAASmC,KAAK,CAAC,CAAC,CACrD,CACF,CACJ,CACF,GACF1G,CAAC,GACA,IAAIG,UAAU,yJACZ7C,OAAAA,AAAI,EACFsE,SAAS,CAACjB,IAAI,CAAC,qKACfpC,OAAO,CAAC4S,IAAAA,AAAS,iKAAC5S,OAAO,CAAC6S,KAAU,CAAC,qKACrC7S,OAAO,CAACya,GAAAA,AAAQ,GAAEC,GAAG,GAAKrX,SAAS,CAACuJ,CAAC,CAAC8N,GAAG,CAAC,CAAC,EAAEhP,OAAc,CAAC,CAC7D,CACF,CACJ;AACH,CAAC,CACF;AAGM,MAAM4O,gBAAgB,GAAGA,CAC9BC,WAA6C,EAC7CI,UAAmB,EACnBjR,OAAyB,KACvB;IACF,OAAQ6Q,WAAW;QACjB,KAAK9Q,SAAS;YACZ,OAAOkR,UAAU,EAAE;QACrB,KAAK,WAAW;YACd,OAAOjR,OAAO,CAACkR,MAAM,CAACC,gBAAgB,CAAC;QACzC;YACE,OAAON,WAAW,GAAG,CAAC,GAAG7Q,OAAO,CAAC6Q,WAAW,CAAC,GAAGI,UAAU,EAAE;IAChE;AACF,CAAC;AAED,MAAMH,sBAAsB,GAAA,WAAA,2JAAG3b,OAAAA,AAAI,EAajC,CAAC,EACD,CACEuD,IAA4B,EAC5BuK,CAAS,EACTpD,UAAkB,EAClBqD,CAAsC,GAEtC,IAAIhL,UAAU,yJACZ7C,OAAI,AAAJA,EACEsE,SAAS,CAACjB,IAAI,CAAC,qKACfpC,OAAO,CAAC4S,IAAAA,AAAS,iKAAC5S,OAAO,CAAC6S,KAAU,CAAC,MACrC7S,OAAO,CAACya,kKAAAA,AAAQ,GAAEC,GAAG,GAAKrX,SAAS,CAACuJ,CAAC,CAAC8N,GAAG,CAAC,CAAC,EAAE;QAC3CH,WAAW,EAAE5N,CAAC;QACdmO,aAAa,sLAAE5a,aAAa,CAAC6a,EAAAA,AAAa,EAAE;QAC5CxR;KACD,CAAC,CACH,CACF,CACJ;AAGM,MAAMzB,OAAO,GAAA,WAAA,0JAAGjJ,QAAAA,AAAI,EAcxBub,IAAI,IAAKrY,QAAQ,CAACqY,IAAI,CAAC,CAAC,CAAC,CAAC,EAAE,CAAChY,IAAI,EAAEsJ,OAAO,GAAK5I,OAAO,CAACV,IAAI,EAAEtD,+JAAQ,EAAE4M,OAAO,CAAC,CAAC;AAG5E,MAAMwG,aAAa,IAAa9P,IAAyC,IAA4B;IAC1G,MAAM0F,OAAO,6KAAyF3H,IAAI,CACvGiF,WAAAA,AAAa,EAAC;QACb1C,OAAO,GAAGL,MAAmC,6KAC3ClC,IAAI,CAAC2C,KAAAA,AAAO,GACV9C,OAAO,CAAC6S,uKAAAA,AAAU,EAACxQ,MAAM,CAAC,EAC1B,IAAMyF,OAAO,CACd;QACH9E,SAAS,wKAAE7C,IAAI,CAACwG,OAAS;QACzBzD,MAAM,EAAEA,CAAA,yKAAM/C,IAAI,CAACgD,EAAAA;KACpB,CAAC;IACJ,OAAO,IAAIvB,UAAU,CAAC7C,+JAAAA,AAAI,EAACsE,SAAS,CAACjB,IAAI,CAAC,4KAAEjC,IAAI,CAACiD,IAAAA,AAAM,EAAC0E,OAAO,CAAC,CAAC,CAAC;AACpE,CAAC;AAGM,MAAMkT,aAAa,GAAA,WAAA,2JAAGnc,OAAAA,AAAI,GAiB9Bub,IAAI,GAAKrY,QAAQ,CAACqY,IAAI,CAAC,CAAC,CAAC,CAAC,EAC3B,CAAChY,IAAI,EAAEsJ,OAAO,GACZA,OAAO,EAAEuP,SAAS,GAChBnY,OAAO,CAACV,IAAI,GAAGwR,CAAC,GAAKhP,UAAU,CAACgP,CAAC,CAAC,EAAE;QAAE2G,WAAW,EAAE7O,OAAO,CAAC6O,WAAAA;IAAW,CAAE,CAAC,GACzED,gBAAgB,CACd5O,OAAO,EAAE6O,WAAW,EACpB,IAAMnB,mBAAmB,CAAChX,IAAI,sJAAEtD,WAAQ,CAAC,GACxC6N,CAAC,GACA,IAAI/K,UAAU,yJACZ7C,OAAAA,AAAI,EACFsE,SAAS,CAACjB,IAAI,CAAC,qKACfpC,OAAO,CAAC4S,IAAAA,AAAS,iKAAC5S,OAAO,CAAC6S,KAAU,CAAC,qKACrC7S,OAAO,CAACkb,UAAAA,AAAe,sJAACpc,WAAQ,EAAE6N,CAAC,CAAC,qKACpC3M,OAAO,CAACmb,CAAAA,AAAM,mJAACld,KAAK,AAAG,CAAFiK,AAAG,CACzB,CACF,CACJ,CACN;AAGM,MAAMkT,iBAAiB,IAC5BhZ,IAA0D,IAC3B;IAC/B,MAAMiZ,YAAY,GAAGA,CACnBlQ,KAAmD,EACnDmQ,IAAmH,KACjH;QACF,MAAM,CAACC,MAAM,EAAEC,IAAI,CAAC,GAAGzc,+JAAAA,AAAI,EAACoM,KAAK,uJAAElN,KAAK,CAACwd,OAAAA,AAAU,GAAE9Q,IAAI,GAAK,qJAAClM,IAAI,CAAC0N,OAAS,AAATA,EAAUxB,IAAI,CAAC,CAAC,CAAC;QACrF,MAAM/H,IAAI,0JAAG7D,QAAAA,AAAI,uJACfd,KAAK,CAACqa,CAAAA,AAAI,EAACkD,IAAI,CAAC,wJAChBrc,MAAM,CAAC+E,CAAAA,AAAK,EAAC;YACX+D,MAAM,EAAEA,CAAA,GAAMqT,IAAI;YAClBlT,MAAM,sJAAE3J,IAAI,CAACyF,GAAAA,AAAK,EAAC;gBACjBlB,SAAS,GAAGwC,KAAK,yJACfrG,MAAM,CAAC+E,CAAAA,AAAK,uJAAClG,KAAK,CAACmR,YAAAA,AAAe,EAAC3J,KAAK,CAAC,EAAE;wBACzCyC,MAAM,EAAEA,CAAA,yKAAM9H,IAAI,CAACgD,EAAI;wBACvBiF,MAAM,wKAAEjI,IAAI,CAACwG,OAAAA;qBACd,CAAC;gBACJuC,SAAS,EAAEA,CAAA,yKAAM/I,IAAI,CAACgD,EAAAA;aACvB;SACF,CAAC,CACH;QACD,+JAAOpE,OAAAA,AAAI,4KACToB,IAAI,CAAC4C,GAAK,AAALA,0JAAMhE,OAAAA,AAAI,EACbwc,MAAM,uJACNtd,KAAK,CAAC+F,MAAAA,AAAS,GAAE2G,IAAI,uJACnBlM,IAAI,CAAC0N,OAAAA,AAAS,EAACxB,IAAI,CAAC,wJAClBxL,MAAM,CAACmF,CAAAA,AAAI,EAACqG,IAAI,CAACtB,KAAK,CAAC,yJACvBlK,MAAM,CAACiF,AAAI,EAAE,CAChB,CACF,CAAC,4KACFjE,IAAI,CAAC2C,MAAAA,AAAO,EAAC,IAAMF,IAAI,CAAC,CACzB;IACH,CAAC;IACD,MAAMsM,OAAO,6KAQT/O,IAAI,CAACiF,WAAAA,AAAa,EAAC;QACrB1C,OAAO,GAAGyI,KAAmD,GAAKkQ,YAAY,CAAClQ,KAAK,EAAE+D,OAAO,CAAC;QAC9FlM,SAAS,GAAGwC,KAAK,6KAAKrF,IAAI,CAACwG,OAAAA,AAAS,EAASnB,KAAK,CAAC;QACnDtC,MAAM,EAAEA,CAAA,yKAAM/C,IAAI,CAACgD,EAAAA;KACpB,CAAC;IACF,OAAO,IAAIvB,UAAU,yJAAC7C,OAAAA,AAAI,EAACsE,SAAS,CAACjB,IAAI,CAAC,4KAAEjC,IAAI,CAACiD,IAAAA,AAAM,EAAC8L,OAAO,CAAC,CAAC,CAAC;AACpE,CAAC;AAGM,MAAMwM,gBAAgB,IAAatZ,IAAsC,2JAC9ErD,OAAI,AAAJA,EAAKqD,IAAI,EAAE+D,GAAG,kJAAClI,KAAK,CAACqZ,SAAY,CAAC,EAAEpF,aAAa,CAAC;AAG7C,MAAMtE,WAAW,GAAiBxL,IAA2C,IAClF8P,aAAa,CAACkJ,iBAAiB,yJAACrc,OAAAA,AAAI,EAACqD,IAAI,EAAE+D,GAAG,EAAED,IAAI,GAAKA,IAAI,CAACyE,IAAI,CAAC,CAAC,CAAC,CAAC;AAGjE,MAAM7G,OAAO,GAAa1B,IAA4B,IAC3D,IAAIR,UAAU,oKAAC5B,OAAO,CAAC2b,GAAAA,AAAQ,EAACtY,SAAS,CAACjB,IAAI,CAAC,CAAC,CAAC;AAG5C,MAAMwZ,iBAAiB,GAAGA,CAC/BC,QAA0B,EAC1BrP,OAA0B,2JAE1BzN,OAAAA,AAAI,wJACFT,MAAM,CAACiF,UAAAA,AAAc,EACnBjF,MAAM,CAAC8L,sJAAAA,AAAI,EAAC,IAAMyR,QAAQ,CAACxa,MAAM,CAACya,aAAa,CAAC,EAAE,CAAC,GAClDlC,QAAQ,GAAKA,QAAQ,CAACmC,MAAM,yJAAGzd,MAAM,CAAC0d,GAAAA,AAAO,EAAC,UAAYpC,QAAQ,CAACmC,MAAO,EAAE,CAAC,qJAAGzd,MAAM,CAAC6E,AAAI,CAC7F,wJACD7E,MAAM,AAAC6H,AAAG,CAAHA,EAAKyT,QAAQ,GAClBqC,kBAAkB,yJAACld,OAAAA,AAAI,MACrBT,MAAM,CAAC4d,wJAAU,AAAVA,EAAW;YAChBC,GAAG,EAAE,MAAAA,CAAA,GAAYvC,QAAQ,CAAChX,IAAI,EAAE;YAChCwZ,KAAK,GAAGvV,MAAM,yJAAK1H,MAAM,CAACmF,AAAI,EAACkI,OAAO,CAAC3F,MAAM,CAAC;SAC/C,CAAC,wJACFvI,MAAM,CAACwE,GAAAA,AAAO,EAAEuZ,MAAM,IAAKA,MAAM,CAACrR,IAAI,yJAAG1M,MAAM,CAAC2E,AAAI,wJAAC9D,MAAM,CAACiF,AAAI,EAAE,CAAC,0JAAG9F,MAAM,CAAC2H,GAAO,AAAPA,EAAQoW,MAAM,CAAChT,KAAK,CAAC,CAAC,CACpG,CAAC,CACH,EACDiC,YAAY,CACb;AAGI,MAAMF,WAAW,GACtBpL,OAAkF,IACvD,IAAI4B,UAAU,CAAC5B,OAAO,CAAC;AAG7C,MAAMqD,SAAS,IACpBiZ,MAA8B,IAC+C;IAC7E,IAAI,SAAS,IAAIA,MAAM,EAAE;QACvB,OAAQA,MAA8B,CAACtc,OAAO;IAChD,CAAC,MAAM,IAAI1B,MAAM,CAAC2D,0JAAAA,AAAQ,EAACqa,MAAM,CAAC,EAAE;QAClC,OAAOjZ,SAAS,CAACuB,UAAU,CAAC0X,MAAM,CAAC,CAAQ;IAC7C,CAAC,MAAM;QACL,MAAM,IAAIC,SAAS,CAAC,CAAA,kBAAA,CAAoB,CAAC;IAC3C;AACF,CAAC;AAGM,MAAMC,SAAS,IAAOrR,KAAqB,GAChD,IAAIvJ,UAAU,sJAAC3D,KAAK,CAACia,IAAAA,AAAO,EAAC/M,KAAK,CAAC,yKAAGhL,IAAI,CAACgD,EAAI,6KAAGhD,IAAI,CAAC4C,GAAK,AAALA,EAAMoI,KAAK,CAAC,CAAC;AAG/D,MAAMsR,eAAe,GASxBA,CAACzO,MAAM,EAAEtC,OAAO,KAAS;IAC3B,IAAIA,OAAO,EAAEhI,MAAM,EAAE;QACnB,MAAM0O,MAAM,GAAG9T,MAAM,CAAC6H,qJAAAA,AAAG,wJAAC7G,MAAM,CAACkP,KAAAA,AAAS,EAACR,MAAM,CAAC,EAAE0O,cAAc,CAAC;QACnE,OAAOhR,OAAO,CAACzB,QAAQ,yJAAG3L,MAAM,AAAC6H,AAAG,CAAHA,CAAIiM,MAAM,EAAE/G,QAAQ,uJAAC/L,MAAM,CAAC2K,IAAAA,AAAQ,EAAC+D,MAAM,CAAC,CAAC,CAAC,GAAGoE,MAAM;IAC1F;IACA,MAAMkK,MAAM,GAAGxZ,OAAO,CAACY,MAAM,uJAACpE,MAAM,CAACkP,KAAAA,AAAS,EAACR,MAAM,CAAC,CAAC,EAAE0O,cAAc,CAAC;IACxE,OAAOhR,OAAO,EAAEzB,QAAQ,GAAGoB,QAAQ,CAACiR,MAAM,wJAAEhd,MAAM,CAAC2K,IAAAA,AAAQ,EAAC+D,MAAM,CAAC,CAAC,GAAGsO,MAAM;AAC/E,CAAC;AAGM,MAAMI,cAAc,GAAGA,CAAI1S,KAAoC,EAAE0B,OAEvE,GACC3M,+JAAAA,AAAI,uJACFQ,KAAK,CAAC2G,CAAAA,AAAI,EAAC8D,KAAK,CAAC,wJACjB1L,MAAM,CAAC+R,SAAAA,AAAa,GAAE7K,KAAK,2JACzBzG,OAAI,AAAJA,uJACEQ,KAAK,CAACod,OAAAA,AAAU,EAAC3S,KAAK,CAAC,wJACvB1L,MAAM,CAACwE,GAAAA,AAAO,GAAE6Z,UAAU,GACxBA,UAAU,yJAAI3e,KAAK,CAAC6M,UAAa,AAAbA,EAAcrF,KAAK,CAAC,6KACtC3E,IAAI,CAAC6E,CAAAA,AAAG,EAAE,8KACV7E,IAAI,CAAC8F,OAAAA,AAAS,EAACnB,KAAK,CAAC,CACxB,CACF,CACF,EACDiH,uBAAuB,EACvBf,OAAO,EAAEzB,QAAQ,GAAGoB,QAAQ,CAAC9L,KAAK,CAAC0K,0JAAAA,AAAQ,EAACD,KAAK,CAAC,CAAC,uJAAGlL,WAAQ,CAC/D;AAGI,MAAM8d,UAAU,GAAGA,CACxB,GAAGva,MAA6B,2JACXtD,OAAAA,AAAI,EAACuY,YAAY,CAACjV,MAAM,CAAC,EAAES,OAAO,CAAC0Z,SAAS,CAAC,CAAC;AAG9D,MAAM5X,UAAU,IAAawN,MAA8B,0JAChErT,QAAAA,AAAI,EAACqT,MAAM,wJAAE9T,MAAM,CAACue,IAAQ,AAARA,oJAAS1d,MAAM,CAACmF,AAAI,CAAC,EAAEiV,gBAAgB,CAAC;AAGvD,MAAMA,gBAAgB,IAAanH,MAA6C,GACrF,IAAIxQ,UAAU,mKACZ5B,OAAO,CAAC+G,EAAAA,AAAM,wJACZzI,MAAM,CAAC4F,CAAAA,AAAK,EAACkO,MAAM,EAAE;QACnBpP,SAAS,wJAAE7D,MAAM,CAAC+E,CAAK,AAALA,EAAM;YACtB+D,MAAM,EAAEA,CAAA,wKAAM9H,IAAI,CAACgD,GAAI;YACvBiF,MAAM,wKAAEjI,IAAI,CAAC8C,EAAAA;SACd,CAAC;QACFiG,SAAS,GAAG0K,CAAC,6KAAKzT,IAAI,CAAC4C,GAAAA,AAAK,sJAAC9E,KAAK,CAACiK,AAAE,EAAC0L,CAAC,CAAC;KACzC,CAAC,CACH,CACF;AAGI,MAAM3F,UAAU,GAWnBA,CAACD,MAAM,EAAEtC,OAAO,KAAS;IAC3B,MAAMoR,YAAY,GAAGpR,OAAO,EAAEoR,YAAY,IAAI5a,gBAAgB;IAE9D,IAAIwJ,OAAO,EAAEhI,MAAM,EAAE;QACnB,MAAM0O,MAAM,yJAAG9T,MAAM,AAAC6H,AAAG,CAAHA,KACpB7G,MAAM,CAACkP,uJAAAA,AAAS,EAACR,MAAM,CAAC,GACvBhE,KAAK,GAAK6D,SAAS,CAAC7D,KAAK,EAAE;gBAAE8S,YAAY;gBAAE7S,QAAQ,EAAE;YAAI,CAAE,CAAC,CAC9D;QAED,OAAOyB,OAAO,CAACzB,QAAQ,yJAAG3L,MAAU,AAAH6H,AAAD,CAACA,CAAIiM,MAAM,EAAE/G,QAAQ,uJAAC/L,MAAM,CAAC2K,IAAAA,AAAQ,EAAC+D,MAAM,CAAC,CAAC,CAAC,GAAGoE,MAAM;IAC1F;IACA,MAAMkK,MAAM,GAAGxZ,OAAO,CACpBY,MAAM,KAACpE,MAAM,CAACkP,uJAAAA,AAAS,EAACR,MAAM,CAAC,CAAC,GAC/BhE,KAAK,GAAK6D,SAAS,CAAC7D,KAAK,EAAE;YAAE8S;QAAY,CAAE,CAAC,CAC9C;IACD,OAAOpR,OAAO,EAAEzB,QAAQ,GAAGoB,QAAQ,CAACiR,MAAM,wJAAEhd,MAAM,CAAC2K,IAAQ,AAARA,EAAS+D,MAAM,CAAC,CAAC,GAAGsO,MAAM;AAC/E,CAAC;AAGM,MAAMS,WAAW,IAAO/O,MAA0B,IAAsB;IAC7E,OAAO1C,YAAY,uJAAChN,MAAU,AAAH6H,AAAD,CAACA,CACzBtG,OAAO,CAACmd,iKAAAA,AAAe,EAAChP,MAAM,CAAC,GAC9BhE,KAAK,GAAKiT,UAAU,CAACjT,KAAK,CAAC,CAC7B,CAAC;AACJ,CAAC;AAGM,MAAMsN,YAAY,IAAOuE,QAAqB,GACnDjT,OAAO,CAAC,yJACN3K,KAAK,CAACif,IAAAA,AAAO,EAACrB,QAAQ,CAAC,GACrBW,SAAS,CAACX,QAAQ,CAAC,GACnBsB,mBAAmB,CAACtB,QAAQ,CAACxa,MAAM,CAACuY,QAAQ,CAAC,EAAE,CAAC,CACnD;AAGI,MAAMwD,kBAAkB,IAC7BhL,MAAwC,2JACbrT,OAAAA,AAAI,EAACqT,MAAM,wJAAE9T,MAAM,AAAC6H,AAAG,CAAHA,CAAImR,YAAY,CAAC,EAAEvQ,MAAM,CAAC;AAGpE,MAAMoW,mBAAmB,GAAGA,CACjCvD,QAAqB,EACrBkD,YAAY,GAAG5a,gBAAgB,KACX;IACpB,+JAAOnD,OAAAA,AAAI,wJACTT,MAAM,CAAC8L,AAAI,EAAC,MAAK;QACf,IAAIiT,OAAO,GAAa,EAAE;QAC1B,MAAMtS,IAAI,GACR6O,QAAqB,4JAErB7a,OAAI,AAAJA,MACET,MAAM,CAAC8L,kJAAAA,AAAI,EAAC,MAAK;gBACf,IAAIxH,IAAI,GAA2BgX,QAAQ,CAAChX,IAAI,EAAE;gBAClD,IAAIka,YAAY,KAAK,CAAC,EAAE;oBACtB,IAAIla,IAAI,CAACoI,IAAI,EAAE;wBACb,6KAAO7K,IAAI,CAACgD,EAAI;oBAClB;oBACA,+JAAOpE,OAAAA,AAAI,4KACToB,IAAI,CAAC4C,GAAAA,AAAK,uJAAC9E,KAAK,AAACiK,AAAE,CAAFA,CAAGtF,IAAI,CAACyG,KAAK,CAAC,CAAC,EAChClJ,IAAI,CAAC2C,+KAAAA,AAAO,EAAC,IAAMiI,IAAI,CAAC6O,QAAQ,CAAC,CAAC,CACnC;gBACH;gBACAyD,OAAO,GAAG,EAAE;gBACZ,IAAIC,KAAK,GAAG,CAAC;gBACb,MAAO1a,IAAI,CAACoI,IAAI,KAAK,KAAK,CAAE;oBAC1BqS,OAAO,CAACE,IAAI,CAAC3a,IAAI,CAACyG,KAAK,CAAC;oBACxBiU,KAAK,GAAGA,KAAK,GAAG,CAAC;oBACjB,IAAIA,KAAK,IAAIR,YAAY,EAAE;wBACzB;oBACF;oBACAla,IAAI,GAAGgX,QAAQ,CAAChX,IAAI,EAAE;gBACxB;gBACA,IAAI0a,KAAK,GAAG,CAAC,EAAE;oBACb,+JAAOve,OAAAA,AAAI,4KACToB,IAAI,CAAC4C,GAAK,AAALA,uJAAM9E,KAAK,CAACmO,YAAAA,AAAe,EAACiR,OAAO,CAAC,CAAC,4KAC1Cld,IAAI,CAAC2C,KAAAA,AAAO,EAAC,IAAMiI,IAAI,CAAC6O,QAAQ,CAAC,CAAC,CACnC;gBACH;gBACA,OAAOzZ,IAAI,CAACgD,wKAAI;YAClB,CAAC,CAAC,iKACFnD,OAAO,CAAC+G,CAAM,CACf;QACH,OAAO,IAAInF,UAAU,CAACmJ,IAAI,CAAC6O,QAAQ,CAAC,CAAC;IACvC,CAAC,CAAC,EACF7S,MAAM,CACP;AACH,CAAC;AAGM,MAAMyD,QAAQ,IACnB4H,MAAkG,2JAC5CrT,OAAAA,AAAI,EAACqT,MAAM,wJAAE9T,MAAU,AAAH6H,AAAD,CAACA,CAAIsG,uBAAuB,CAAC,EAAEnB,YAAY,CAAC;AAGhH,MAAMuC,SAAS,GAAGA,CACvB7D,KAAuB,EACvB0B,OAGC,2JAED3M,OAAI,AAAJA,uJACEQ,KAAK,CAACie,QAAW,AAAXA,EAAYxT,KAAK,EAAE,CAAC,EAAE0B,OAAO,EAAEoR,YAAY,IAAI5a,gBAAgB,CAAC,wJACtE5D,MAAM,CAAC+R,SAAAA,AAAa,GAAE7K,KAAK,2JACzBzG,OAAAA,AAAI,EACFQ,KAAK,CAACod,4JAAU,AAAVA,EAAW3S,KAAK,CAAC,wJACvB1L,MAAM,CAACwE,GAAAA,AAAO,GAAE6Z,UAAU,GACxBA,UAAU,yJAAI3e,KAAK,CAAC6M,UAAAA,AAAa,EAACrF,KAAK,CAAC,6KACtC3E,IAAI,CAAC6E,CAAAA,AAAG,EAAE,8KACV7E,IAAI,CAAC8F,OAAS,AAATA,EAAUnB,KAAK,CAAC,CACxB,CACF,CACF,EACDiH,uBAAuB,EACvBf,OAAO,EAAEzB,QAAQ,GAAGoB,QAAQ,KAAC9L,KAAK,CAAC0K,sJAAAA,AAAQ,EAACD,KAAK,CAAC,CAAC,uJAAGlL,WAAQ,CAC/D;AAGI,MAAMme,UAAU,IAAOjT,KAAyB,2JACrDjL,OAAAA,AAAI,MACFe,MAAM,CAACoG,kJAAAA,AAAI,EAAC8D,KAAK,CAAC,wJAClB1L,MAAO6H,AAAG,AAAJ,CAACA,kJAAIlI,KAAK,AAAG,CAAFiK,AAAG,wJACpB5J,MAAM,CAAC+R,SAAAA,AAAa,GAAE7K,KAAK,GACzBzG,+JAAAA,AAAI,wJACFe,MAAM,CAAC6c,MAAAA,AAAU,EAAC3S,KAAK,CAAC,wJACxB1L,MAAM,CAACwE,GAAAA,AAAO,GAAE6Z,UAAU,GACxBA,UAAU,yJAAI3e,KAAK,CAAC6M,UAAAA,AAAa,EAACrF,KAAK,CAAC,IACtC3E,IAAI,CAAC6E,0KAAAA,AAAG,EAAE,8KACV7E,IAAI,CAAC8F,OAAAA,AAAS,EAACnB,KAAK,CAAC,CACxB,CACF,CACF,EACDiH,uBAAuB,CACxB;AAGI,MAAMgR,YAAY,IAAU1Z,QAA0C,2JAC3EhF,OAAAA,AAAI,MACFY,QAAQ,CAACgF,oJAAAA,AAAM,EAACZ,QAAQ,CAAC,wJACzBzF,MAAM,AAAC6H,AAAG,CAAHA,EAAKxB,MAAM,GAAKsX,kBAAkB,CAACtX,MAAM,CAAC/B,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,EAC/DmE,MAAM,CACP;AAGI,MAAM2W,kBAAkB,GAY3BA,CACF,GAAGtD,IAOF,KACsB;IACvB,MAAM/E,QAAQ,GAAG+E,IAAI,CAACpN,MAAM,KAAK,CAAC,GAAGoN,IAAI,CAAC,CAAC,CAAC,CAAC/E,QAAQ,GAAG+E,IAAI,CAAC,CAAC,CAAC;IAC/D,MAAM5N,OAAO,GAAG4N,IAAI,CAACpN,MAAM,KAAK,CAAC,GAAGoN,IAAI,CAAC,CAAC,CAAC,CAAC5N,OAAO,GAAG4N,IAAI,CAAC,CAAC,CAAC;IAC7D,MAAMuD,gBAAgB,GAAGvD,IAAI,CAACpN,MAAM,KAAK,CAAC,GAAGoN,IAAI,CAAC,CAAC,CAAC,CAACuD,gBAAgB,KAAK,IAAI,GAAG,KAAK;IACtF,OAAOrS,YAAY,EAAChN,MAAM,CAAC6H,oJAAAA,AAAG,wJAC5B7H,MAAM,CAACiF,UAAAA,AAAc,wJACnBjF,MAAM,CAAC8L,AAAI,EAAC,IAAMiL,QAAQ,EAAE,CAACuI,SAAS,EAAE,CAAC,GACxCvF,MAAM,GACLsF,gBAAgB,yJACZrf,MAAM,CAAC8L,AAAI,EAAC,IAAMiO,MAAM,CAACwF,WAAW,EAAE,CAAC,yJACvCvf,MAAM,CAAC0d,GAAAA,AAAO,EAAC,IAAM3D,MAAM,CAACyF,MAAM,EAAE,CAAC,CAC5C,GACAzF,MAAM,GACL4D,kBAAkB,uJAChB3d,MAAM,CAACwE,GAAAA,AAAO,wJACZxE,MAAM,CAAC4d,MAAAA,AAAU,EAAC;YAChBC,GAAG,EAAEA,CAAA,GAAM9D,MAAM,CAAC0F,IAAI,EAAE;YACxB3B,KAAK,GAAGvV,MAAM,yJAAK1H,MAAM,CAACmF,AAAI,EAACkI,OAAO,CAAC3F,MAAM,CAAC;SAC/C,CAAC,EACF,CAAC,EAAEmE,IAAI,EAAE3B,KAAAA,EAAO,GAAK2B,IAAI,OAAG1M,MAAM,CAAC2E,kJAAAA,AAAI,wJAAC9D,MAAM,CAACiF,AAAI,EAAE,CAAC,0JAAG9F,MAAM,CAAC2H,GAAAA,AAAO,EAACoD,KAAK,CAAC,CAC/E,CACF,CACJ,CAAC;AACJ,CAAC;AAGM,MAAM2U,sBAAsB,GAc/BA,CACF,GAAG5D,IASF,KAC+B;IAChC,MAAM/E,QAAQ,GAAG+E,IAAI,CAACpN,MAAM,KAAK,CAAC,GAAGoN,IAAI,CAAC,CAAC,CAAC,CAAC/E,QAAQ,GAAG+E,IAAI,CAAC,CAAC,CAAC;IAC/D,MAAM5N,OAAO,GAAG4N,IAAI,CAACpN,MAAM,KAAK,CAAC,GAAGoN,IAAI,CAAC,CAAC,CAAC,CAAC5N,OAAO,GAAG4N,IAAI,CAAC,CAAC,CAAC;IAC7D,MAAM6D,SAAS,GAAG,CAAC7D,IAAI,CAACpN,MAAM,KAAK,CAAC,GAAGoN,IAAI,CAAC,CAAC,CAAC,CAAC7Q,UAAU,GAAG6Q,IAAI,CAAC,CAAC,CAAC,KAAK,IAAI;IAC5E,MAAMuD,gBAAgB,GAAGvD,IAAI,CAACpN,MAAM,KAAK,CAAC,GAAGoN,IAAI,CAAC,CAAC,CAAC,CAACuD,gBAAgB,KAAK,IAAI,GAAG,KAAK;IACtF,OAAOrS,YAAY,uJAAChN,MAAM,AAAC6H,AAAG,CAAHA,uJACzB7H,MAAM,CAACiF,UAAAA,AAAc,MACnBjF,MAAM,CAAC8L,kJAAAA,AAAI,EAAC,IAAMiL,QAAQ,EAAE,CAACuI,SAAS,CAAC;YAAEM,IAAI,EAAE;QAAM,CAAE,CAAC,CAAC,GACxD7F,MAAM,GAAKsF,gBAAgB,yJAAGrf,MAAM,CAAC8L,AAAI,EAAC,IAAMiO,MAAM,CAACwF,WAAW,EAAE,CAAC,GAAGvf,MAAM,CAAC0d,yJAAAA,AAAO,EAAC,IAAM3D,MAAM,CAACyF,MAAM,EAAE,CAAC,CAC/G,GACAzF,MAAM,GACLjI,QAAQ,CACNtM,OAAO,CAACqa,yBAAyB,CAAC9F,MAAM,EAAE7L,OAAO,EAAEyR,SAAS,CAAC,CAAC,GAC7D/S,KAAK,GAAKA,KAAK,KAAKkT,GAAG,GAAG9a,KAAK,GAAGL,IAAI,CAACiI,KAAK,CAAC,CAC/C,CACJ,CAAC;AACJ,CAAC;AAED,MAAMkT,GAAG,GAAA,WAAA,GAAG/c,MAAM,CAACC,GAAG,CAAC,mBAAmB,CAAC;AAE3C,MAAM6c,yBAAyB,GAAGA,CAChC9F,MAAgC,EAChC7L,OAA8B,EAC9BoJ,IAAY,KACiC;IAC7C,MAAMhH,MAAM,GAAG,IAAIyP,WAAW,CAACzI,IAAI,CAAC;IACpC,OAAO0I,cAAc,CAAC,CAAC,GAAGC,MAAM,yJAC9BjgB,MAAM,CAACwE,GAAAA,AAAO,wJACZxE,MAAM,CAAC4d,MAAAA,AAAU,EAAC;YAChBC,GAAG,EAAEA,CAAA,GAAM9D,MAAM,CAAC0F,IAAI,CAAC,IAAIS,UAAU,CAAC5P,MAAM,EAAE2P,MAAM,EAAE3P,MAAM,CAAC6P,UAAU,GAAGF,MAAM,CAAC,CAAC;YAClFnC,KAAK,GAAGvV,MAAM,GAAK2F,OAAO,CAAC3F,MAAM;SAClC,CAAC,EACF,CAAC,EAAEmE,IAAI,EAAE3B,KAAAA,EAAO,KAAI;YAClB,IAAI2B,IAAI,EAAE;gBACR,6JAAO1M,MAAM,CAAC2E,AAAI,EAACmb,GAAG,CAAC;YACzB;YACA,MAAMM,SAAS,GAAGH,MAAM,GAAGlV,KAAK,CAACoV,UAAU;YAC3C,4JAAOngB,MAAM,CAAC2H,IAAAA,AAAO,EAAC;gBACpBoD,KAAK;gBACLqV,SAAS,IAAI9P,MAAM,CAAC6P,UAAU,yJAC1Btf,MAAM,CAACiF,AAAI,EAAU,QACrBjF,MAAM,CAACmF,kJAAAA,AAAI,EAACoa,SAAS,CAAC;aAC3B,CAAC;QACJ,CAAC,CACF,CAAC;AACN,CAAC;AAGM,MAAMC,eAAe,GAAA,WAAA,0JAAG9f,QAAAA,AAAI,EASjC,CAAC,EACD,CACEuD,IAA4B,EAC5BwK,CAAc,KACsC;IAEpD,MAAMgS,oBAAoB,GAAGA,CAC3BpK,KAA4B,EAC5BrJ,KAAqB,KAC2B;QAChD,yJAAIlN,KAAK,CAACia,IAAAA,AAAO,EAAC/M,KAAK,CAAC,EAAE;YACxB,OAAO;gBAACqJ,KAAK;gBAAEvW,KAAK,CAACqF,uJAAAA,AAAK,EAAE;aAAC;QAC/B;QACA,MAAM+Z,OAAO,GAAkB,EAAE;QACjC,IAAI9O,IAAI,GAAG,CAAC;QACZ,IAAIsQ,KAAK,GAAG,CAAC;QACb,IAAI/I,GAAG,GAAkBrM,SAAS;QAClC,IAAIqV,aAAa,wJAAG7gB,KAAK,CAACqF,EAAAA,AAAK,EAAK;QACpC,OAAQkR,KAAK,CAACnO,IAAI;YAChB,KAAK,MAAM;gBAAE;oBACX,MAAMsH,KAAK,GAAG6G,KAAK,CAACnL,KAAK;oBACzByM,GAAG,GAAGnI,KAAK,CAAC,CAAC,CAAC;oBACd,IAAI5C,IAAI,GAAG,IAAI;oBACf,MAAOA,IAAI,IAAI8T,KAAK,GAAG1T,KAAK,CAAC6B,MAAM,CAAE;wBACnC,MAAMrK,KAAK,GAAG1E,KAAK,CAAC8gB,2JAAAA,AAAS,EAAC5T,KAAK,EAAE0T,KAAK,CAAC;wBAC3C,MAAMG,UAAU,GAAGpS,CAAC,CAACjK,KAAK,CAAC;wBAC3B,IAAI,sJAACnE,KAAK,CAAC6S,GAAAA,AAAM,EAACyE,GAAG,EAAEkJ,UAAU,CAAC,EAAE;4BAClC,MAAMF,aAAa,GAAGnR,KAAK,CAAC,CAAC,CAAC;4BAC9B,MAAMsR,eAAe,OAAGhhB,KAAK,CAACmO,6JAAAA,AAAe,EAACkC,KAAK,CAACC,IAAI,CAACpD,KAAK,CAAC,CAAC+T,KAAK,CAAC3Q,IAAI,EAAEsQ,KAAK,CAAC,CAAC;4BACnF,MAAMM,KAAK,wJAAGlhB,KAAK,CAAC4E,MAAS,AAATA,EAAUic,aAAa,EAAEG,eAAe,CAAC;4BAC7D5B,OAAO,CAACE,IAAI,CAAC;gCAACzH,GAAG;gCAAEqJ,KAAK;6BAAC,CAAC;4BAC1BrJ,GAAG,GAAGkJ,UAAU;4BAChBzQ,IAAI,GAAGsQ,KAAK;4BACZ9T,IAAI,GAAG,KAAK;wBACd;wBACA8T,KAAK,GAAGA,KAAK,GAAG,CAAC;oBACnB;oBACA,IAAI9T,IAAI,EAAE;wBACR+T,aAAa,GAAGnR,KAAK,CAAC,CAAC,CAAC;oBAC1B;oBACA;gBACF;YACA,KAAK,MAAM;gBAAE;oBACXmI,GAAG,GAAGlJ,CAAC,sJAAC3O,KAAK,CAAC8gB,MAAAA,AAAS,EAAC5T,KAAK,EAAE0T,KAAK,CAAC,CAAC;oBACtCA,KAAK,GAAGA,KAAK,GAAG,CAAC;oBACjB;gBACF;QACF;QACA,MAAOA,KAAK,GAAG1T,KAAK,CAAC6B,MAAM,CAAE;YAC3B,MAAMrK,KAAK,wJAAG1E,KAAK,CAAC8gB,MAAAA,AAAS,EAAC5T,KAAK,EAAE0T,KAAK,CAAC;YAC3C,MAAMG,UAAU,GAAGpS,CAAC,CAACjK,KAAK,CAAC;YAC3B,IAAI,EAACnE,KAAK,CAAC6S,uJAAAA,AAAM,EAACyE,GAAG,EAAEkJ,UAAU,CAAC,EAAE;gBAClC3B,OAAO,CAACE,IAAI,CAAC;oBAACzH,GAAG;yKAAE7X,KAAK,CAACmO,YAAAA,AAAe,EAACkC,KAAK,CAACC,IAAI,CAACpD,KAAK,CAAC,CAAC+T,KAAK,CAAC3Q,IAAI,EAAEsQ,KAAK,CAAC,CAA2B;iBAAC,CAAC;gBAC1G/I,GAAG,GAAGkJ,UAAU;gBAChBzQ,IAAI,GAAGsQ,KAAK;YACd;YACAA,KAAK,GAAGA,KAAK,GAAG,CAAC;QACnB;QACA,MAAMO,aAAa,wJAAGnhB,KAAK,CAAC4E,MAAS,AAATA,EAAUic,aAAa,uJAAE7gB,KAAK,CAACmO,YAAAA,AAAe,EAACkC,KAAK,CAACC,IAAI,CAACpD,KAAK,CAAC,CAAC+T,KAAK,CAAC3Q,IAAI,EAAEsQ,KAAK,CAAC,CAAC,CAAC;QACjH,MAAM3U,MAAM,GAAGjM,KAAK,CAACmO,iKAAAA,AAAe,EAACiR,OAAO,CAAC;QAC7C,OAAO;kKAACle,MAAM,CAACmF,AAAI,EAAC;gBAACwR,GAAG;gBAAEsJ,aAAuC;aAAC,CAAC;YAAElV,MAAM;SAAC;IAC9E,CAAC;IAED,MAAMmV,aAAa,IACjB7K,KAA4B,6KAE5BrU,IAAI,CAACiF,WAAAA,AAAa,EAAC;YACjB1C,OAAO,GAAGC,KAAqB,IAAI;gBACjC,MAAM,CAAC2c,YAAY,EAAEpV,MAAM,CAAC,GAAG0U,oBAAoB,CAACpK,KAAK,EAAE7R,KAAK,CAAC;gBACjE,4JAAO1E,KAAK,CAACia,IAAAA,AAAO,EAAChO,MAAM,CAAC,GACxBmV,aAAa,CAACC,YAAY,CAAC,6KAC3Bnf,IAAI,CAAC2C,KAAAA,AAAO,4KAAC3C,IAAI,CAAC4C,GAAAA,AAAK,EAACmH,MAAM,CAAC,EAAE,IAAMmV,aAAa,CAACC,YAAY,CAAC,CAAC;YACzE,CAAC;YACDtc,SAAS,GAAGwC,KAAK,GACfrG,MAAM,CAAC+E,uJAAK,AAALA,EAAMsQ,KAAK,EAAE;oBAClBvM,MAAM,EAAEA,CAAA,OAAM9H,IAAI,CAACwG,6KAAAA,AAAS,EAACnB,KAAK,CAAC;oBACnC4C,MAAM,GAAG8B,MAAM,6KAAK/J,IAAI,CAAC2C,KAAAA,AAAO,4KAAC3C,IAAI,CAAC4C,GAAAA,AAAK,uJAAC9E,KAAK,AAACiK,AAAE,CAAFA,CAAGgC,MAAM,CAAC,CAAC,EAAE,8KAAM/J,IAAI,CAACwG,OAAAA,AAAS,EAACnB,KAAK,CAAC;iBAC3F,CAAC;YACJtC,MAAM,GAAG8H,IAAI,GACX7L,MAAM,CAAC+E,uJAAAA,AAAK,EAACsQ,KAAK,EAAE;oBAClBvM,MAAM,EAAEA,CAAA,6KAAM9H,IAAI,CAACyY,QAAAA,AAAU,EAAC5N,IAAI,CAAC;oBACnC5C,MAAM,EAAG8B,MAAM,6KAAK/J,IAAI,CAAC2C,MAAAA,AAAO,4KAAC3C,IAAI,CAAC4C,GAAAA,AAAK,uJAAC9E,KAAK,AAACiK,AAAE,CAAFA,CAAGgC,MAAM,CAAC,CAAC,EAAE,8KAAM/J,IAAI,CAACyY,QAAU,AAAVA,EAAW5N,IAAI,CAAC;iBAC3F;SACJ,CAAC;IACJ,OAAO,IAAIpJ,UAAU,EAAC5B,OAAO,CAACuH,yKAAAA,AAAY,EAAClE,SAAS,CAACjB,IAAI,CAAC,EAAEid,aAAa,uJAAClgB,MAAM,CAAK,AAAJiF,EAAM,CAAC,CAAC,CAAC;AAC5F,CAAC,CACF;AAGM,MAAMmb,OAAO,GAAA,WAAA,2JAAG1gB,OAAAA,AAAI,EAIzB,CAAC,EACD,CAAUuD,IAA4B,EAAEod,SAAiB,2JACvDzgB,OAAAA,AAAI,EAACqD,IAAI,EAAEsN,OAAO,CAAC8P,SAAS,CAAC,EAAEnd,MAAM,CAAC,CACzC;AAGM,MAAMod,aAAa,GAAA,WAAA,0JAAG5gB,QAAAA,AAAI,EAW/B,CAAC,EACD,CACEuD,IAA4B,EAC5Bod,SAAiB,EACjBvL,QAAgC,GAEhCpQ,eAAe,CAACzB,IAAI,kKAAE7B,KAAK,CAACmf,QAAAA,AAAW,EAACF,SAAS,CAAC,0JAAE7f,QAAQ,CAACggB,AAAM,EAAC1L,QAAQ,CAAC,CAAC,CACjF;AAGM,MAAM2L,QAAQ,GAAA,WAAA,2JAAG/gB,OAAAA,AAAI,EAS1B,CAAC,EACD,CACEuD,IAA4B,EAC5BgQ,MAAgC,KACI;IACpC,MAAMd,MAAM,IACV+C,KAAyB,2JAEzBtV,OAAAA,AAAI,uJACFL,KAAK,CAACmhB,CAAAA,AAAI,EAACxL,KAAK,CAAC,wJACjB/V,MAAM,AAAC6H,AAAG,CAAHA,uJAAIhH,MAAM,CAAC+E,CAAAA,AAAK,EAAC;YACtB+D,MAAM,EAAEA,CAAA,6KACN9H,IAAI,CAACsC,MAAAA,AAAQ,EAAC;oBACZC,OAAO,EAAGC,KAAqB,IAAKxC,IAAI,CAAC2C,+KAAAA,AAAO,GAAC3C,IAAI,CAAC4C,4KAAAA,AAAK,EAACJ,KAAK,CAAC,EAAE,IAAM2O,MAAM,CAAC+C,KAAK,CAAC,CAAC;oBACxFrR,SAAS,wKAAE7C,IAAI,CAAC8C,EAAI;oBACpBC,MAAM,EAAEA,CAAA,yKAAM/C,IAAI,CAACgD,EAAAA;iBACpB,CAAC;YACJiF,MAAM,sJAAE3J,IAAI,CAACyF,GAAAA,AAAK,EAAC;gBACjBlB,SAAS,wKAAE7C,IAAI,CAACwG,OAAS;gBACzBuC,SAAS,EAAEA,CAAA,yKAAM/I,IAAI,CAACgD,EAAAA;aACvB;SACF,CAAC,CAAC,EACHnD,OAAO,CAAC+G,gKAAM,CACf;IACH,OAAO,IAAInF,UAAU,oKACnB5B,OAAO,CAACmJ,WAAAA,AAAgB,GAAE9B,KAAK,GAC7B+K,MAAM,CAACrT,IAAI,uJACTT,MAAM,CAACoJ,EAAAA,AAAM,EAACL,KAAK,CAAC,wJACpB/I,MAAM,AAAC6H,AAAG,CAAHA,EAAKkO,KAAK,GAAKhR,SAAS,CAACjB,IAAI,CAAC,CAACrD,IAAI,2KAACoB,IAAI,CAACiD,IAAAA,AAAM,EAACkO,MAAM,CAAC+C,KAAK,CAAC,CAAC,CAAC,CAAC,CACxE,CACF,CACF;AACH,CAAC,CACF;AAGM,MAAMyL,SAAS,GAAA,WAAA,2JAAGjhB,OAAAA,AAAI,EAI3B,CAAC,EACD,CAAUuD,IAA4B,EAAE6R,QAAgC,2JACtElV,OAAAA,AAAI,EAACqD,IAAI,EAAEwd,QAAQ,sJAAC1hB,KAAK,CAACkW,EAAAA,AAAK,EAACH,QAAQ,CAAC,CAAC,CAAC,CAC9C;AAGM,MAAM8L,gBAAgB,GAAA,WAAA,GAAGlhB,+JAAAA,AAAI,EAIlC,CAAC,EACD,CAAiBuD,IAA4B,EAAE2N,QAAkC,KAAiC;IAChH,MAAMuB,MAAM,2JAAsFvS,OAAAA,AAAI,0JACpGX,OAASyhB,AAAI,CAAL,CAACA,AAAK9P,QAAQ,CAAC,wJACvBzR,MAAM,AAAC6H,AAAG,CAAHA,uJAAIhH,MAAM,CAAC+E,CAAAA,AAAK,EAAC;QACtB+D,MAAM,EAAEA,CAAA,6KACN9H,IAAI,CAACsC,MAAAA,AAAQ,EAAC;gBACZC,OAAO,GAAGC,KAAqB,2JAAK5D,OAAAA,AAAI,4KAACoB,IAAI,CAAC4C,GAAAA,AAAK,EAACJ,KAAK,CAAC,4KAAExC,IAAI,CAAC2C,KAAAA,AAAO,EAAC,IAAMwO,MAAM,CAAC,CAAC;gBACvFtO,SAAS,wKAAE7C,IAAI,CAAC8C,EAAI;gBACpBC,MAAM,EAAEA,CAAA,yKAAM/C,IAAI,CAACgD,EAAAA;aACpB,CAAC;QACJiF,MAAM,GAAGgK,MAAM,sKACbpS,OAAO,CAAC+G,CAAAA,AAAM,uJAACzI,MAAM,CAAC4F,EAAK,AAALA,EAAMkO,MAAM,EAAE;gBAClCpP,SAAS,wKAAE7C,IAAI,CAAC8C,EAAI;gBACpBiG,SAAS,EAAEA,CAAA,yKAAM/I,IAAI,CAACgD,EAAAA;aACvB,CAAC;KACL,CAAC,CAAC,iKACHnD,OAAO,CAAC+G,CAAM,CACf;IACD,OAAO,IAAInF,UAAU,yJAAC7C,OAAAA,AAAI,EAACsE,SAAS,CAACjB,IAAI,CAAC,MAAEjC,IAAI,CAACiD,0KAAAA,AAAM,EAACkO,MAAM,CAAC,CAAC,CAAC;AACnE,CAAC,CACF;AAGM,MAAM8G,cAAc,GAAGA,CAAA,GAC5B,IAAIxW,UAAU,oKACZ5B,OAAO,CAACuN,UAAAA,AAAe,EAA4E,CACpG;AAGI,MAAMyS,UAAU,GAAA,WAAA,2JAAGnhB,OAAAA,AAAI,EAS5B,CAAC,EACD,CACEuD,IAA4B,EAC5BqQ,IAA+B,2JACW1T,OAAAA,AAAI,EAACqD,IAAI,EAAE6d,cAAc,CAACxN,IAAI,EAAE3O,OAAO,CAACW,IAAI,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC,CAAC,CAAC,CACzG;AAGM,MAAMwb,cAAc,GAAA,WAAA,2JAAGphB,OAAAA,AAAI,EAWhC,CAAC,EACD,CACEuD,IAA4B,EAC5BqQ,IAA+B,EAC/ByN,OAAuC,KACY;IACnD,MAAMtQ,QAAQ,IACZ/K,OAAwD,6KAExD1E,IAAI,CAACiF,WAAAA,AAAa,EAAC;YACjB1C,OAAO,GAAG2G,KAAa,GACrBlJ,IAAI,CAAC2C,+KAAAA,AAAO,4KACV3C,IAAI,CAACyE,QAAAA,AAAU,+KACbjE,OAAO,CAAC0E,AAAK,EAAiCR,OAAO,kKAAE5D,KAAaiH,AAAE,EAACmB,KAAJ,AAAS,CAAC,AAATnB,CAAU,CAC/E,EACD,IAAM0H,QAAQ,CAAC/K,OAAO,CAAC,CACxB;YACH7B,SAAS,GAAGwC,KAAK,6KACfrF,IAAI,CAACyE,QAAAA,AAAU,8KACbjE,OAAO,CAAC0E,CAAAA,AAAK,EACXR,OAAO,kKACP5D,YAAsB,AAAT0F,AAAD,CAACA,CAAUnB,KAAK,CAAC,CAC9B,CACF;YACHtC,MAAM,EAAEA,CAAA,6KACN/C,IAAI,CAACyE,QAAAA,AAAU,GACbjE,OAAO,CAAC0E,4KAAAA,AAAK,EAAiCR,OAAO,8JAAE5D,MAAgB,CAAC,KAAL,CAACyE;SAEzE,CAAC;IACJ,OAAO,IAAI9D,UAAU,KACnB5B,OAAO,CAACmJ,0KAAgB,AAAhBA,EAAkB9B,KAAK,4JAC7BtI,OAAI,AAAJA,+KACE4B,OAAO,AAAC8D,AAAI,CAAJA,CAAsC,yJAC9CnG,MAAM,AAAC6hB,AAAG,CAAHA,8KAAIxf,OAAO,AAAC8D,AAAI,CAAJA,CAAsC,CAAC,yJAC1DnG,MAAOsN,AAAD,AAAI,CAAHA,CAAI,CAAC,CAACvD,IAAI,CAAC,GAChBhF,SAAS,CAACjB,IAAI,CAAC,CAACrD,IAAI,EAClBiB,OAAO,CAAC4S,sKAAAA,AAAS,iKAAC5S,OAAO,CAAC6S,KAAU,CAAC,4KACrC1S,IAAI,CAACiD,IAAAA,AAAM,EAACwM,QAAQ,CAACvH,IAAI,CAAC,CAAC,wLAC3BpI,QAAgB6S,AAAK,EAACzL,KAAP,AAAY,CAAXyL,AAAY,wJAC5BxU,MAAM,CAACoJ,EAAAA,AAAM,EAACL,KAAK,CAAC,CACrB,CACF,wJACD/I,MAAM,AAACsN,AAAG,CAAHA,CAAI,CAAC,CAACnK,CAAC,EAAE0G,KAAK,CAAC,GACpB9E,SAAS,CAACoP,IAAI,CAAC,CAAC1T,IAAI,oKAClBiB,OAAO,CAAC4S,IAAAA,AAAS,iKAAC5S,OAAO,CAAC6S,KAAU,CAAC,4KACrC1S,IAAI,CAACiD,IAAM,AAANA,EAAOwM,QAAQ,CAACzH,KAAK,CAAC,CAAC,wLAC5BlI,QAAgB6S,AAAK,EAACzL,KAAP,AAAY,CAAXyL,AAAY,wJAC5BxU,MAAM,CAACoJ,EAAAA,AAAM,EAACL,KAAK,CAAC,CACrB,CACF,uJACD/I,MAAM,CAAC6H,AAAG,AAAHA,EAAI,CAAC,CAACkC,IAAI,EAAEF,KAAK,CAAC,KAAI;YAC3B,MAAM+G,OAAO,GAAGA,CACdkR,QAAiB,EACjBC,SAAkB,6KAElBlgB,IAAI,CAACiF,WAAAA,AAAa,EAAC;oBACjB1C,OAAO,GAAG+D,IAAa,IAAI;wBACzB,IAAIA,IAAI,IAAI,CAAC2Z,QAAQ,EAAE;4BACrB,+JAAOrhB,OAAI,AAAJA,4KACLoB,IAAI,CAACyE,QAAU,AAAVA,+KAAWjE,OAAO,AAACuF,AAAI,CAAJA,CAAKmC,IAAI,CAAC,CAAC,4KACnClI,IAAI,CAAC2C,KAAAA,AAAO,kKAAC7B,QAAaiD,AAAK,EAAC,EAAP,CAACA;gCACxBsL,KAAK,EAAEA,CAAA,GAAM6Q,SAAS,yKAAGlgB,IAAI,CAACgD,EAAI,GAAG+L,OAAO,CAAC,IAAI,EAAEmR,SAAS,CAAC;gCAC7Drd,SAAS,wKAAE7C,IAAI,CAACwG,OAAS;gCACzBuC,SAAS,GAAGiC,KAAK,2JAAKpM,OAAAA,AAAI,4KAACoB,IAAI,CAAC4C,GAAK,AAALA,EAAMoI,KAAK,CAAC,4KAAEhL,IAAI,CAAC2C,KAAAA,AAAO,EAAC,IAAMoM,OAAO,CAACkR,QAAQ,EAAEC,SAAS,CAAC,CAAC;6BAC/F,CAAC,CAAC,CACJ;wBACH;wBACA,IAAI,CAAC5Z,IAAI,IAAI,CAAC4Z,SAAS,EAAE;4BACvB,+JAAOthB,OAAAA,AAAI,4KACToB,IAAI,CAACyE,QAAAA,AAAU,+KAACjE,OAAO,AAACuF,AAAI,CAAJA,CAAKiC,KAAK,CAAC,CAAC,EACpChI,IAAI,CAAC2C,+KAAAA,AAAO,kKAAC7B,QAAaiD,AAAK,EAAC,EAAP,CAACA;gCACxBsL,KAAK,EAAEA,CAAA,GAAM4Q,QAAQ,yKAAGjgB,IAAI,CAACgD,EAAI,GAAG+L,OAAO,CAACkR,QAAQ,EAAE,IAAI,CAAC;gCAC3Dpd,SAAS,wKAAE7C,IAAI,CAACwG,OAAS;gCACzBuC,SAAS,GAAGiC,KAAK,OAAKpM,2JAAAA,AAAI,4KAACoB,IAAI,CAAC4C,GAAAA,AAAK,EAACoI,KAAK,CAAC,4KAAEhL,IAAI,CAAC2C,KAAO,AAAPA,EAAQ,IAAMoM,OAAO,CAACkR,QAAQ,EAAEC,SAAS,CAAC,CAAC;6BAC/F,CAAC,CAAC,CACJ;wBACH;wBACA,OAAOnR,OAAO,CAACkR,QAAQ,EAAEC,SAAS,CAAC;oBACrC,CAAC;oBACDrd,SAAS,wKAAE7C,IAAI,CAACwG,OAAS;oBACzBzD,MAAM,EAAEA,CAAA,yKAAM/C,IAAI,CAACgD,EAAAA;iBACpB,CAAC;YACJ,OAAOpE,+JAAI,AAAJA,EACLsE,SAAS,CAAC6c,OAAO,CAAC,qKAClBlgB,OAAO,CAAC4S,IAAAA,AAAS,iKAAC5S,OAAO,CAAC6S,KAAU,CAAC,4KACrC1S,IAAI,CAACiD,IAAAA,AAAM,EAAC8L,OAAO,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC,CACnC;QACH,CAAC,CAAC,CACH,CACF,CACF;AACH,CAAC,CACF;AAGM,MAAMoR,WAAW,GAAA,WAAA,2JAAGzhB,OAAAA,AAAI,EAG7B,CAAC,EAAE,CAAcuD,IAA4B,EAAEme,OAAW,GAC1D,IAAI3e,UAAU,CACZ7C,+JAAAA,AAAI,EACFsE,SAAS,CAACjB,IAAI,CAAC,qKACfpC,OAAO,CAACuH,OAAAA,AAAY,4KAClBpH,IAAI,CAACyI,KAAAA,AAAO,EAAC,MAAK;QAChB,MAAM0I,MAAM,IACVkP,OAAgB,6KAEhBrgB,IAAI,CAACiF,WAAAA,AAAa,EAAC;gBACjB1C,OAAO,GAAGyI,KAAqB,IAAI;oBACjC,MAAMkS,OAAO,GAAkB,EAAE;oBACjC,IAAIoD,UAAU,GAAGD,OAAO;oBACxB,KAAK,MAAMtW,MAAM,IAAIiB,KAAK,CAAE;wBAC1B,IAAIsV,UAAU,EAAE;4BACdA,UAAU,GAAG,KAAK;4BAClBpD,OAAO,CAACE,IAAI,CAACrT,MAAM,CAAC;wBACtB,CAAC,MAAM;4BACLmT,OAAO,CAACE,IAAI,CAACgD,OAAO,CAAC;4BACrBlD,OAAO,CAACE,IAAI,CAACrT,MAAM,CAAC;wBACtB;oBACF;oBACA,+JAAOnL,OAAAA,AAAI,4KACToB,IAAI,CAAC4C,GAAAA,AAAK,uJAAC9E,KAAK,CAACmO,YAAAA,AAAe,EAACiR,OAAO,CAAC,CAAC,4KAC1Cld,IAAI,CAAC2C,KAAAA,AAAO,EAAC,IAAMwO,MAAM,CAACmP,UAAU,CAAC,CAAC,CACvC;gBACH,CAAC;gBACDzd,SAAS,EAAE7C,IAAI,CAACwG,6KAAS;gBACzBzD,MAAM,EAAEA,CAAA,yKAAM/C,IAAI,CAACgD,EAAAA;aACpB,CAAC;QACJ,OAAOmO,MAAM,CAAC,IAAI,CAAC;IACrB,CAAC,CAAC,CACH,CACF,CACF,CAAC;AAGG,MAAMoP,kBAAkB,GAAA,WAAA,2JAAG7hB,OAAAA,AAAI,EAiBpC,CAAC,EACD,CACEuD,IAA4B,EAC5B,EAAEsD,GAAG,EAAEib,MAAM,EAAEzQ,KAAAA,EAId,2JAEDnR,OAAAA,AAAI,EACF0F,IAAI,CAACyL,KAAK,CAAC,EACXqD,MAAM,KAACxU,2JAAAA,AAAI,EAACqD,IAAI,EAAEke,WAAW,CAACK,MAAM,CAAC,CAAC,CAAC,EACvCpN,MAAM,CAAC9O,IAAI,CAACiB,GAAG,CAAC,CAAC,CAClB,CACJ;AAGM,MAAMkb,cAAc,GAAA,WAAA,2JAAG/hB,OAAAA,AAAI,EAIhC,CAAC,EACD,CAAUuD,IAA4B,EAAE6R,QAAgC,GACtElV,+JAAAA,AAAI,EAACqD,IAAI,EAAEye,aAAa,sJAAC3iB,KAAK,CAACkW,EAAAA,AAAK,EAACH,QAAQ,CAAC,CAAC,CAAC,CACnD;AAGM,MAAM4M,aAAa,GAAA,WAAA,IAAGhiB,8JAAAA,AAAI,EAS/B,CAAC,EACD,CACEuD,IAA4B,EAC5BgQ,MAAgC,GACK,IAAIxQ,UAAU,yJAAC7C,OAAAA,AAAI,EAACsE,SAAS,CAACjB,IAAI,CAAC,EAAEpC,OAAO,CAAC6gB,2KAAAA,AAAa,EAACzO,MAAM,CAAC,CAAC,CAAC,CAC5G;AAGM,MAAMuF,qBAAqB,GAAA,WAAA,IAAG9Y,8JAAAA,AAAI,EAIvC,CAAC,EACD,CAAiBuD,IAA4B,EAAE2N,QAAkC,GAC/E,IAAInO,UAAU,yJAAC7C,OAAAA,AAAI,EAACsE,SAAS,CAACjB,IAAI,CAAC,qKAAEpC,OAAO,CAAC2X,gBAAAA,AAAqB,EAAC5H,QAAQ,CAAC,CAAC,CAAC,CACjF;AAGM,MAAM+Q,OAAO,GAAGA,CAAIzX,KAAQ,EAAEzG,IAAqB,GACxDme,MAAM,CAAC1X,KAAK,GAAGuK,CAAC,yJAAKzU,MAAM,CAACmF,AAAI,EAAC;YAACsP,CAAC;YAAEhR,IAAI,CAACgR,CAAC,CAAC;SAAU,CAAC,CAAC;AAGnD,MAAMnP,IAAI,GAAGA,CAAwB,GAAG2E,EAAM,GAAgCkO,YAAY,CAAClO,EAAE,CAAC;AAG9F,MAAMjD,GAAG,GAAA,WAAA,2JAAGtH,OAAAA,AAAI,EAIrB,CAAC,EACD,CAAauD,IAA4B,EAAEwK,CAAc,GACvD,IAAIhL,UAAU,yJAAC7C,OAAAA,AAAI,EAACsE,SAAS,CAACjB,IAAI,CAAC,EAAEpC,OAAO,CAACmb,oKAAAA,AAAM,uJAACld,KAAK,CAACkI,AAAG,EAACyG,CAAC,CAAC,CAAC,CAAC,CAAC,CACtE;AAGM,MAAMoU,QAAQ,GAAA,WAAA,0JAAGniB,QAAAA,AAAI,EAO1B,CAAC,EACD,CACEuD,IAA4B,EAC5BI,CAAI,EACJoK,CAAmC,KACR;IAC3B,MAAMrK,WAAW,IAAIC,CAAI,OACvBrC,IAAI,CAACsC,4KAAQ,AAARA,EAAS;YACZC,OAAO,GAAGC,KAAqB,IAAI;gBACjC,MAAM,CAACse,KAAK,EAAE9V,KAAK,CAAC,OAAGlN,KAAK,CAAC+iB,sJAAAA,AAAQ,EAACre,KAAK,EAAEH,CAAC,EAAEoK,CAAC,CAAC;gBAClD,iLAAOzM,IAAI,CAAC2C,KAAAA,AAAO,MACjB3C,IAAI,CAAC4C,yKAAAA,AAAK,EAACoI,KAAK,CAAC,EACjB,IAAM5I,WAAW,CAAC0e,KAAK,CAAC,CACzB;YACH,CAAC;YACDje,SAAS,wKAAE7C,IAAI,CAAC8C,EAAI;YACpBC,MAAM,EAAEA,CAAA,wKAAM/C,IAAI,CAACgD,GAAAA;SACpB,CAAC;IACJ,OAAO,IAAIvB,UAAU,yJAAC7C,OAAAA,AAAI,EAACsE,SAAS,CAACjB,IAAI,CAAC,4KAAEjC,IAAI,CAACiD,IAAAA,AAAM,EAACb,WAAW,CAACC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC3E,CAAC,CACF;AAGM,MAAM0e,cAAc,GAAA,WAAA,2JAAGriB,OAAI,AAAJA,EAW5B,CAAC,EACD,CACEuD,IAA4B,EAC5BI,CAAI,EACJoK,CAA0D,GAE1DhE,OAAO,CAAC,MAAK;QACX,MAAMrG,WAAW,GACfC,CAAI,6KAEJrC,IAAI,CAACsC,OAAQ,AAARA,EAAS;gBACZC,OAAO,GAAGC,KAAqB,2JAC7B5D,OAAAA,AAAI,wJACFT,MAAM,CAACsK,GAAAA,AAAO,EAAC,MAAK;wBAClB,MAAMgJ,OAAO,GAAc,EAAE;wBAC7B,MAAMnR,IAAI,IAAIyJ,MAAU,yJACtB5L,MAAM,CAAC8L,AAAI,EAAC,MAAK;gCACfwH,OAAO,CAAC2L,IAAI,CAACrT,MAAM,CAAC;4BACtB,CAAC,CAAC;wBACJ,QAAOnL,8JAAAA,AAAI,EACT4D,KAAK,EACLrE,MAAM,CAACoT,wJAAAA,AAAM,EAAClP,CAAC,EAAE,CAACA,CAAC,EAAEoR,CAAC,2JACpB7U,OAAAA,AAAI,EACF6N,CAAC,CAACpK,CAAC,EAAEoR,CAAC,CAAC,wJACPtV,MAAM,CAACwE,GAAAA,AAAO,EAAC,CAAC,CAACN,CAAC,EAAEoR,CAAC,CAAC,2JAAK7U,OAAAA,AAAI,EAAC0B,IAAI,CAACmT,CAAC,CAAC,wJAAEtV,KAAO8K,AAAE,CAAH,CAACA,AAAG5G,CAAC,CAAC,CAAC,CAAC,CACxD,CAAC,wJACJlE,MAAM,CAAC4F,CAAAA,AAAK,EAAC;4BACXlB,SAAS,GAAGkI,KAAK,IAAI;gCACnB,IAAI0G,OAAO,CAAC5E,MAAM,KAAK,CAAC,EAAE;oCACxB,0KAAOhN,OAAO,CAACgG,GAAAA,AAAQ,EAAC7F,IAAI,CAAC4C,6KAAAA,AAAK,uJAAC9E,KAAK,CAACmO,YAAe,AAAfA,EAAgBwF,OAAO,CAAC,CAAC,4KAAEzR,IAAI,CAAC8C,EAAAA,AAAI,EAACiI,KAAK,CAAC,CAAC;gCACvF;gCACA,iLAAO/K,IAAI,CAAC8C,EAAAA,AAAI,EAACiI,KAAK,CAAC;4BACzB,CAAC;4BACDhC,SAAS,GAAG1G,CAAC,6KAAKrC,IAAI,CAAC2C,KAAAA,AAAO,4KAAC3C,IAAI,CAAC4C,GAAAA,AAAK,uJAAC9E,KAAK,CAACmO,YAAAA,AAAe,EAACwF,OAAO,CAAC,CAAC,EAAE,IAAMrP,WAAW,CAACC,CAAC,CAAC;yBAChG,CAAC,CACH;oBACH,CAAC,CAAC,iKACFxC,OAAO,CAAC+G,CAAM,CACf;gBACH/D,SAAS,wKAAE7C,IAAI,CAAC8C,EAAI;gBACpBC,MAAM,EAAEA,CAAA,yKAAM/C,IAAI,CAACgD,EAAAA;aACpB,CAAC;QACJ,OAAO,IAAIvB,UAAU,EAAC7C,8JAAAA,AAAI,EAACsE,SAAS,CAACjB,IAAI,CAAC,qKAAEpC,OAAO,CAACuH,OAAAA,AAAY,EAAChF,WAAW,CAACC,CAAC,CAAC,CAAC,CAAC,CAAC;IACpF,CAAC,CAAC,CACL;AAGM,MAAM2e,OAAO,GAAA,WAAA,2JAAGtiB,OAAAA,AAAI,EAezB,CAAC,EACD,CACEuD,IAA4B,EAC5BsJ,OAGC,IAC4B3M,8JAAAA,AAAI,EAACqD,IAAI,EAAEya,QAAQ,CAACnR,OAAO,CAAC1I,SAAS,CAAC,EAAEmD,GAAG,CAACuF,OAAO,CAACxC,SAAS,CAAC,CAAC,CAC/F;AAGM,MAAM8I,SAAS,GAAA,WAAA,2JAAGnT,OAAAA,AAAI,EAM3B,CAAC,EACD,CAAauD,IAA4B,EAAEwK,CAA4C,GACrF,IAAIhL,UAAU,KAAC7C,2JAAI,AAAJA,EAAKsE,SAAS,CAACjB,IAAI,CAAC,oKAAEpC,OAAO,CAACmb,EAAM,AAANA,EAAOvO,CAAC,CAAC,CAAC,CAAC,CAC3D;AAGM,MAAMwU,eAAe,GAAA,WAAA,2JAAGviB,OAAAA,AAAI,EASjC,CAAC,EACD,CACEuD,IAA4B,EAC5BwK,CAAmE,GAC9B,IAAIhL,UAAU,EAAC7C,8JAAAA,AAAI,EAACsE,SAAS,CAACjB,IAAI,CAAC,EAAEpC,OAAO,CAACqhB,0KAAAA,AAAY,EAACzU,CAAC,CAAC,CAAC,CAAC,CACtG;AAGM,MAAM0U,SAAS,GAAA,WAAA,2JAAGziB,OAAAA,AAAI,EAI3B,CAAC,EACD,CAAcuD,IAA4B,EAAEwK,CAAyB,2JACnE7N,OAAI,AAAJA,EAAKqD,IAAI,EAAEmf,cAAc,EAAE3N,CAAC,uJAAK3V,KAAK,CAACqZ,UAAAA,AAAY,EAAC1K,CAAC,CAACgH,CAAC,CAAC,CAAC,CAAC,CAAC,CAC9D;AAGM,MAAM2N,cAAc,GAAA,WAAA,2JAAG1iB,OAAAA,AAAI,EAIhC,CAAC,EACD,CAAcuD,IAA4B,EAAEwK,CAA4B,2JACtE7N,OAAAA,AAAI,EAACqD,IAAI,EAAE4P,SAAS,sJAAC/T,KAAK,CAAC6E,IAAO,AAAPA,EAAQ8J,CAAC,CAAC,CAAC,CAAC,CAC1C;AAGM,MAAM4U,oBAAoB,GAAA,WAAA,2JAAG3iB,OAAAA,AAAI,EAStC,CAAC,EACD,CACEuD,IAA4B,EAC5BwK,CAAmD,2JACb7N,OAAAA,AAAI,EAACqD,IAAI,EAAEgX,mBAAmB,CAACxM,CAAC,CAAC,EAAE2U,cAAc,qJAACziB,WAAQ,CAAC,CAAC,CACrG;AAGM,MAAM2iB,eAAe,GAAA,WAAA,2JAAG5iB,OAAAA,AAAI,EASjC,CAAC,EACD,CACEuD,IAA4B,EAC5BwK,CAAgD,2JAEhD7N,OAAAA,AAAI,EAACqD,IAAI,EAAEgX,mBAAmB,CAAExF,CAAC,2JAAK7U,QAAAA,AAAI,EAAC6N,CAAC,CAACgH,CAAC,CAAC,wJAAEtV,MAAM,AAAC6H,AAAG,CAAHA,kJAAIlI,KAAK,CAACqZ,SAAY,CAAC,CAAC,CAAC,EAAEiK,cAAc,qJAACziB,WAAQ,CAAC,CAAC,CAC/G;AAGM,MAAMsa,mBAAmB,GAAA,WAAA,GAAGva,+JAAAA,AAAI,EASrC,CAAC,EACD,CACEuD,IAA4B,EAC5BwK,CAAsC,KACD;IACrC,MAAM7B,IAAI,IACR6O,QAAqB,IACgE;QACrF,MAAMhX,IAAI,GAAGgX,QAAQ,CAAChX,IAAI,EAAE;QAC5B,IAAIA,IAAI,CAACoI,IAAI,EAAE;YACb,WAAO7K,IAAI,CAACiF,iLAAAA,AAAa,EAAC;gBACxB1C,OAAO,GAAG6R,IAAI,GAAKxJ,IAAI,CAACwJ,IAAI,CAAClT,MAAM,CAACuY,QAAQ,CAAC,EAAE,CAAC;gBAChD5W,SAAS,wKAAE7C,IAAI,CAACwG,OAAS;gBACzBzD,MAAM,EAAE/C,IAAI,CAAC8F,2KAAAA;aACd,CAAC;QACJ,CAAC,MAAM;YACL,MAAMoD,KAAK,GAAGzG,IAAI,CAACyG,KAAK;YACxB,OAAOrJ,OAAO,CAAC+G,oKAAAA,AAAM,wJACnBzI,MAAM,AAAC6H,AAAG,CAAHA,CAAIyG,CAAC,CAACvD,KAAK,CAAC,GAAGwK,EAAE,6KACtB1T,IAAI,CAAC2C,KAAAA,AAAO,4KACV3C,IAAI,CAAC4C,GAAAA,AAAK,uJAAC9E,KAAK,AAACiK,AAAE,CAAFA,CAAG2L,EAAE,CAAC,CAAC,EACxB,IAAM9I,IAAI,CAAC6O,QAAQ,CAAC,CACrB,CAAC,CACL;QACH;IACF,CAAC;IACD,OAAO,IAAIhY,UAAU,yJAAC7C,OAAI,AAAJA,EACpBsE,SAAS,CAACjB,IAAI,CAAC,4KACfjC,IAAI,CAACiD,IAAAA,AAAM,2KAACjD,IAAI,CAACyI,MAAAA,AAAO,EAAC,IAAMmC,IAAI,sJAAC9M,KAAK,CAACqF,EAAAA,AAAK,GAAK,CAACjC,MAAM,CAACuY,QAAQ,CAAC,EAAE,CAAC,CAAC,CAAC,CAC3E,CAAC;AACJ,CAAC,CACF;AAGM,MAAM8H,YAAY,GAAA,WAAA,2JAAG7iB,OAAAA,AAAI,EAW9B,CAAC,EACD,CACEuD,IAA4B,EAC5BuK,CAAS,EACTC,CAAsC,GAEtC,IAAIhL,UAAU,yJACZ7C,OAAAA,AAAI,EACFsE,SAAS,CAACjB,IAAI,CAAC,qKACfpC,OAAO,CAAC4S,IAAAA,AAAS,EAAC5S,OAAO,CAAC6S,oKAAU,CAAC,EACrC7S,OAAO,CAACkb,6KAAAA,AAAe,EAACtO,CAAC,EAAED,CAAC,CAAC,qKAC7B3M,OAAO,CAACmb,CAAAA,AAAM,mJAACld,KAAQ,AAAH,CAACiK,AAAG,CACzB,CACF,CACJ;AAGM,MAAM2U,QAAQ,GAAA,WAAA,2JAAGhe,OAAAA,AAAI,EAI1B,CAAC,EACD,CAAcuD,IAA4B,EAAEwK,CAAmB,GAC7D,IAAIhL,UAAU,yJAAC7C,OAAAA,AAAI,EAACsE,SAAS,CAACjB,IAAI,CAAC,qKAAEpC,OAAO,CAAC6c,GAAAA,AAAQ,EAACjQ,CAAC,CAAC,CAAC,CAAC,CAC7D;AAGM,MAAM+U,aAAa,GAAA,WAAA,2JAAG9iB,OAAAA,AAAI,EAM/B,CAAC,EACD,CAAcuD,IAA4B,EAAEwK,CAA6C,GACvF,IAAIhL,UAAU,yJAAC7C,OAAAA,AAAI,EAACsE,SAAS,CAACjB,IAAI,CAAC,qKAAEpC,OAAO,CAAC2hB,QAAAA,AAAa,EAAC/U,CAAC,CAAC,CAAC,CAAC,CAClE;AAGM,MAAMgV,KAAK,GAAA,WAAA,2JAAG/iB,OAAI,AAAJA,GAelBub,IAAI,GAAKrY,QAAQ,CAACqY,IAAI,CAAC,CAAC,CAAC,CAAC,EAC3B,CACEhY,IAA4B,EAC5BqQ,IAA+B,EAC/B/G,OAEC,GAEDmW,SAAS,CAACzf,IAAI,EAAEqQ,IAAI,EAAE;QACpBqP,MAAM,EAAEhjB,+JAAQ;QAChBijB,OAAO,sJAAEjjB,WAAQ;QACjB4B,YAAY,EAAEgL,OAAO,EAAEhL;KACxB,CAAC,CACL;AAGM,MAAMshB,QAAQ,GAAA,WAAA,2JAAGnjB,OAAAA,AAAI,GASzBub,IAAI,GAAK/Y,MAAM,CAACuY,QAAQ,IAAIQ,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC3G,OAAO,EAAE/H,OAAO,GAAK5D,OAAO,CAACwP,YAAY,CAAC7D,OAAO,CAAC,EAAE/H,OAAO,CAAC,CAAC;AAG/F,MAAMuW,YAAY,GAAA,WAAA,2JAoBrBpjB,OAAAA,AAAI,EAAC,CAAC,EAAE,CAAC4U,OAAO,EAAE/H,OAAO,KAAI;IAC/B,MAAMoF,IAAI,GAAGC,MAAM,CAACD,IAAI,CAAC2C,OAAO,CAAC;IACjC,MAAMgD,MAAM,GAAG3F,IAAI,CAAC3K,GAAG,EAAE2P,GAAG,GAAKrC,OAAO,CAACqC,GAAG,CAAC,CAAC/W,IAAI,CAACoH,GAAG,EAAEkD,KAAK,GAAA,CAAM;gBAAEhD,IAAI,EAAEyP,GAAG;gBAAEzM;YAAK,CAAE,CAAC,CAAC,CAAC,CAAQ;IAClG,OAAO2Y,QAAQ,CAACvL,MAAM,EAAE/K,OAAO,CAAC;AAClC,CAAC,CAAC;AAGK,MAAMwW,WAAW,GAAA,WAAA,2JAAGrjB,OAAAA,AAAI,EAS7B,CAAC,EACD,CACEuD,IAA4B,EAC5BqQ,IAA+B,GAE/BoP,SAAS,CAACzf,IAAI,EAAEqQ,IAAI,EAAE;QAAEqP,MAAM,oJAAEvjB,MAAM,CAAC8J,AAAI;QAAE0Z,OAAO,EAAExjB,MAAM,CAAC4J,mJAAAA;IAAK,CAAE,CAAC,CACxE;AAGM,MAAMga,SAAS,GAAA,WAAA,2JAAGtjB,OAAAA,AAAI,EAS3B,CAAC,EACD,CACEwJ,IAA+B,EAC/BF,KAAgC,2JACQpJ,OAAAA,AAAI,EAACsJ,IAAI,EAAEuZ,KAAK,CAACpK,KAAK,CAACrP,KAAK,CAAC,CAAC,CAAC,CAC1E;AAGM,MAAMia,UAAU,GAAA,WAAA,2JAAGvjB,OAAAA,AAAI,EAS5B,CAAC,EACD,CACEwJ,IAA+B,EAC/BF,KAAgC,GACQpJ,+JAAAA,AAAI,EAACyY,KAAK,CAACnP,IAAI,CAAC,EAAEuZ,KAAK,CAACzZ,KAAK,CAAC,CAAC,CAC1E;AAGM,MAAM0Z,SAAS,GAAA,WAAA,0JAAGhjB,QAAI,AAAJA,EAmBvB,CAAC,EACD,CACEuD,IAA4B,EAC5BigB,KAAgC,EAChC3W,OAIC,KACyC;IAC1C,MAAM/B,QAAQ,GAAG+B,OAAO,CAAChL,YAAY,OAAGA,YAAY,CAAC4hB,6KAAAA,AAAS,EAAC5W,OAAO,CAAChL,YAAY,CAAC,iKAAGd,OAAiB,KAAL,CAAC2iB;IACpG,MAAMC,OAAO,IACV3S,SAAkB,IAClBlF,IAAgC,GAC/BkF,SAAS,IAAI,qJAACpR,IAAI,CAAC0N,OAAAA,AAAS,EAACxB,IAAI,CAAC,GAChC,eAAA;gBACAzL,aAAa,CAACujB,kJAAAA,AAAI,wJAACnkB,MAAM,CAACsK,GAAAA,AAAO,EAAC,IAAM+B,IAAI,CAAC,CAAC,gKAC9CzL,QAAcwjB,AAAK,GAAE/X,EAAR,CAAC+X,CAAW,yJAAKpkB,MAAM,CAACsK,GAAAA,AAAO,EAAC,IAAM+B,IAAI,CAAC,CAAC;IAE/D,OAAO,IAAI/I,UAAU,oKACnB5B,OAAO,CAAC6hB,IAAAA,AAAS,EAACxe,SAAS,CAAC8C,GAAG,CAAC/D,IAAI,EAAEsJ,OAAO,CAACoW,MAAM,CAAC,CAAC,EAAE;QACtDO,KAAK,EAAEhf,SAAS,CAAC8C,GAAG,CAACkc,KAAK,EAAE3W,OAAO,CAACqW,OAAO,CAAC,CAAC;QAC7CtZ,UAAU,EAAE+Z,OAAO,CAAC7Y,QAAQ,CAACtD,IAAI,KAAK,QAAQ,IAAIsD,QAAQ,CAACtD,IAAI,KAAK,MAAM,CAAC;QAC3EwC,WAAW,EAAE2Z,OAAO,CAAC7Y,QAAQ,CAACtD,IAAI,KAAK,QAAQ,IAAIsD,QAAQ,CAACtD,IAAI,KAAK,OAAO;KAC7E,CAAC,CACH;AACH,CAAC,CACF;AAGM,MAAMsc,QAAQ,IAAUvgB,IAAiC,GAC9DqF,GAAG,CAACrF,IAAI,8JAAE7B,KAAK,CAACoiB,KAAQ,CAAC;AAGpB,MAAMC,KAAK,GAAA,WAAA,GAAyBhe,UAAU,mJAACtG,MAAM,CAACskB,CAAK,CAAC;AAG5D,MAAMpT,KAAK,GAAA,WAAA,2JAQd3Q,OAAAA,AAAI,EACN,CAAC,EACD,CACEuD,IAA4B,EAC5BgQ,MAAgC,GACKmB,MAAM,CAACnR,IAAI,EAAEoV,KAAK,CAAC5S,UAAU,CAACwN,MAAM,CAAC,CAAC,CAAC,CAC/E;AAGM,MAAM5F,OAAO,GAAA,WAAA,2JAAG3N,OAAAA,AAAI,EASzB,CAAC,EACD,CACEuD,IAA4B,EAC5BygB,OAA+D,2JAE/D9jB,OAAAA,AAAI,EAACqD,IAAI,EAAEiO,aAAa,EAAE7K,KAAK,GAAKZ,UAAU,yJAAC7F,OAAI,AAAJA,EAAK8jB,OAAO,CAACrd,KAAK,CAAC,wJAAElH,MAAM,CAAC0H,IAAAA,AAAQ,wJAAC1H,MAAM,CAACqI,KAAS,AAATA,EAAUnB,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CACnH;AAGM,MAAMtC,MAAM,GAAA,WAAA,2JAAGrE,OAAAA,AAAI,EASxB,CAAC,EACD,CACEuD,IAA4B,EAC5BygB,OAA0C,GAE1C,IAAIjhB,UAAU,CACZ7C,+JAAAA,AAAI,EAACsE,SAAS,CAACjB,IAAI,CAAC,4KAAEjC,IAAI,CAAC6Y,UAAAA,AAAY,GAAErO,IAAI,uJAAKlM,IAAI,CAAC0N,OAAS,AAATA,EAAUxB,IAAI,CAAC,GAAGkY,OAAO,EAAE,GAAGvkB,MAAM,CAAC6E,kJAAI,CAAC,CAAC,CACnG,CACJ;AAGM,MAAM2f,OAAO,GAAA,WAAA,2JAQhBjkB,OAAAA,AAAI,EACN,CAAC,EACD,CACEuD,IAA4B,EAC5BgQ,MAAgC,GACKrL,MAAM,uJAACzI,KAAO8K,AAAE,CAAH,CAAIgJ,AAAHhJ,MAAS,EAAEhH,IAAI,CAAC,CAAC,CACvE;AAGM,MAAM2gB,KAAK,IAAa3gB,IAA4B,2JACzDrD,OAAAA,AAAI,EAACqD,IAAI,EAAE4gB,SAAS,qJAAClkB,WAAQ,CAAC,CAAC;AAG1B,MAAMkkB,SAAS,GAAA,WAAA,2JAAGnkB,OAAAA,AAAI,EAI3B,CAAC,EACD,CAAUuD,IAA4B,EAAEwK,CAAoB,GAC1D,IAAIhL,UAAU,yJAAC7C,OAAAA,AAAI,EAACsE,SAAS,CAACjB,IAAI,CAAC,qKAAEpC,OAAO,CAACgjB,IAAAA,AAAS,EAACpW,CAAC,CAAC,CAAC,CAAC,CAC9D;AAGM,MAAMqW,MAAM,GAAA,WAAA,2JAAGpkB,OAAAA,AAAI,EASxB,CAAC,EACD,CACEuD,IAA4B,EAC5BqQ,IAAwC,GAExC,IAAI7Q,UAAU,yJAAqB7C,OAAAA,AAAI,EAACsE,SAAS,CAACjB,IAAI,CAAC,qKAAEpC,OAAO,CAACijB,CAAAA,AAAM,EAAC,IAAM5f,SAAS,CAACoP,IAAI,EAAE,CAAC,CAAC,CAAC,CAAC,CACrG;AAGM,MAAMyQ,YAAY,GAAA,WAAA,GAAGrkB,+JAAAA,AAAI,EAS9B,CAAC,EACD,CACEuD,IAA4B,EAC5BqQ,IAAwC,2JAExC1T,OAAAA,AAAI,EAACqD,IAAI,EAAE+D,GAAG,mJAAC5H,MAAM,CAAC8J,AAAI,CAAC,EAAE4a,MAAM,CAAC,4JAAMlkB,OAAAA,AAAI,EAAC0T,IAAI,EAAE,EAAEtM,GAAG,mJAAC5H,MAAM,CAAC4J,CAAK,CAAC,CAAC,CAAC,CAAC,CAC9E;AAGM,MAAMgb,UAAU,GAAA,WAAA,0JAAGtkB,QAAAA,AAAI,EAI5B,CAAC,EACD,CAAcuD,IAA4B,EAAE8I,KAAkB,2JAC5DnM,OAAAA,AAAI,EAACqD,IAAI,EAAE6gB,MAAM,CAAC,IAAMzJ,QAAQ,CAACtO,KAAK,CAAC,CAAC,CAAC,CAC5C;AAGM,MAAMkY,aAAa,GAAA,WAAA,2JAAGvkB,OAAI,AAAJA,EAI3B,CAAC,EACD,CAAcuD,IAA4B,EAAEme,OAAoB,OAC9DxhB,2JAAAA,AAAI,EAACqD,IAAI,EAAEihB,kBAAkB,CAAC,yJAAMplB,KAAK,AAACiK,AAAE,CAAFA,CAAGqY,OAAO,EAAE,CAAC,CAAC,CAAC,CAC5D;AAGM,MAAM8C,kBAAkB,GAAA,WAAA,2JAAGxkB,OAAAA,AAAI,EAIpC,CAAC,EACD,CAAcuD,IAA4B,EAAE+I,KAA+B,2JACzEpM,OAAAA,AAAI,EAACqD,IAAI,EAAEkhB,mBAAmB,CAAC,IAAM,IAAI1hB,UAAU,2KAACzB,IAAI,CAAC4C,GAAAA,AAAK,EAACoI,KAAK,EAAE,CAAC,CAAC,CAAC,CAAC,CAC7E;AAGM,MAAMmY,mBAAmB,GAAA,WAAA,2JAAGzkB,OAAAA,AAAI,EASrC,CAAC,EACD,CACEuD,IAA4B,EAC5Bka,MAA0C,KACD;IACzC,MAAMhL,MAAM,6KAA0FnR,IAAI,CAACsC,MAAQ,AAARA,EACzG;QACEC,OAAO,GAAGC,KAAqB,IAAI;YACjC,IAAI1E,KAAK,CAACia,yJAAAA,AAAO,EAACvV,KAAK,CAAC,EAAE;gBACxB,iLAAOxC,IAAI,CAACyI,KAAAA,AAAO,EAAC,IAAM0I,MAAM,CAAC;YACnC;YACA,+JAAOvS,OAAAA,AAAI,2KACToB,IAAI,CAAC4C,IAAAA,AAAK,EAACJ,KAAK,CAAC,qKACjB3C,OAAO,CAACgG,GAAAA,AAAQ,qKAAChG,OAAO,CAACuN,UAAAA,AAAe,EAA8B,CAAC,CACxE;QACH,CAAC;QACDvK,SAAS,wKAAE7C,IAAI,CAAC8C,EAAI;QACpBC,MAAM,EAAEA,CAAA,6KAAM/C,IAAI,CAACyI,KAAAA,AAAO,EAAC,IAAMvF,SAAS,CAACiZ,MAAM,EAAE,CAAC;KACrD,CACF;IACD,OAAO,IAAI1a,UAAU,wJAAC7C,QAAAA,AAAI,EAACsE,SAAS,CAACjB,IAAI,CAAC,4KAAEjC,IAAI,CAACiD,IAAM,AAANA,EAAOkO,MAAM,CAAC,CAAC,CAAC;AACnE,CAAC,CACF;AAGM,MAAMiS,aAAa,GAAA,WAAA,0JAAG1kB,QAAI,AAAJA,EAI3B,CAAC,EACD,CAAcuD,IAA4B,EAAEiH,KAAkB,2JAC5DtK,OAAAA,AAAI,EAACqD,IAAI,EAAE6gB,MAAM,CAAC,IAAM7Y,IAAI,CAACf,KAAK,CAAC,CAAC,CAAC,CACxC;AAGM,MAAMma,QAAQ,GAAGA,CAAOhhB,CAAI,EAAEoK,CAA2C,GAC9E6W,aAAa,CAACjhB,CAAC,GAAGA,CAAC,IAAI;QACrB,MAAMkhB,IAAI,GAAG9W,CAAC,CAACpK,CAAC,CAAC;QACjB,OAAO;iKAACvE,KAAMiK,AAAD,AAAG,CAAFA,CAAGwb,IAAI,CAAC,CAAC,CAAC,CAAC;YAAEA,IAAI,CAAC,CAAC,CAAC;SAAU;IAC9C,CAAC,CAAC;AAGG,MAAMD,aAAa,GAAGA,CAC3BjhB,CAAI,EACJoK,CAAwD,KACpC;IACpB,MAAM7B,IAAI,IAAIvI,CAAI,IAAgF;QAChG,MAAMkhB,IAAI,GAAG9W,CAAC,CAACpK,CAAC,CAAC;QACjB,QAAOrD,MAAM,CAAC+E,sJAAAA,AAAK,EAACwf,IAAI,CAAC,CAAC,CAAC,EAAE;YAC3Bzb,MAAM,EAAEA,CAAA,qKAAMjI,OAAO,CAACgG,IAAQ,AAARA,4KAAS7F,IAAI,CAAC4C,GAAAA,AAAK,EAAC2gB,IAAI,CAAC,CAAC,CAAC,CAAC,wKAAEvjB,IAAI,CAACgD,EAAI,CAAC;YAC9DiF,MAAM,GAAG5F,CAAC,GAAKrC,IAAI,CAAC2C,+KAAAA,AAAO,4KAAC3C,IAAI,CAAC4C,GAAAA,AAAK,EAAC2gB,IAAI,CAAC,CAAC,CAAC,CAAC,EAAE,IAAM3Y,IAAI,CAACvI,CAAC,CAAC;SAC/D,CAAC;IACJ,CAAC;IACD,OAAO,IAAIZ,UAAU,2KAACzB,IAAI,CAACyI,KAAAA,AAAO,EAAC,IAAMmC,IAAI,CAACvI,CAAC,CAAC,CAAC,CAAC;AACpD,CAAC;AAGM,MAAMmhB,mBAAmB,GAAGA,CACjCnhB,CAAI,EACJoK,CAA6E,KACnD;IAC1B,MAAM7B,IAAI,IAAIvI,CAAI,sKAChBxC,OAAO,CAAC+G,CAAAA,AAAM,wJACZzI,MAAM,AAAC6H,AAAG,CAAHA,CAAIyG,CAAC,CAACpK,CAAC,CAAC,EAAE,CAAC,CAAC2I,KAAK,EAAEwG,MAAM,CAAC,IAC/BxS,MAAM,CAAC+E,sJAAAA,AAAK,EAACyN,MAAM,EAAE;gBACnB1J,MAAM,EAAEA,CAAA,sKAAMjI,OAAO,CAACgG,GAAAA,AAAQ,4KAAC7F,IAAI,CAAC4C,GAAAA,AAAK,EAACoI,KAAK,CAAC,wKAAEhL,IAAI,CAACgD,EAAI,CAAC;gBAC5DiF,MAAM,EAAG5F,CAAC,8KAAKrC,IAAI,CAAC2C,KAAAA,AAAO,4KAAC3C,IAAI,CAAC4C,GAAAA,AAAK,EAACoI,KAAK,CAAC,EAAE,IAAMJ,IAAI,CAACvI,CAAC,CAAC;aAC7D,CAAC,CAAC,CACN;IACH,OAAO,IAAIZ,UAAU,KAACzB,IAAI,CAACyI,2KAAAA,AAAO,EAAC,IAAMmC,IAAI,CAACvI,CAAC,CAAC,CAAC,CAAC;AACpD,CAAC;AAGM,MAAM8b,cAAc,GAAGA,CAC5B9b,CAAI,EACJoK,CAAgE,GAEhE+W,mBAAmB,CAACnhB,CAAC,GAAGA,CAAC,2JAAKzD,OAAAA,AAAI,EAAC6N,CAAC,CAACpK,CAAC,CAAC,uJAAElE,MAAM,CAAC6H,AAAG,EAAC,CAAC,CAACyN,CAAC,EAAEpR,CAAC,CAAC,GAAK;qKAACvE,KAAK,AAACiK,AAAE,CAAFA,CAAG0L,CAAC,CAAC;gBAAEpR,CAAC;aAAU,CAAC,CAAC,CAAC;AAGvF,MAAMohB,IAAI,GAAA,WAAA,GAAG/kB,+JAAAA,AAAI,EAUtB,CAAC,EAAE,CACHuD,IAA4B,EAC5BwB,IAAiC,KACyC;IAE1E,MAAM0C,OAAO,GAAG,MAAe;IAE/B,MAAMI,OAAO,GAAG,MAAe;IAE/B,MAAME,MAAM,GAAG,KAAc;IAa7B,+JAAO7H,OAAAA,AAAI,yJACTX,QAAa,AAAJqG,AAAD,CAACA,CAAkB,IAC3BnG,MAAM,CAACwE,wJAAAA,AAAO,EAAEiN,QAAQ,QACtBhR,2JAAAA,AAAI,+KACF4B,OAAO,AAAC8D,AAAI,CAAJA,CAAc,yJACtBnG,MAAM,AAAC6H,AAAG,CAAHA,EAAKtB,OAAO,IAAI;YACrB,MAAMoL,QAAQ,GAAG1P,KAAK,CAACsjB,qKAAAA,AAAQ,kKAACtjB,KAAK,CAACujB,YAAAA,AAAe,EAAClgB,IAAI,CAAC,EAAE;gBAC3DZ,SAAS,GAAGkI,KAAK,mKACf3K,KAAK,CAACyF,KAAAA,AAAQ,iKACZzF,KAAK,CAACqE,QAAU,AAAVA,0JAAWxG,OAAS6E,AAAI,CAAL,CAACA,AAAK8M,QAAQ,EAAE7E,KAAK,CAAC,CAAC,kKAChD3K,KAAK,CAAC0C,CAAI,AAAJA,EAAKiI,KAAK,CAAC,CAClB;gBACHhC,SAAS,EAAEA,CAAC,CAAC6a,CAAC,EAAEje,SAAS,CAAC,KAAI;oBAC5B,MAAMiF,IAAI,GAA8E5K,IAAI,CACzFiF,qLAAAA,AAAa,EAAC;wBACb1C,OAAO,GAAG6D,QAAQ,6KAChBpG,IAAI,CAAC2C,KAAAA,AAAO,2KACV3C,IAAI,CAACyE,SAAAA,AAAU,+KACbjE,OAAO,CAAC0E,AAAK,EAASR,OAAO,EAAE;gCAAEwB,IAAI,EAAEC,OAAO;gCAAEC;4BAAQ,CAAE,CAAC,CAC5D,EACD,IAAMwE,IAAI,CACX;wBACH/H,SAAS,GAAGwC,KAAK,sKACfxF,OAAO,CAACgG,GAAAA,AAAQ,4KACd7F,IAAI,CAACyE,QAAAA,AAAU,+KAACjE,OAAO,CAAC0E,AAAK,EAASR,OAAO,EAAE;gCAAEwB,IAAI,EAAEK,OAAO;gCAAElB;4BAAK,CAAE,CAAC,CAAC,4KACzErF,IAAI,CAACwG,OAAAA,AAAS,EAACnB,KAAK,CAAC,CACtB;wBACHtC,MAAM,GAAGzB,CAAC,OACRzB,OAAO,CAACgG,kKAAAA,AAAQ,4KACd7F,IAAI,CAACyE,QAAAA,AAAU,+KAACjE,OAAO,CAAC0E,AAAK,EAASR,OAAO,EAAE;gCAAEwB,IAAI,EAAEO;4BAAM,CAAE,CAAC,CAAC,uKACjEzG,IAAI,CAACgD,GAAI;qBAEd,CAAC;oBACJ,uKAAO5C,KAAK,CAAC6K,QAAAA,AAAW,0JACtBrM,OAAAA,AAAI,EACFoB,IAAI,CAACyE,kLAAAA,AAAU,0JAACxG,QAAQ,CAAC6H,CAAO,AAAPA,EAAQ8J,QAAQ,EAAEgU,CAAC,CAAC,CAAC,qKAC9C/jB,OAAO,CAACgG,GAAAA,AAAQ,4KAAC7F,IAAI,CAACyE,QAAAA,AAAU,0JAC9B7F,OAAAA,AAAI,EACF8F,OAAO,+KACPlE,OAAO,CAAC0E,AAAK,EAAS;wBAAEgB,IAAI,EAAEC,OAAO;wBAAEC,QAAQ,EAAET;oBAAS,CAAE,CAAC,CAC9D,CACF,CAAC,EACF9F,OAAO,CAACgG,sKAAAA,AAAQ,EAAC+E,IAAI,CAAC,CACvB,CACF;gBACH;aACD,CAAC;YAEF,MAAM6E,QAAQ,2JAAwE7Q,OAAI,AAAJA,MACpF4B,OAAO,CAACuF,wKAAAA,AAAI,EAACrB,OAAO,CAAC,wJACrBvG,MAAM,AAAC6H,AAAG,CAAHA,CAAKC,MAAM,IAAI;gBACpB,OAAQA,MAAM,CAACC,IAAI;oBACjB,KAAKC,OAAO;wBAAE;4BACZ,+JAAOvH,OAAAA,AAAI,4KAACoB,IAAI,CAAC4C,GAAAA,AAAK,EAACqD,MAAM,CAACG,QAAQ,CAAC,4KAAEpG,IAAI,CAAC2C,KAAAA,AAAO,EAAC,IAAM8M,QAAQ,CAAC,CAAC;wBACxE;oBACA,KAAKlJ,OAAO;wBAAE;4BACZ,iLAAOvG,IAAI,CAACwG,OAAAA,AAAS,EAACP,MAAM,CAACZ,KAAK,CAAC;wBACrC;oBACA,KAAKoB,MAAM;wBAAE;4BACX,6KAAOzG,IAAI,CAACgD,EAAI;wBAClB;gBACF;YACF,CAAC,CAAC,iKACFnD,OAAO,CAAC+G,CAAM,CACf;YAED,+JAAOhI,OAAAA,AAAI,EACTqD,IAAI,EACJ4hB,aAAa,EAAExe,KAAK,2JAAKpH,QAAQ,CAACuI,GAAAA,AAAS,EAACoJ,QAAQ,EAAEvK,KAAK,CAAC,CAAC,EAC7DiC,GAAG,CAACwI,QAAQ,CAAC,oJACb3R,MAAM,CAACmQ,MAAU,wJACjBnQ,MAAM,CAAC0H,IAAAA,AAAQ,EAAC5H,QAAQ,CAAC0R,uJAAAA,AAAK,EAACC,QAAQ,CAAC,CAAC,wJACzCzR,MAAM,AAAC6H,AAAG,CAAHA,EAAK4d,CAAC,GAAK;oBAACA,CAAC;oBAAE,IAAIniB,UAAU,CAACgO,QAAQ,CAAC;iBAA2B,CAAC,CAC3E;QACH,CAAC,CAAC,CACH,CACF,oJACDtR,MAAM,CAACwJ,GAAO,CACf;AACH,CAAC,CAAC;AAGK,MAAMmc,SAAS,GAAA,WAAA,2JAuClBplB,OAAAA,AAAI,GACLub,IAAI,GAAK,OAAOA,IAAI,CAAC,CAAC,CAAC,KAAK,UAAU,EACvC,CACEhY,IAA4B,EAC5BqW,SAAuB,EACvB/M,OAEC,GAMDwY,eAAe,CACb9hB,IAAI,GACHwR,CAAC,yJAAKtV,MAAM,CAAC2H,GAAAA,AAAO,EAACwS,SAAS,CAAC7E,CAAC,CAAC,GAAGrV,MAAM,CAAC4J,uJAAK,AAALA,EAAMyL,CAAC,CAAC,yJAAGrV,MAAM,CAAC8J,AAAI,EAACuL,CAAC,CAAC,CAAC,EACtElI,OAAO,CACR,CACJ;AAGM,MAAMwY,eAAe,GAAA,WAAA,OAAGrlB,2JAAAA,AAAI,GAyBhCub,IAAI,GAAK,OAAOA,IAAI,CAAC,CAAC,CAAC,KAAK,UAAU,EACvC,CACEhY,IAA4B,EAC5BqW,SAAiE,EACjE/M,OAEC,2JAMD3M,OAAAA,AAAI,EACFqa,mBAAmB,CAAChX,IAAI,EAAEqW,SAAS,CAAC,EACpCjD,eAAe,CAAC;QACdI,IAAI,EAAE,CAAC;QACPnI,UAAU,EAAE/B,OAAO,EAAEnC,UAAU,IAAI,EAAE;QACrCmM,MAAM,wJAAEnX,MAAM,CAAC2F,CAAAA,AAAK,EAAC;YACnBC,MAAM,EAAEA,CAAA,GAAM7F,MAAM,CAAC2H,yJAAAA,AAAO,GAAE0G,CAAC,GAAKA,CAAC,KAAK,CAAC,CAAC;YAC5CtI,OAAO,EAAEA,CAAA,yJAAM/F,MAAM,CAAC2H,GAAAA,AAAO,GAAE0G,CAAC,GAAKA,CAAC,KAAK,CAAC;SAC7C;KACF,CAAC,wJACFrO,MAAM,CAACwE,GAAO,AAAPA,EAAQ,CAAC,CAACqhB,MAAM,EAAEC,MAAM,CAAC,OAC9B9lB,MAAM,CAAC2H,qJAAAA,AAAO,EAAC;YACbjC,SAAS,CACPoX,iBAAiB,CAACvN,SAAS,CAACsW,MAAM,EAAE;gBAAEla,QAAQ,EAAE;YAAI,CAAE,CAAC,CAAC,GACvDxI,CAAC,wJACAlD,MAAM,CAAC2F,EAAAA,AAAK,EAACzC,CAAC,EAAE;oBACd0C,MAAM,oJAAEhF,MAAM,CAACmF,AAAI;oBACnBD,OAAO,oJAAElF,MAAM,CAACiF;iBACjB,CAAC,CACL;YACDJ,SAAS,CACPoX,iBAAiB,CAACvN,SAAS,CAACuW,MAAM,EAAE;gBAAEna,QAAQ,EAAE;YAAI,CAAE,CAAC,CAAC,GACvDxI,CAAC,yJACAlD,MAAM,CAAC2F,CAAAA,AAAK,EAACzC,CAAC,EAAE;oBACd0C,MAAM,oJAAEhF,MAAM,CAACiF,AAAI;oBACnBC,OAAO,oJAAElF,MAAM,CAACmF;iBACjB,CAAC,CACL;SACF,CAAC,CACH,CACF,CACJ;AAGM,MAAM+f,WAAW,GAAA,WAAA,GAAGxlB,+JAAAA,AAAI,EAS7B,CAAC,EACD,CACEuD,IAA4B,EAC5BwB,IAAiC,GAEjC,IAAIhC,UAAU,yJAAC7C,OAAI,AAAJA,EAAKsE,SAAS,CAACjB,IAAI,CAAC,qKAAEpC,OAAO,CAACuH,OAAAA,AAAY,iKAAChH,KAAK,CAAC8C,OAAAA,AAAS,EAACO,IAAI,CAAC,CAAC,CAAC,CAAC,CACrF;AAGM,MAAM0gB,kBAAkB,GAAA,WAAA,2JAAGzlB,OAAAA,AAAI,EASpC,CAAC,EACD,CACEuD,IAA4B,EAC5BpC,OAAsF,GACpD,IAAI4B,UAAU,CAACzB,IAAI,CAACiD,8KAAAA,AAAM,EAACC,SAAS,CAACjB,IAAI,CAAC,EAAEpC,OAAO,CAAC,CAAC,CAC1F;AAGM,MAAMukB,wBAAwB,GAAA,WAAA,2JAAG1lB,OAAAA,AAAI,EAS1C,CAAC,EACD,CACEuD,IAA4B,EAC5BoiB,IAAmF,GAC7C,IAAI5iB,UAAU,KAAC7C,2JAAAA,AAAI,EAACsE,SAAS,CAACjB,IAAI,CAAC,qKAAEpC,OAAO,CAACuH,OAAAA,AAAY,EAACid,IAAI,CAAC,CAAC,CAAC,CAC1G;AAGM,MAAMnO,OAAO,GAAA,WAAA,0JAAGxX,QAAAA,AAAI,EAGzB,CAAC,EAAE,CAACuD,IAAI,EAAEqU,MAAM,GAChB,IAAI7U,UAAU,oKACZ5B,OAAO,CAACgG,GAAAA,AAAQ,4KACd7F,IAAI,CAAC4C,GAAAA,AAAK,EAAC0T,MAA0B,CAAC,EACtCpT,SAAS,CAACjB,IAAI,CAAC,CAChB,CACF,CAAC;AAGG,MAAMqiB,cAAc,GAAA,WAAA,2JAAG5lB,OAAAA,AAAI,EAIhC,CAAC,EACD,CAAUuD,IAA4B,EAAE6W,OAA2B,GACjE,IAAIrX,UAAU,wJAAC7C,QAAAA,AAAI,EAACsE,SAAS,CAACjB,IAAI,CAAC,4KAAEjC,IAAI,CAACskB,YAAAA,AAAc,EAACxL,OAAO,CAAC,CAAC,CAAC,CACtE;AAGM,MAAMyL,kBAAkB,GAAA,WAAA,OAAG7lB,2JAAAA,AAAI,EAIpC,CAAC,EACD,CAAcuD,IAA4B,EAAE6W,OAA4B,GACtE0L,eAAe,CAACviB,IAAW,yJAAEjE,OAAO,CAACyjB,AAAK,EAAC3I,OAAO,CAAC,CAAC,CACvD;AAGM,MAAM2L,YAAY,GAAA,WAAA,2JAAG/lB,OAAAA,AAAI,EAS9B,CAAC,EACD,CACEuD,IAA+B,EAC/BmC,KAAiC,GAEjC,IAAI3C,UAAU,oKACZ5B,OAAO,CAACmJ,WAAAA,AAAgB,GAAE9B,KAAK,IAC7BpI,KAAK,CAAC4lB,+JAAAA,AAAc,EAACtgB,KAAK,EAAE8C,KAAK,CAAC,CAACtI,IAAI,uJACrCT,MAAU,AAAH6H,AAAD,CAACA,CAAK2e,GAAG,KAAK/lB,8JAAAA,AAAI,EAACsE,SAAS,CAACjB,IAAI,CAAC,4KAAEjC,IAAI,CAACskB,YAAAA,AAAc,EAACK,GAAG,CAAC,CAAC,CAAC,CACrE,CACF,CACF,CACJ;AAGM,MAAMC,cAAc,GAAA,WAAA,GAAGlmB,+JAAAA,AAAI,EAWhC,CAAC,EACD,CACEuD,IAA4B,EAC5B4iB,GAAsB,EACtBC,QAA0B,GACvBC,oBAAoB,CAAC9iB,IAAI,EAAE4iB,GAAG,EAAE1mB,MAAM,CAAC2H,yJAAAA,AAAO,EAACgf,QAAQ,CAAC,CAAC,CAC/D;AAGM,MAAMC,oBAAoB,GAAA,WAAA,2JAAGrmB,OAAAA,AAAI,EAWtC,CAAC,EACD,CACEuD,IAA4B,EAC5B4iB,GAAsB,EACtB5S,MAA+C,GAC5C+S,oBAAoB,CAAC/iB,IAAI,EAAE4iB,GAAG,EAAEpgB,UAAU,CAACwN,MAAM,CAAC,CAAC,CACzD;AAGM,MAAM+S,oBAAoB,GAAA,WAAA,OAAGtmB,2JAAAA,AAAI,EAWtC,CAAC,EACD,CACEuD,IAA4B,EAC5B4iB,GAAsB,EACtB1I,MAA+C,GAE/CjD,iBAAiB,EAAEyL,GAAwC,GACzDhiB,OAAO,CACLwZ,MAAM,GACL8I,OAAO,2JAAKrmB,OAAAA,AAAI,EAACqD,IAAI,EAAEqiB,cAAc,wJAACtmB,MAAQknB,AAAG,CAAJ,CAAKP,AAAJO,GAAO,EAAEL,GAAG,EAAEI,OAAO,CAA4B,CAAC,CAAC,CACnG,CACF,CACJ;AAGM,MAAMT,eAAe,GAAA,WAAA,2JAAG9lB,OAAI,AAAJA,EAS7B,CAAC,EACD,CACEuD,IAA4B,EAC5BwK,CAAmD,GACvByM,iBAAiB,EAAEyL,GAAG,2JAAK/lB,OAAAA,AAAI,EAACqD,IAAI,EAAEqiB,cAAc,CAAC7X,CAAC,CAACkY,GAAG,CAAC,CAAC,CAAC,CAAC,CAC7F;AAGM,MAAMQ,gBAAgB,GAAA,WAAA,2JAAGzmB,OAAAA,AAAI,EASlC,CAAC,EACD,CACEuD,IAA4B,EAC5BmC,KAAiC,GAEjC,mBAAA;IACA,yDAAA;4JACAxF,OAAAA,AAAI,EACFqD,IAAI,EACJwiB,YAAY,yJAAC7lB,OAAAA,AAAI,GAACE,KAAK,CAACga,wJAAAA,AAAO,EAAE,wJAAEha,KAAK,CAAC2iB,EAAAA,AAAK,EAACrd,KAAK,CAAC,CAAC,CAAC,CACxD,CACJ;AAGM,MAAMoR,KAAK,GAAGA,CAAC4P,GAAW,EAAEvN,GAAW,EAAEwH,SAAS,GAAGtd,gBAAgB,GAC1E0G,OAAO,CAAC,MAAK;QACX,IAAI2c,GAAG,GAAGvN,GAAG,EAAE;YACb,OAAO1U,KAA8B;QACvC;QACA,MAAMkiB,EAAE,GAAGA,CACTD,GAAW,EACXvN,GAAW,EACXwH,SAAiB,KACkE;YACnF,MAAMiG,SAAS,GAAGzN,GAAG,GAAGuN,GAAG,GAAG,CAAC;YAC/B,IAAIE,SAAS,GAAGjG,SAAS,EAAE;gBACzB,+JAAOzgB,OAAAA,AAAI,GACToB,IAAI,CAAC4C,4KAAK,AAALA,uJAAM9E,KAAK,CAAC0X,EAAAA,AAAK,EAAC4P,GAAG,EAAEA,GAAG,GAAG/F,SAAS,GAAG,CAAC,CAAC,CAAC,4KACjDrf,IAAI,CAAC2C,KAAAA,AAAO,EAAC,IAAM0iB,EAAE,CAACD,GAAG,GAAG/F,SAAS,EAAExH,GAAG,EAAEwH,SAAS,CAAC,CAAC,CACxD;YACH;YACA,iLAAOrf,IAAI,CAAC4C,GAAAA,AAAK,uJAAC9E,KAAK,CAAC0X,EAAAA,AAAK,EAAC4P,GAAG,EAAEA,GAAG,GAAGE,SAAS,GAAG,CAAC,CAAC,CAAC;QAC1D,CAAC;QACD,OAAO,IAAI7jB,UAAU,CAAC4jB,EAAE,CAACD,GAAG,EAAEvN,GAAG,EAAEwH,SAAS,CAAC,CAAC;IAChD,CAAC,CAAC;AAGG,MAAMkG,IAAI,GAAA,WAAA,2JAQb7mB,OAAAA,AAAI,EACN,CAAC,EACD,CACEwJ,IAA+B,EAC/BF,KAAgC,GACawd,OAAO,CAACtd,IAAI,EAAEF,KAAK,CAAC,CACpE;AAGM,MAAMwd,OAAO,GAAGA,CACrB,GAAGlS,OAAU,2JAMbrV,OAASqG,AAAI,CAAL,CAACA,AAAY,EAAC1F,IAAI,uJACxBT,MAAM,AAAC6H,AAAG,CAAHA,EAAKV,IAAI,IAAI;QAClB,IAAImgB,MAAM,GAAkB,IAAI;QAChC,OAAO5D,QAAQ,CACbvO,OAAO,CAACtN,GAAG,CAAC,CAACmW,MAAM,EAAEuJ,KAAK,GACxBvJ,MAAM,CAACvd,IAAI,CACT+mB,SAAS,CAAC,MAAK;gBACb,IAAIF,MAAM,KAAK,IAAI,EAAE;oBACnBA,MAAM,GAAGC,KAAK;4KACdznB,QAAQ,CAAC2nB,IAAAA,AAAU,EAACtgB,IAAI,kJAAEhH,IAAI,CAAC0E,EAAI,CAAC;oBACpC,OAAO,IAAI;gBACb;gBACA,OAAOyiB,MAAM,KAAKC,KAAK;YACzB,CAAC,CAAC,EACFhF,aAAa,CACXziB,QAAQ,CAAC0R,uJAAAA,AAAK,EAACrK,IAAI,CAAC,CAAC1G,IAAI,uJACvBT,MAAM,CAACwE,GAAAA,AAAO,EAAC,IAAM8iB,MAAM,KAAKC,KAAK,GAAGvnB,MAAM,CAACskB,mJAAK,qJAAGtkB,MAAM,CAAC6E,AAAI,CAAC,CACpE,CACF,CACF,CACF,EACD;YAAEoX,WAAW,EAAE9G,OAAO,CAACzG,MAAAA;QAAM,CAAE,CAChC;IACH,CAAC,CAAC,EACFjG,MAAM,CACP;AAGI,MAAM2I,OAAO,GAAA,WAAA,2JAAG7Q,OAAI,AAAJA,EAGrB,CAAC,EAAE,CAAUuD,IAA4B,EAAEuK,CAAS,GACpD/D,OAAO,CAAC,MAAK;QACX,MAAMod,MAAM,GAAGjO,IAAI,CAACC,GAAG,CAACrL,CAAC,EAAE,CAAC,CAAC;QAC7B,MAAMuC,OAAO,GAAG+W,cAAc,CAAC,IAAIC,eAAe,CAACF,MAAM,CAAC,EAAEA,MAAM,CAAC;QACnE,OAAO,IAAIpkB,UAAU,yJAAC7C,OAAAA,AAAI,EAACsE,SAAS,CAACjB,IAAI,CAAC,4KAAEjC,IAAI,CAACiD,IAAAA,AAAM,EAAC8L,OAAO,CAAC,CAAC,CAAC;IACpE,CAAC,CAAC,CAAC;AAEL,cAAA,GACA,MAAM+W,cAAc,GAAGA,CACrBE,SAAgC,EAChCH,MAAc,OAEd7lB,IAAI,CAACiF,iLAAAA,AAAa,EAAC;QACjB1C,OAAO,GAAGyI,KAAqB,IAAI;YACjC,IAAIA,KAAK,CAAC6B,MAAM,KAAKgZ,MAAM,IAAIG,SAAS,CAACjO,OAAO,EAAE,EAAE;gBAClD,iLAAO/X,IAAI,CAAC2C,KAAAA,AAAO,4KACjB3C,IAAI,CAAC4C,GAAAA,AAAK,EAACoI,KAAK,CAAC,EACjB,IAAM8a,cAAc,CAACE,SAAS,EAAEH,MAAM,CAAC,CACxC;YACH;YACA,IAAI7a,KAAK,CAAC6B,MAAM,GAAG,CAAC,EAAE;gBACpB,MAAM3K,MAAM,GAA0B,EAAE;gBACxC,IAAIga,MAAM,GAA+B5S,SAAS;gBAClD,IAAIoc,KAAK,GAAG,CAAC;gBACb,MAAOA,KAAK,GAAG1a,KAAK,CAAC6B,MAAM,CAAE;oBAC3B,MAAO6Y,KAAK,GAAG1a,KAAK,CAAC6B,MAAM,IAAIqP,MAAM,KAAK5S,SAAS,CAAE;wBACnD4S,MAAM,GAAG8J,SAAS,CAACpjB,KAAK,KAAChE,2JAAAA,AAAI,EAACoM,KAAK,uJAAElN,KAAK,CAAC8gB,MAAAA,AAAS,EAAC8G,KAAK,CAAC,CAAC,CAAC;wBAC7DA,KAAK,GAAGA,KAAK,GAAG,CAAC;oBACnB;oBACA,IAAIxJ,MAAM,KAAK5S,SAAS,EAAE;wBACxBpH,MAAM,CAACkb,IAAI,CAAClB,MAAM,CAAC;wBACnBA,MAAM,GAAG5S,SAAS;oBACpB;gBACF;gBACA,iLAAOtJ,IAAI,CAAC2C,KAAAA,AAAO,qKACjB9C,OAAO,CAAComB,GAAAA,AAAQ,CAAC,IAAG/jB,MAAM,CAAC,EAC3B,IAAM4jB,cAAc,CAACE,SAAS,EAAEH,MAAM,CAAC,CACxC;YACH;YACA,iLAAO7lB,IAAI,CAACyI,KAAAA,AAAO,EAAC,IAAMqd,cAAc,CAACE,SAAS,EAAEH,MAAM,CAAC,CAAC;QAC9D,CAAC;QACDhjB,SAAS,GAAGwC,KAAK,GAAKxF,OAAO,CAACgG,sKAAAA,AAAQ,EAACmgB,SAAS,CAACE,cAAc,EAAE,4KAAElmB,IAAI,CAACwG,OAAAA,AAAS,EAACnB,KAAK,CAAC,CAAC;QACzFtC,MAAM,EAAEA,CAAA,GAAMijB,SAAS,CAACE,cAAc;KACvC,CAAC;AAEJ,MAAMH,eAAe;IAIEvZ,CAAA,CAAA;IAHb0Q,OAAO,GAAa,EAAE,CAAA;IACtBiJ,GAAG,GAAG,CAAC,CAAA;IAEfzkB,YAAqB8K,CAAS,CAAA;QAAT,IAAA,CAAAA,CAAC,GAADA,CAAC;IACtB;IAEAuL,OAAOA,CAAA,EAAA;QACL,OAAO,IAAI,CAACoO,GAAG,KAAK,CAAC;IACvB;IAEAvjB,KAAKA,CAACwR,IAAO,EAAA;QACX,IAAI,CAAC8I,OAAO,CAACE,IAAI,CAAChJ,IAAI,CAAC;QACvB,IAAI,CAAC+R,GAAG,IAAI,CAAC;QAEb,IAAI,IAAI,CAACA,GAAG,KAAK,IAAI,CAAC3Z,CAAC,EAAE;YACvB,MAAM0P,MAAM,wJAAGpe,KAAK,CAACmO,YAAAA,AAAe,EAAC,IAAI,CAACiR,OAAO,CAAC;YAClD,IAAI,CAACA,OAAO,GAAG,EAAE;YACjB,IAAI,CAACiJ,GAAG,GAAG,CAAC;YACZ,OAAOjK,MAAM;QACf;QAEA,OAAO5S,SAAS;IAClB;IAEA4c,cAAcA,CAAA,EAAA;QACZ,IAAI,IAAI,CAACC,GAAG,KAAK,CAAC,EAAE;YAClB,WAAOnmB,IAAI,CAAC4C,yKAAAA,AAAK,uJAAC9E,KAAK,CAACmO,YAAAA,AAAe,EAAC,IAAI,CAACiR,OAAO,CAAC,CAAC;QACxD;QACA,4KAAOld,IAAI,CAACgD,GAAI;IAClB;;AAIK,MAAMojB,WAAW,GAAA,WAAA,2JAAG1nB,OAAI,AAAJA,EAIzB,CAAC,EACD,CAAcuD,IAA4B,EAAEmO,EAAmC,2JAC7ExR,OAAAA,AAAI,EAACqD,IAAI,EAAEokB,eAAe,CAACjW,EAAE,sJAAEzR,WAAQ,CAAC,CAAC,CAC5C;AAGM,MAAM0nB,eAAe,GAAA,WAAA,2JAAG3nB,OAAAA,AAAI,EAWjC,CAAC,EACD,CACEuD,IAA4B,EAC5BmO,EAAmC,EACnC3D,CAAwB,GAExB,IAAIhL,UAAU,oKACZ5B,OAAO,CAACoQ,GAAAA,AAAQ,EAAC/M,SAAS,CAACjB,IAAI,CAAC,GAAG8I,KAAK,yJACtC/L,MAAM,CAAC+E,CAAAA,AAAK,EAACqM,EAAE,CAACrF,KAAK,CAAC,EAAE;YACtBjD,MAAM,EAAEA,CAAA,4KAAM9H,IAAI,CAACwG,QAAAA,AAAS,uJAAC3I,KAAK,CAAI,AAAHkX,EAAItI,CAAC,CAAC1B,KAAK,CAAC,CAAC,CAAC;YACjD9C,MAAM,EAAEjI,IAAI,CAAC8C,wKAAAA;SACd,CAAC,CAAC,CACN,CACJ;AAGM,MAAMwjB,MAAM,GAAA,WAAA,2JAAG5nB,OAAAA,AAAI,EASxB,CAAC,EACD,CACEuD,IAA4B,EAC5B2B,QAA2C,GAE3CC,SAAS,CACP0iB,YAAY,CAACtkB,IAAI,EAAE2B,QAAQ,CAAC,GAC3BtC,CAAC,IACAlD,MAAM,CAAC2F,sJAAAA,AAAK,EAACzC,CAAC,EAAE;YACd0C,MAAM,oJAAEhF,MAAM,CAACiF,AAAI;YACnBC,OAAO,oJAAElF,MAAM,CAACmF;SACjB,CAAC,CACL,CACJ;AAGM,MAAMqiB,YAAY,IAAavU,MAA8B,GAClE6J,kBAAkB,KAACld,2JAAAA,AAAI,EAACqT,MAAM,EAAE9T,MAAM,CAACue,0JAAAA,AAAQ,oJAAC1d,MAAM,CAACmF,AAAI,CAAC,CAAC,CAAC;AAGzD,MAAMsiB,iBAAiB,IAAaxU,MAA2C,GACpF3F,uBAAuB,yJAAC1N,OAAI,AAAJA,EAAKqT,MAAM,wJAAE9T,MAAM,CAACue,IAAAA,AAAQ,oJAAC1d,MAAM,CAACmF,AAAI,CAAC,CAAC,CAAC;AAG9D,MAAMmI,uBAAuB,IAClC2F,MAA0D,GAE1DkB,iBAAiB,CAAClB,MAAM,GAAGA,MAAM,OAC/BrT,2JAAAA,AAAI,wJACFT,MAAM,AAAC6H,AAAG,CAAHA,CAAIiM,MAAM,GAAGjH,KAAK,yJAAKhM,MAAM,CAACmF,AAAI,EAAC;gBAAC6G,KAAK;gBAAEiH,MAAM;aAAU,CAAC,CAAC,MACpE9T,MAAM,CAAC8R,sJAAAA,AAAQ,wJAACjR,MAAM,CAAC+E,CAAAA,AAAK,EAAC;YAC3B+D,MAAM,EAAEA,CAAA,yJAAM3J,MAAM,CAAC2H,GAAO,AAAPA,wJAAQ9G,MAAM,CAACiF,AAAI,EAAE,CAAC;YAC3CgE,MAAM,oJAAE9J,MAAM,CAAC2E;SAChB,CAAC,CAAC,CACJ,CAAC;AAGC,MAAMgZ,kBAAkB,IAAa7J,MAA6C,GACvF3F,uBAAuB,CAAC1N,+JAAAA,AAAI,EAACqT,MAAM,GAAE9T,MAAM,CAAC6H,oJAAAA,AAAG,kJAAClI,KAAK,CAACiK,AAAE,CAAC,CAAC,CAAC;AAGtD,MAAMwe,YAAY,GAAA,WAAA,2JAAG7nB,OAAAA,AAAI,EAS9B,CAAC,EACD,CACEuD,IAA4B,EAC5B2B,QAA2C,GAE3C8iB,UAAU,CAACzkB,IAAI,EAAE2B,QAAQ,EAAE;QACzB+iB,SAAS,GAAGlT,CAAC,OAA0BrV,MAAM,CAAC4J,mJAAAA,AAAK,EAACyL,CAAC,CAAC;QACtDmT,UAAU,oJAAExoB,MAAM,CAAC8J;KACpB,CAAC,CACL;AAGM,MAAM2e,cAAc,GAAA,WAAA,2JAAGnoB,OAAAA,AAAI,EAShC,CAAC,EACD,CACEuD,IAA4B,EAC5B2B,QAA2C,GAE3CC,SAAS,CACPijB,kBAAkB,CAAC7kB,IAAI,EAAE2B,QAAQ,EAAE;QAAE+iB,SAAS,GAAGlT,CAAC,IAAKzU,MAAM,CAACmF,qJAAAA,AAAI,EAACsP,CAAC,CAAC;QAAEmT,UAAU,oJAAE5nB,MAAM,CAACiF;IAAI,CAAE,CAAC,EACjGtF,+JAAQ,CACT,CACJ;AAGM,MAAMmoB,kBAAkB,GAAA,WAAA,2JAAGpoB,OAAI,AAAJA,EAiBhC,CAAC,EACD,CACEuD,IAA4B,EAC5B2B,QAA2C,EAC3C2H,OAGC,KAC8B;IAC/B,MAAM/G,MAAM,2JAAG5F,OAAAA,AAAI,yJACjBY,QAAQ,CAACgF,CAAAA,AAAM,EAACZ,QAAQ,CAAC,wJACzBzF,MAAM,AAAC6H,AAAG,CAAHA,EAAKxB,MAAM,IAAI;QACpB,MAAMuiB,IAAI,IACRvkB,KAAqB,yJAErBxD,MAAM,CAAC+E,CAAAA,AAAK,uJAACjG,KAAK,CAACqa,CAAAA,AAAI,EAAC3V,KAAK,CAAC,EAAE;gBAC9BsF,MAAM,EAAEA,CAAA,GAAM8C,IAAI;gBAClB3C,MAAM,GAAGwL,CAAC,sKACR5T,OAAO,CAACgG,GAAAA,AAAQ,4KACd7F,IAAI,CAAC4C,GAAAA,AAAK,sJAAC9E,KAAK,CAACiK,AAAE,EAACwD,OAAO,CAACob,SAAS,CAAClT,CAAC,CAAC,CAAC,CAAC,EAC1CuT,IAAI,yJAACpoB,OAAAA,AAAI,EAAC4D,KAAK,uJAAE1E,KAAK,CAAC2Z,CAAAA,AAAI,EAAC,CAAC,CAAC,CAAC,EAAEhE,CAAC,CAAC;aAExC,CAAC;QACJ,MAAMuT,IAAI,GAAGA,CACXxkB,KAAqB,EACrBiR,CAAI,KACwE;YAC5E,MAAMwT,OAAO,2JAAGroB,OAAAA,AAAI,EAClB4F,MAAM,CAAC/B,IAAI,CAACgR,CAAC,CAAC,wJACdtV,KAAO8K,AAAE,CAAH,CAACA,wJAAGrK,OAAAA,AAAI,4KAACoB,IAAI,CAAC4C,GAAK,AAALA,EAAM9E,KAAK,CAACiK,oJAAAA,AAAE,EAACwD,OAAO,CAACob,SAAS,CAAClT,CAAC,CAAC,CAAC,CAAC,4KAAEzT,IAAI,CAAC2C,KAAAA,AAAO,EAAC,IAAMqkB,IAAI,CAACxkB,KAAK,EAAEiR,CAAC,CAAC,CAAC,CAAC,CAAC,CAChG;YACD,MAAMyT,KAAK,GAIPtoB,+JAAAA,AAAI,EACN4F,MAAM,CAAC4M,IAAI,oJACXjT,MAAM,CAACykB,CAAK,wJACZzkB,MAAM,CAACwE,GAAO,AAAPA,GAAS8E,CAAC,0JACf7I,QAAAA,AAAI,EACF4F,MAAM,CAAC0iB,KAAK,wJACZ/oB,MAAM,AAAC6H,AAAG,CAAHA,CAAI,2JACTpH,QAAAA,AAAI,4KACFoB,IAAI,CAAC4C,GAAAA,AAAK,uJAAC9E,KAAQ,AAAH,AAACiK,CAAAA,CAAGwD,OAAO,CAACqb,UAAU,CAACnf,CAAC,CAAC,CAAC,CAAC,qKAC3C5H,OAAO,CAACgG,GAAAA,AAAQ,EAACkhB,IAAI,CAACvkB,KAAK,CAAC,CAAC,CAC9B,CACF,CACF,CACF,CACF;YACD,OAAO5D,+JAAAA,AAAI,EAACqoB,OAAO,wJAAE9oB,MAAM,CAAC2kB,EAAAA,AAAM,EAAC,IAAMoE,KAAK,CAAC,iKAAErnB,OAAO,CAAC+G,CAAM,CAAC;QAClE,CAAC;QACD,MAAMgE,IAAI,6KAA6E5K,IAAI,CAACsC,MAAAA,AAAQ,EAAC;YACnGC,OAAO,EAAEwkB,IAAI;YACblkB,SAAS,wKAAE7C,IAAI,CAAC8C,EAAI;YACpBC,MAAM,EAAEA,CAAA,yKAAM/C,IAAI,CAACgD,EAAAA;SACpB,CAAC;QACF,OAAO4H,IAAI;IACb,CAAC,CAAC,iKACF/K,OAAO,CAAC+G,CAAM,CACf;IACD,OAAO,IAAInF,UAAU,yJAAC7C,OAAAA,AAAI,EAACsE,SAAS,CAACjB,IAAI,CAAC,4KAAEjC,IAAI,CAACiD,IAAAA,AAAM,EAACuB,MAAM,CAAC,CAAC,CAAC;AACnE,CAAC,CACF;AAGM,MAAM2iB,WAAW,IAAOje,KAAQ,GACrC,IAAIzH,UAAU,oKACZ5B,OAAO,CAAC2b,GAAAA,AAAQ,4KAACxb,IAAI,CAAC4C,GAAAA,AAAK,uJAAC9E,KAAQ,AAAH,AAACiK,CAAAA,CAAGmB,KAAK,CAAC,CAAC,CAAC,CAC9C;AAGI,MAAMwd,UAAU,GAAA,WAAA,2JAAGhoB,OAAAA,AAAI,EAiB5B,CAAC,EACD,CACEuD,IAA4B,EAC5B2B,QAA2C,EAC3C2H,OAGC,KAC8B;IAC/B,+JAAO3M,OAAAA,AAAI,0JACTY,QAAQ,CAAO,AAANgF,EAAOZ,QAAQ,CAAC,wJACzBzF,MAAO6H,AAAG,AAAJ,CAACA,EAAKxB,MAAM,IAAI;QACpB,MAAM4iB,wBAAwB,GAAGrC,oBAAoB,qJACnDvlB,QAAQ,CAAC6nB,kBAAwB,EACjC/nB,GAAG,CAAC+G,qJAAAA,AAAG,EAAC7B,MAAM,CAAC8iB,aAAa,CAAC,CAC9B;QAED,MAAMvY,OAAO,2JAAGnQ,OAAAA,AAAI,EAACqD,IAAI,EAAEmlB,wBAAwB,EAAEphB,GAAG,CAACuF,OAAO,CAACob,SAAS,CAAC,EAAEzjB,SAAS,CAAC;QACvF,MAAM0H,IAAI,sKAAgF/K,OAAO,CAAC+G,CAAAA,AAAM,EACtGzI,MAAM,CAAC4F,uJAAK,AAALA,EACLS,MAAM,CAAC/B,IAAI,CAAC,KAAK,CAAC,CAAC,EACnB;YACEI,SAAS,EAAEA,CAAA,yKAAM7C,IAAI,CAACgD,EAAI;YAC1B+F,SAAS,GAAGgB,MAAM,6KAChB/J,IAAI,CAAC2C,KAAAA,AAAO,EACVoM,OAAO,EACP,uKAAMlP,OAAO,CAACgG,GAAAA,AAAQ,4KAAC7F,IAAI,CAAC4C,GAAK,AAALA,uJAAM9E,KAAK,AAACiK,AAAE,CAAFA,CAAGwD,OAAO,CAACqb,UAAU,CAAC7c,MAAM,CAAC,CAAC,CAAC,EAAEa,IAAI,CAAC;SAEnF,CACF,CACF;QACD,OAAO,IAAInJ,UAAU,CAAC5B,OAAO,CAACgG,sKAAQ,AAARA,EAASkJ,OAAO,EAAEnE,IAAI,CAAC,CAAC;IACxD,CAAC,CAAC,EACFhE,MAAM,CACP;AACH,CAAC,CACF;AAED,MAAM2gB,kBAAkB,GAAGA,CACzBre,KAAQ,EACRtF,QAAoC,GACL4jB,wBAAwB,uJAACrpB,MAAM,CAAC2H,GAAAA,AAAO,EAACoD,KAAK,CAAC,EAAEtF,QAAQ,CAAC;AAGnF,MAAM4jB,wBAAwB,GAAGA,CACtCvV,MAA8B,EAC9BrO,QAAsC,GAEtCjB,OAAO,CACL8B,UAAU,uJAACtG,MAAM,AAAC6hB,AAAG,CAAHA,CAAI/N,MAAM,0JAAEzS,QAAQ,CAACgF,AAAM,EAACZ,QAAQ,CAAC,CAAC,CAAC,EACzD,CAAC,CAAC6P,CAAC,EAAEjP,MAAM,CAAC,KAAI;QACd,MAAM4iB,wBAAwB,yJAAGjpB,MAAM,CAAC4mB,gBAAAA,AAAoB,sJAC1DvlB,QAAQ,CAAC6nB,kBAAwB,qJACjC/nB,GAAG,CAAC+G,EAAG,AAAHA,EAAI7B,MAAM,CAAC8iB,aAAa,CAAC,CAC9B;QACD,OAAOlU,MAAM,CACXtN,OAAO,CAAC2N,CAAC,CAAC,EACVT,YAAY,CAACS,CAAC,GAAGpR,CAAC,OAChBlE,MAAM,CAACspB,yJAAAA,AAAW,EAACjjB,MAAM,CAAC/B,IAAI,CAACJ,CAAO,CAAC,EAAE;gBACvCQ,SAAS,oJAAE1E,MAAM,CAAC2H,GAAO;gBACzBiD,SAAS,EAAEA,CAAA,yJACT5K,MAAO6H,AAAG,AAAJ,CAACA,CAAIohB,wBAAwB,CAACnV,MAAM,CAAC,GAAGyV,KAAK,GAAK1oB,MAAM,CAACmF,sJAAAA,AAAI,EAAC;4BAACujB,KAAK;4BAAEA,KAAK;yBAAU,CAAC;aAC/F,CAAC,CAAC,CACN;IACH,CAAC,CACF;AAGI,MAAMC,KAAK,GAAA,WAAA,2JAAGjpB,OAAAA,AAAI,EASvB,CAAC,EACD,CACEuD,IAA4B,EAC5B2lB,MAAkD,GAElDpoB,QAAQ,CAACgF,wJAAAA,AAAM,EAACojB,MAAM,CAAC,CAAChpB,IAAI,uJAC1BT,MAAM,AAAC6H,AAAG,CAAHA,EAAKxB,MAAM,IAAI;QACpB,MAAM4iB,wBAAwB,GAAGrC,oBAAoB,CACnDvlB,QAAQ,CAAC6nB,sKAAwB,EACjC/nB,GAAG,CAAC+G,qJAAAA,AAAG,EAAC7B,MAAM,CAAC8iB,aAAa,CAAC,CAC9B;QAED,MAAM1c,IAAI,GAQN1H,SAAS,CAACkkB,wBAAwB,CAACnlB,IAAI,CAAC,CAAC,CAACrD,IAAI,oKAChDiB,OAAO,CAACqhB,OAAAA,AAAY,GAAE3G,GAAG,yJAAKpc,KAAO8K,AAAE,CAAH,CAACA,AAAGzE,MAAM,CAAC0iB,KAAK,EAAE3M,GAAG,CAAC,CAAC,qKAC3D1a,OAAO,CAACoQ,GAAAA,AAAQ,GAAElF,KAAK,GACrBvG,MAAM,CAAC/B,IAAI,CAACsI,KAAK,CAAC,CAACnM,IAAI,uJACrBT,MAAM,CAAC4F,CAAAA,AAAK,EAAC;gBACXlB,SAAS,EAAEA,CAAA,OAAM7C,IAAI,CAAC8C,wKAAAA,AAAI,EAACiI,KAAK,CAAC;gBACjChC,SAAS,EAAEA,CAAA,GAAM6B;aAClB,CAAC,iKACF/K,OAAO,CAAC+G,CAAM,CACf,CACF,CACF;QACD,OAAOgE,IAAI;IACb,CAAC,CAAC,iKACF/K,OAAO,CAAC+G,CAAM,EACdqE,WAAW,CACZ,CACJ;AAGM,MAAM4c,iBAAiB,GAAA,WAAA,OA0B1BnpB,2JAAAA,AAAI,GAAEub,IAAI,GAAKrY,QAAQ,CAACqY,IAAI,CAAC,CAAC,CAAC,CAAC,EAAE,CACpChY,IAA4B,EAC5B2lB,MAKE,EACFrc,OAEC,GAED9C,OAAO,CAAC,MAAK;QACX,MAAMqf,8BAA8B,GAAGvc,OAAO,EAAEuc,8BAA8B,IAAI,KAAK;QACvF,IAAIC,CAAC,GAAG,CAAC;QACT,IAAIC,SAAS,yJAAGhpB,MAAM,CAACiF,AAAI,EAAe;QAC1C,MAAM2G,IAAI,GAINnC,OAAO,CAAC,MAAK;YACf,MAAMue,IAAI,GAAGY,MAAM,CAACK,KAAK,CAACF,CAAC,EAAE,CAAC;YAC9B,IAAI,CAACf,IAAI,EAAE;gBACT,OAAOlkB,IAAI,uJAAC9D,MAAM,CAACkpB,MAAAA,AAAU,EAACF,SAAS,CAAC,CAAC;YAC3C;YAEA,IAAIG,UAAU,yJAA6DnqB,OAAO,CAACoqB,KAAAA,AAAS,EAACpB,IAAI,CAACqB,OAAO,CAAC,GACtG9D,kBAAkB,CAACtiB,IAAI,EAAE+kB,IAAI,CAACqB,OAAO,CAAC,GACtClD,gBAAgB,CAACljB,IAAI,EAAE+kB,IAAI,CAACqB,OAAiD,CAAC;YAClF,IAAIC,gBAAgB,GAAG,KAAK;YAE5B,0JAAItpB,MAAM,CAAC0S,EAAAA,AAAM,EAACsW,SAAS,CAAC,EAAE;gBAC5B,MAAMjd,KAAK,GAAGid,SAAS,CAAC9e,KAAK;gBAC7B,IAAIqf,SAAS,GAAG,KAAK;gBACrB,MAAMC,OAAO,GAAGL,UAAU;gBAC1B,+CAAA;gBACAA,UAAU,GAAG1f,OAAO,CAAC,MAAK;oBACxB,IAAI8f,SAAS,EAAE,OAAOC,OAAO;oBAC7BD,SAAS,GAAG,IAAI;oBAChB,OAAOzlB,IAAI,CAACiI,KAAK,CAAC;gBACpB,CAAC,CAAC;gBACFod,UAAU,GAAGM,oBAAoB,CAACd,KAAK,CAACQ,UAAU,2KAAEtpB,mBAAsB6pB,AAAgB,EAAjB,AAAkB1B,CAAjB0B,GAAqB,EAAE,KAAK,CAAE,CAAC,CAAC;YAC5G,CAAC,MAAM;gBACL,MAAM9kB,QAAQ,4KAAG/E,mBAAsB6pB,AAAgB,EAAC1B,AAAlB,CAAC0B,GAAqB,EAAE,IAAI,CAAC;gBACnEP,UAAU,GAAGvkB,QAAQ,GAAG6kB,oBAAoB,CAACd,KAAK,CAACQ,UAAU,EAAEvkB,QAAQ,CAAC,CAAC,GAAGukB,UAAU;YACxF;YAEA,OAAOlY,QAAQ,CACb6X,8BAA8B,GAC5BjW,SAAS,CAACsW,UAAU,GAAGnd,KAAK,IAAI;gBAC9Bsd,gBAAgB,GAAG,IAAI;gBACvB,OAAOtd,KAAK;YACd,CAAC,CAAC,GACFmd,UAAU,GACXpd,KAAK,IAAI;gBACR,IAAI+c,8BAA8B,IAAIQ,gBAAgB,EAAE;oBACtD,OAAOxlB,IAAI,CAACiI,KAAK,CAAC;gBACpB;gBACAid,SAAS,wJAAGhpB,MAAM,CAACmF,CAAAA,AAAI,EAAC4G,KAAK,CAAC;gBAC9B,OAAOH,IAAI;YACb,CAAC,CACF;QACH,CAAC,CAAC;QACF,OAAOA,IAAI;IACb,CAAC,CAAC,CAAC;AAEL,MAAM6d,oBAAoB,IAAaxmB,IAA4B,GACjEiO,aAAa,CAACjO,IAAI,GAAGoD,KAAK,GAAKmB,SAAS,qKAACrG,gBAAgB,CAACwoB,WAAAA,AAAyB,EAACtjB,KAAK,CAAC,CAAC,CAAC;AAGvF,MAAMiC,GAAG,GAAA,WAAA,OAAG5I,2JAAAA,AAAI,EAUrB,CAAC,EAAE,CACHuD,IAA4B,EAC5BwB,IAAuC,GAEvCP,SAAS,CAACjB,IAAI,CAAC,CAACrD,IAAI,oKAClBiB,OAAO,CAACuH,OAAAA,AAAY,iKAAChH,KAAK,CAAC8C,OAAAA,AAAS,EAACO,IAAI,CAAC,CAAC,iKAC3C5D,OAAO,CAAC+oB,GAAQ,CACjB,CAAC;AAGG,MAAMC,UAAU,IACrB5mB,IAA4B,GACYqF,GAAG,CAACrF,IAAI,MAAE7B,KAAK,CAAC0oB,mKAAAA,AAAU,EAAE,CAAC;AAGhE,MAAMC,QAAQ,IAAa9mB,IAA4B,GAAkCqF,GAAG,CAACrF,IAAI,8JAAE7B,KAAK,CAAC+c,EAAK,CAAC;AAG/G,MAAMyL,QAAQ,IAAa3mB,IAA4B,GAAgCqF,GAAG,CAACrF,IAAI,8JAAE7B,KAAK,CAACiX,EAAK,CAAC;AAG7G,MAAM2R,OAAO,GAAA,WAAA,2JAAGtqB,OAAAA,AAAI,EAazB,CAAC,EACD,CAAauD,IAA4B,EAAEI,CAAI,EAAEoK,CAAoB,GACnEwc,YAAY,CAAChnB,IAAI,EAAEI,CAAC,sJAAE5D,YAAS,EAAEgO,CAAC,CAAC,CACtC;AAGM,MAAMyc,aAAa,GAAA,WAAA,2JAAGxqB,OAAAA,AAAI,EAU/B,CAAC,EAAE,CACHuD,IAA4B,EAC5BI,CAAI,EACJoK,CAA2C,GACN0c,kBAAkB,CAAClnB,IAAI,EAAEI,CAAC,sJAAE5D,YAAS,EAAEgO,CAAC,CAAC,CAAC;AAG1E,MAAM2c,aAAa,GAAA,WAAA,2JAAG1qB,OAAAA,AAAI,EAI/B,CAAC,EACD,CAAauD,IAA4B,EAAEI,CAAI,EAAEoK,CAAoB,2JACnE7N,OAAAA,AAAI,EAACqD,IAAI,EAAEonB,kBAAkB,CAAChnB,CAAC,sJAAE5D,YAAS,EAAEgO,CAAC,CAAC,CAAC,CAClD;AAGM,MAAM6c,mBAAmB,GAAA,WAAA,2JAAG5qB,OAAAA,AAAI,EAUrC,CAAC,EAAE,CACHuD,IAA4B,EAC5BI,CAAI,EACJoK,CAA2C,2JACQ7N,OAAAA,AAAI,EAACqD,IAAI,EAAEsnB,wBAAwB,CAAClnB,CAAC,sJAAE5D,YAAS,EAAEgO,CAAC,CAAC,CAAC,CAAC;AAGpG,MAAMwc,YAAY,GAAA,WAAA,2JAAGvqB,OAAI,AAAJA,EAc1B,CAAC,EAAE,CACHuD,IAA4B,EAC5BI,CAAI,EACJ8Y,IAAkB,EAClB1O,CAAoB,GACOnF,GAAG,CAACrF,IAAI,kKAAE7B,KAAK,CAACopB,CAAAA,AAAI,EAACnnB,CAAC,EAAE8Y,IAAI,EAAE1O,CAAC,CAAC,CAAC,CAAC;AAGxD,MAAM0c,kBAAkB,GAAA,WAAA,GAAGzqB,+JAAI,AAAJA,EAchC,CAAC,EAAE,CACHuD,IAA4B,EAC5BI,CAAI,EACJ8Y,IAAkB,EAClB1O,CAA2C,GACNnF,GAAG,CAACrF,IAAI,kKAAE7B,KAAK,CAACqpB,OAAAA,AAAU,EAACpnB,CAAC,EAAE8Y,IAAI,EAAE1O,CAAC,CAAC,CAAC,CAAC;AAGxE,MAAM4c,kBAAkB,GAAA,WAAA,2JAAG3qB,OAAAA,AAAI,EAYpC,CAAC,EAAE,CACHuD,IAA4B,EAC5BI,CAAI,EACJ8Y,IAAkB,EAClB1O,CAAoB,2JACqB7N,OAAAA,AAAI,EAACqD,IAAI,EAAE+N,SAAS,iKAAC5P,KAAK,CAACopB,CAAAA,AAAI,EAACnnB,CAAC,EAAE8Y,IAAI,EAAE1O,CAAC,CAAC,CAAC,CAAC,CAAC;AAGlF,MAAM8c,wBAAwB,GAAA,WAAA,2JAAG7qB,OAAAA,AAAI,EAY1C,CAAC,EAAE,CACHuD,IAA4B,EAC5BI,CAAI,EACJ8Y,IAAkB,EAClB1O,CAA2C,GACQ7N,+JAAAA,AAAI,EAACqD,IAAI,EAAE+N,SAAS,iKAAC5P,KAAK,CAACqpB,OAAAA,AAAU,EAACpnB,CAAC,EAAE8Y,IAAI,EAAE1O,CAAC,CAAC,CAAC,CAAC,CAAC;AAGlG,MAAMid,UAAU,GAAA,WAAA,2JAAGhrB,OAAAA,AAAI,EAU5B,CAAC,EAAE,CACHuD,IAA4B,EAC5BwK,CAAqC,GACGnF,GAAG,CAACrF,IAAI,kKAAE7B,KAAK,CAACmW,IAAAA,AAAO,EAAC9J,CAAC,CAAC,CAAC,CAAC;AAG/D,MAAMkd,eAAe,GAAA,WAAA,GAAGjrB,+JAAAA,AAAI,EAUjC,CAAC,EAAE,CACHuD,IAA4B,EAC5BwK,CAAkD,GACVnF,GAAG,CAACrF,IAAI,kKAAE7B,KAAK,CAACwpB,SAAAA,AAAY,EAACnd,CAAC,CAAC,CAAC,CAAC;AAGpE,MAAMod,qBAAqB,GAAA,WAAA,2JAAGnrB,OAAI,AAAJA,EAQnC,CAAC,EAAE,CACHuD,IAA4B,EAC5BwK,CAAkD,2JACI7N,OAAAA,AAAI,EAACqD,IAAI,EAAE+N,SAAS,iKAAC5P,KAAK,CAACwpB,SAAAA,AAAY,EAACnd,CAAC,CAAC,CAAC,CAAC,CAAC;AAG9F,MAAM2K,gBAAgB,GAAA,WAAA,2JAAG1Y,OAAAA,AAAI,EAQlC,CAAC,EAAE,CACHuD,IAA4B,EAC5BwK,CAAqC,2JACiB7N,OAAAA,AAAI,EAACqD,IAAI,EAAE+N,SAAS,iKAAC5P,KAAK,CAACmW,IAAAA,AAAO,EAAC9J,CAAC,CAAC,CAAC,CAAC,CAAC;AAGzF,MAAMqd,eAAe,GAAA,WAAA,OAAGprB,2JAAAA,AAAI,EAUjC,CAAC,EAAE,CACHuD,IAA4B,EAC5BwK,CAA2C,GACHnF,GAAG,CAACrF,IAAI,kKAAE7B,KAAK,CAAC2pB,SAAAA,AAAY,EAACtd,CAAC,CAAC,CAAC,CAAC;AAGpE,MAAMud,qBAAqB,GAAA,WAAA,2JAAGtrB,OAAAA,AAAI,EAQvC,CAAC,EAAE,CACHuD,IAA4B,EAC5BwK,CAA2C,IACW7N,8JAAAA,AAAI,EAACqD,IAAI,EAAE+N,SAAS,iKAAC5P,KAAK,CAAC2pB,SAAAA,AAAY,EAACtd,CAAC,CAAC,CAAC,CAAC,CAAC;AAG9F,MAAMwd,OAAO,IAClBhoB,IAA4B,GACcqF,GAAG,CAACrF,IAAI,kKAAE7B,KAAK,CAAC+X,CAAAA,AAAI,EAAK,CAAC;AAG/D,MAAM+R,aAAa,GAAA,WAAA,2JAAGxrB,OAAI,AAAJA,EAS3B,CAAC,EACD,CACEuD,IAA4B,EAC5B4L,MAAsC,2JACkBjP,OAAAA,AAAI,EAACqD,IAAI,EAAEkoB,YAAY,CAACtc,MAAM,CAAC,CAAC,CAC3F;AAGM,MAAMU,mBAAmB,GAAA,WAAA,2JAAG7P,OAAAA,AAAI,EAQrC,CAAC,EAAE,CACHuD,IAA4B,EAC5B4L,MAAsC,2JACUjP,OAAAA,AAAI,EAACqD,IAAI,EAAEmoB,kBAAkB,CAACvc,MAAM,CAAC,CAAC,CAAC;AAGlF,MAAMsc,YAAY,GAAA,WAAA,2JAAGzrB,OAAAA,AAAI,EAS9B,CAAC,EACD,CACEuD,IAA4B,EAC5B4H,KAAqC,2JACmBjL,OAAAA,AAAI,EAACqD,IAAI,EAAEmoB,kBAAkB,CAACvgB,KAAK,CAAC,oJAAE1L,MAAM,CAACoF,EAAM,CAAC,CAC/G;AAGM,MAAM8mB,0BAA0B,GAAA,WAAA,0JAAG3rB,QAAAA,AAAI,EAQ5C,CAAC,EAAE,CACHuD,IAA4B,EAC5B4H,KAAoD,KACL;IAC/C,MAAMsH,MAAM,6KAAmGnR,IAAI,CAChHiF,WAAAA,AAAa,EAAC;QACb1C,OAAO,GAAGC,KAAqB,GAC7BxC,IAAI,CAAC2C,+KAAAA,AAAO,4KACV3C,IAAI,CAACyE,QAAAA,AAAU,uJAACrF,KAAK,CAACkrB,KAAAA,AAAQ,EAACzgB,KAAK,uJAAE/L,KAAK,CAACkI,AAAG,EAACxD,KAAK,kJAAElE,IAAI,CAACwH,KAAO,CAAC,CAAC,CAAC,EACtE,IAAMqL,MAAM,CACb;QACHtO,SAAS,GAAGwC,KAAK,6KAAKrF,IAAI,CAACyE,QAAAA,AAAU,uJAACrF,KAAK,CAAC8F,EAAAA,AAAK,EAAC2E,KAAK,EAAEvL,IAAI,CAACkI,2JAAAA,AAAS,uJAAC3I,KAAK,CAACmI,AAAG,EAACX,KAAK,oJAAErG,MAAM,CAACmF,AAAI,CAAC,CAAC,CAAC,CAAC;QACxGpB,MAAM,EAAEA,CAAA,6KAAM/C,IAAI,CAACyE,QAAAA,AAAU,uJAACrF,KAAK,CAAC8F,EAAAA,AAAK,EAAC2E,KAAK,sJAAEvL,IAAI,CAACwE,EAAAA,AAAI,uJAAC9D,MAAM,CAACiF,CAAAA,AAAI,EAAE,CAAC,CAAC;KAC3E,CAAC;IACJ,+JAAOrF,OAAAA,AAAI,4KACToB,IAAI,CAACiD,IAAAA,AAAM,EAACC,SAAS,CAACjB,IAAI,CAAC,EAAEkP,MAAM,CAAC,gKACpCtR,OAAO,CAACwX,CAAK,iKACbxX,OAAO,CAACmQ,IAAS,oJACjB7R,MAAM,CAACmM,EAAM,CACd;AACH,CAAC,CAAC;AAGK,MAAM8f,kBAAkB,GAAA,WAAA,GAAG1rB,+JAAAA,AAAI,EAQpC,CAAC,EAAE,CACHuD,IAA4B,EAC5B4H,KAAqC,KACU;IAC/C,MAAMsH,MAAM,6KAAoFnR,IAAI,CACjGiF,WAAAA,AAAa,EAAC;QACb1C,OAAO,GAAGC,KAAqB,6KAAKxC,IAAI,CAAC2C,KAAAA,AAAO,4KAAC3C,IAAI,CAAC4C,GAAAA,AAAK,kKAAC9B,QAAakK,AAAK,EAACxI,EAAP,CAACwI,EAAW,CAAC,CAAC,EAAE,IAAMmG,MAAM,CAAC;QACrGtO,SAAS,GAAGwC,KAAK,GAAKrF,IAAI,CAAC4C,6KAAAA,AAAK,kKAAC9B,YAAY,AAAC0F,AAAS,CAATA,CAAUnB,KAAK,CAAC,CAAC;QAC/DtC,MAAM,EAAEA,CAAA,6KAAM/C,IAAI,CAAC4C,GAAK,AAALA,8JAAM9B,MAAgB,MAAJ,CAACyE;KACvC,CAAC;IACJ,+JAAO3G,OAAAA,AAAI,4KACToB,IAAI,CAACiD,IAAAA,AAAM,EAACC,SAAS,CAACjB,IAAI,CAAC,EAAEkP,MAAM,CAAC,MACpCtR,OAAO,CAACqhB,sKAAAA,AAAY,GAAEnb,IAAI,wJAAK3G,KAAK,CAAC8F,EAAAA,AAAK,EAAC2E,KAAK,EAAE9D,IAAI,CAAC,CAAC,iKACxDlG,OAAO,CAACwX,AAAK,EACbxX,OAAO,CAACmQ,mKAAS,oJACjB7R,MAAM,CAACmM,EAAM,CACd;AACH,CAAC,CAAC;AAGK,MAAMigB,OAAO,IAClBtoB,IAA4B,GACcqF,GAAG,CAACrF,IAAI,kKAAE7B,KAAK,CAACgR,CAAAA,AAAI,EAAE,CAAC;AAG5D,MAAMpB,SAAS,GAAA,WAAA,OAAGtR,2JAAAA,AAAI,EAQ3B,CAAC,EAAE,CACHuD,IAA4B,EAC5BwB,IAAuC,2JAEvC7E,OAAAA,AAAI,EACFsE,SAAS,CAACjB,IAAI,CAAC,qKACfpC,OAAO,CAACuH,OAAAA,AAAY,kKAAChH,KAAK,CAAC8C,MAAAA,AAAS,EAACO,IAAI,CAAC,CAAC,iKAC3C5D,OAAO,CAACwX,AAAK,iKACbxX,OAAO,CAACmQ,IAAS,CAClB,CAAC;AAGG,MAAMwa,MAAM,GAAUvoB,IAAiC,IAAkCqF,GAAG,CAACrF,IAAI,6JAAE7B,KAAK,CAACqqB,CAAG,CAAC;AAG7G,MAAMC,IAAI,GAAA,WAAA,2JAAGhsB,OAAAA,AAAI,EAItB,CAAC,EACD,CAAauD,IAA4B,EAAEI,CAAI,EAAEoK,CAAoB,2JACnE7N,OAAAA,AAAI,EAACqD,IAAI,EAAE0oB,UAAU,CAACtoB,CAAC,EAAE,CAACA,CAAC,EAAEoR,CAAC,OAAKtV,MAAM,CAAC2H,qJAAAA,AAAO,EAAC2G,CAAC,CAACpK,CAAC,EAAEoR,CAAC,CAAC,CAAC,CAAC,CAAC,CAC/D;AAGM,MAAMmX,UAAU,GAAA,WAAA,2JAAGlsB,OAAAA,AAAI,EAI5B,CAAC,EACD,CAAcuD,IAA4B,EAAEwK,CAA2B,0JACrE7N,QAAAA,AAAI,EAACqD,IAAI,EAAE4oB,gBAAgB,CAAC,CAACnX,EAAE,EAAED,CAAC,yJAAKtV,MAAM,CAAC2H,GAAAA,AAAO,EAAC2G,CAAC,CAACiH,EAAE,EAAED,CAAC,CAAC,CAAC,CAAC,CAAC,CACpE;AAGM,MAAMoX,gBAAgB,GAAA,WAAA,0JAAGnsB,QAAAA,AAAI,EASlC,CAAC,EACD,CACEuD,IAA4B,EAC5BwK,CAAsD,IAEtD7N,8JAAAA,AAAI,EACFqD,IAAI,EACJ8e,cAAc,uJAA2C/hB,MAAM,CAACiF,AAAI,EAA2B,GAAE,CAACuN,MAAM,EAAEiC,CAAC,KAAI;QAC7G,OAAQjC,MAAM,CAACtL,IAAI;YACjB,KAAK,MAAM;gBAAE;oBACX,6JAAO/H,MAAM,CAAC2H,GAAO,AAAPA,EAAQ;8KAAC9G,MAAM,CAAK,AAAJmF,EAAasP,CAAC,CAAC;wBAAEA,CAAC;qBAAU,CAAC;gBAC7D;YACA,KAAK,MAAM;gBAAE;oBACX,8JAAO7U,QAAI,AAAJA,EACL6N,CAAC,CAAC+E,MAAM,CAACtI,KAAK,EAAEuK,CAAC,CAAC,wJAClBtV,MAAM,AAAC6H,AAAG,CAAHA,EAAKyB,CAAC,GAAK;kLAACzI,MAAM,CAAK,AAAJmF,EAAasD,CAAC,CAAC;4BAAEA,CAAC;yBAAU,CAAC,CACxD;gBACH;QACF;IACF,CAAC,CAAC,CACH,CACJ;AAGM,MAAM7D,QAAQ,GAAA,WAAA,2JAAGlF,OAAAA,AAAI,EAS1B,CAAC,EACD,CACEuD,IAA4B,EAC5B2B,QAAsC,GAEtCC,SAAS,CACPinB,YAAY,CAAC7oB,IAAI,EAAE2B,QAAQ,EAAE;QAAE+iB,SAAS,EAAE3nB,MAAM,CAACmF,kJAAI;QAAEyiB,UAAU,oJAAE5nB,MAAM,CAACiF;IAAI,CAAE,CAAC,sJACjFtF,WAAQ,CACT,CACJ;AAGM,MAAMmsB,YAAY,GAAA,WAAA,2JAAGpsB,OAAAA,AAAI,EAiB9B,CAAC,EACD,CACEuD,IAA4B,EAC5B2B,QAAsC,EACtC2H,OAGC,KAC8B;IAC/B,MAAMX,IAAI,GAAGA,CACXpG,MAA0C,EAC1CiV,QAAqB,KAC0D;QAC/E,MAAMhX,IAAI,GAAGgX,QAAQ,CAAChX,IAAI,EAAE;QAC5B,IAAIA,IAAI,CAACoI,IAAI,EAAE;YACb,iLAAO7K,IAAI,CAACiF,WAAAA,AAAa,EAAC;gBACxB1C,OAAO,GAAGyI,KAAqB,GAAKJ,IAAI,CAACpG,MAAM,EAAEwG,KAAK,CAAC9J,MAAM,CAACuY,QAAQ,CAAC,EAAE,CAAC;gBAC1E5W,SAAS,wKAAE7C,IAAI,CAACwG,OAAS;gBACzBzD,MAAM,wKAAE/C,IAAI,CAACyY,QAAAA;aACd,CAAC;QACJ;QACA,0KAAO5Y,OAAO,CAAC+G,CAAAA,AAAM,MACnBzI,MAAM,CAACspB,yJAAW,AAAXA,EAAYjjB,MAAM,CAAC/B,IAAI,CAACA,IAAI,CAACyG,KAAW,CAAC,EAAE;YAChDrG,SAAS,EAAEA,CAAA,2JACTjE,OAAAA,AAAI,EACF4F,MAAM,CAAC4M,IAAI,oJACXjT,MAAM,CAACykB,CAAK,wJACZzkB,MAAM,AAAC6H,AAAG,CAAHA,CAAKyB,CAAC,2JACX7I,QAAAA,AAAI,4KACFoB,IAAI,CAAC4C,GAAAA,AAAK,uJAAC9E,KAAK,CAACwG,CAAAA,AAAI,EAACiH,OAAO,CAACob,SAAS,CAAClkB,IAAI,CAACyG,KAAK,CAAC,EAAEqC,OAAO,CAACqb,UAAU,CAACnf,CAAC,CAAC,CAAC,CAAC,4KAC5EzH,IAAI,CAAC2C,KAAAA,AAAO,EAAC,IAAMiI,IAAI,CAACpG,MAAM,EAAEiV,QAAQ,CAAC,CAAC,CAC3C,CACF,wJACDtb,MAAM,CAAC4sB,GAAO,AAAPA,EAAQvmB,MAAM,CAAC0iB,KAAK,CAAC,CAC7B;YACHne,SAAS,EAAEA,CAAA,wJACT5K,MAAM,CAAC2H,IAAAA,AAAO,0JAAClH,OAAAA,AAAI,4KACjBoB,IAAI,CAAC4C,GAAAA,AAAK,GAAC9E,KAAK,CAACiK,mJAAAA,AAAE,EAACwD,OAAO,CAACob,SAAS,CAAClkB,IAAI,CAACyG,KAAK,CAAC,CAAC,CAAC,4KACnDlJ,IAAI,CAAC2C,KAAO,AAAPA,EAAQ,IAAMiI,IAAI,CAACpG,MAAM,EAAEiV,QAAQ,CAAC,CAAC,CAC3C;SACJ,CAAC,CACH;IACH,CAAC;IACD,OAAO,IAAIhY,UAAU,yJACnB7C,OAAAA,AAAI,4KACFoB,IAAI,CAACyE,QAAU,AAAVA,0JAAWjF,QAAQ,CAACgF,AAAM,EAACZ,QAAQ,CAAC,CAAC,4KAC1C5D,IAAI,CAAC2C,KAAAA,AAAO,GAAE6B,MAAM,2JAClB5F,OAAAA,AAAI,EACFsE,SAAS,CAACjB,IAAI,CAAC,4KACfjC,IAAI,CAACiD,IAAAA,AAAM,EAAC2H,IAAI,CAACpG,MAAM,uJAAE1G,KAAK,CAACqF,EAAAA,AAAK,GAAK,CAACjC,MAAM,CAACuY,QAAQ,CAAC,EAAE,CAAC,CAAC,CAC/D,CACF,CACF,CACF;AACH,CAAC,CACF;AAGM,MAAMkR,UAAU,GAAA,WAAA,2JAAGjsB,OAAAA,AAAI,EAW5B,CAAC,EACD,CACEuD,IAA4B,EAC5BI,CAAI,EACJoK,CAA2C,GAE3C,IAAIhL,UAAU,yJACZ7C,OAAAA,AAAI,4KACFoB,IAAI,CAAC4C,GAAAA,AAAK,uJAAC9E,KAAK,AAACiK,AAAE,CAAFA,CAAG1F,CAAC,CAAC,CAAC,4KACvBrC,IAAI,CAAC2C,KAAAA,AAAO,EAAC,IACXO,SAAS,wJAACtE,QAAAA,AAAI,EACZqD,IAAI,EACJ8e,cAAc,CAAC1e,CAAC,EAAE,CAACA,CAAC,EAAEoR,CAAC,IAAK7U,8JAAAA,AAAI,EAAC6N,CAAC,CAACpK,CAAC,EAAEoR,CAAC,CAAC,wJAAEtV,MAAM,AAAC6H,AAAG,CAAHA,EAAK3D,CAAC,GAAK;oBAACA,CAAC;oBAAEA,CAAC;iBAAC,CAAC,CAAC,CAAC,CACtE,CAAC,CACH,CACF,CACF,CACJ;AAGM,MAAMkB,MAAM,GACjB0O,MAA8B,IAE9B,IAAIxQ,UAAU,EAAC5B,OAAO,CAACqL,qKAAQ,AAARA,qKAASrL,OAAO,CAAC0D,CAAAA,AAAM,0JAAC3E,OAAAA,AAAI,EAACqT,MAAM,wJAAE9T,MAAM,AAAC6H,AAAG,CAAHA,kJAAIlI,KAAK,AAAG,CAAFiK,AAAG,CAAC,CAAC,oJAAE5J,MAAM,CAAC6E,AAAI,CAAC,CAAC;AAG5F,MAAM6R,UAAU,IACrBpI,CAAiD,GAEjD,IAAIhL,UAAU,oKAAC5B,OAAO,CAACgV,KAAAA,AAAU,EAAE3N,KAAK,IACtCuF,CAAC,CAACvF,KAAK,CAAC,CAACtI,IAAI,uJACXT,MAAO6H,AAAD,AAAI,CAAHA,kJAAIlI,KAAQ,AAAH,CAACiK,AAAG,CACrB,CACF,CAAC;AAGG,MAAM5D,IAAI,IAAalC,IAA2C,OACvErD,2JAAAA,AAAI,EAACqD,IAAI,EAAEya,QAAQ,mJAAC1d,MAAM,CAACmF,AAAI,CAAC,EAAE6mB,UAAU,CAAC,0JAAMhsB,MAAM,CAACiF,AAAI,EAAE,CAAC,CAAC;AAG7D,MAAMgnB,UAAU,GAAA,WAAA,2JAAGvsB,OAAAA,AAAI,EAI5B,CAAC,EACD,CAAcuD,IAA2C,EAAEipB,QAAqB,OAC9EtsB,2JAAAA,AAAI,EAACqD,IAAI,EAAE+D,GAAG,uJAAChH,MAAM,CAACqR,KAAAA,AAAS,EAAC6a,QAAQ,CAAC,CAAC,CAAC,CAC9C;AAGM,MAAMF,UAAU,GAAA,WAAA,2JAAGtsB,OAAAA,AAAI,EAI5B,CAAC,EACD,CAAcuD,IAA2C,EAAE8I,KAAkB,GAC3EkO,mBAAmB,CACjBhX,IAAI,wJACJjD,MAAM,CAAC+E,CAAAA,AAAK,EAAC;QACX+D,MAAM,EAAEA,CAAA,yJAAM3J,MAAM,CAACkb,IAAAA,AAAQ,EAACtO,KAAK,CAAC;QACpC9C,MAAM,EAAE9J,MAAM,CAAC2H,qJAAAA;KAChB,CAAC,CACH,CACJ;AAGM,MAAM4D,OAAO,GAAA,WAAA,2JAAGhL,OAAAA,AAAI,EAMzB,CAAC,EACD,CAAUuD,IAA4B,EAAEod,SAAiB,GACvD8L,WAAW,CAAClpB,IAAI,EAAEod,SAAS,EAAE,CAAC,CAAC,CAClC;AAGM,MAAM8L,WAAW,GAAA,WAAA,2JAAGzsB,OAAAA,AAAI,EAO7B,CAAC,EACD,CAAUuD,IAA4B,EAAEod,SAAiB,EAAE+L,QAAgB,KAAyC;IAClH,IAAI/L,SAAS,IAAI,CAAC,IAAI+L,QAAQ,IAAI,CAAC,EAAE;QACnC,OAAOrW,GAAG,CACR,qJAAIlX,KAAK,CAACwtB,qBAAwB,CAAC,uEAAuE,CAAC,CAC5G;IACH;IACA,OAAO,IAAI5pB,UAAU,2KAACzB,IAAI,CAACyI,KAAO,AAAPA,EAAQ,MAAK;QACtC,MAAMoB,KAAK,GAAG,sKAAI3J,aAAU,CAAImf,SAAS,CAAC;QAC1C,MAAMiM,eAAe,GAAGA,CACtBC,SAAiB,EACjBC,UAAgG,KAC9F;YACF,IAAID,SAAS,GAAGlM,SAAS,EAAE;gBACzB,MAAMoM,KAAK,GAAG5hB,KAAK,CAAC6hB,OAAO,EAAE;gBAC7B,MAAMxP,MAAM,OAAGpe,KAAK,CAACia,qJAAAA,AAAO,EAAC0T,KAAK,CAAC,wJAAG3tB,KAAK,CAACqF,EAAAA,AAAK,EAAkB,IAAGrF,KAAK,CAACiK,oJAAAA,AAAE,EAAC0jB,KAAK,CAAC;gBACrF,+JAAO7sB,OAAI,AAAJA,4KAAKoB,IAAI,CAAC4C,GAAAA,AAAK,EAACsZ,MAAM,CAAC,EAAElc,IAAI,CAAC2C,+KAAAA,AAAO,EAAC,IAAM6oB,UAAU,CAAC,CAAC;YACjE;YACA,MAAMG,aAAa,GAAGJ,SAAS,GAAG,CAACA,SAAS,GAAGlM,SAAS,IAAI+L,QAAQ;YACpE,IAAIO,aAAa,KAAKJ,SAAS,EAAE;gBAC/B,OAAOC,UAAU;YACnB;YACA,MAAM7lB,SAAS,GAAG4lB,SAAS,GAAA,CAAII,aAAa,GAAGtM,SAAS,GAAG+L,QAAQ,CAAC;YACpE,MAAMQ,SAAS,2JAAGhtB,OAAAA,AAAI,EAACiL,KAAK,CAAC6hB,OAAO,EAAE,uJAAE5tB,KAAK,CAAC+tB,MAAAA,AAAS,EAAClmB,SAAS,CAAC,CAAC;YACnE,MAAMuW,MAAM,wJAAGpe,KAAK,CAACia,IAAAA,AAAO,EAAC6T,SAAS,CAAC,wJAAG9tB,KAAK,CAACqF,EAAAA,AAAK,EAAkB,yJAAGrF,KAAMiK,AAAE,AAAH,CAACA,CAAG6jB,SAAS,CAAC;YAC7F,+JAAOhtB,OAAAA,AAAI,4KAACoB,IAAI,CAAC4C,GAAAA,AAAK,EAACsZ,MAAM,CAAC,4KAAElc,IAAI,CAAC2C,KAAAA,AAAO,EAAC,IAAM6oB,UAAU,CAAC,CAAC;QACjE,CAAC;QACD,MAAMtT,MAAM,IACVqT,SAAiB,6KAEjBvrB,IAAI,CAACiF,WAAa,AAAbA,EAAc;gBACjB1C,OAAO,GAAGC,KAAqB,OAC7BxC,IAAI,CAAC2C,2KAAAA,AAAO,EACV3C,IAAI,CAAC4C,6KAAK,AAALA,uJACH9E,KAAK,CAAC+F,MAAAA,AAAS,EAACrB,KAAK,EAAE,CAAC4d,OAAO,EAAEsF,KAAK,KAAI;wBACxC7b,KAAK,CAACuO,GAAG,CAACgI,OAAO,CAAC;wBAClB,MAAM0L,YAAY,GAAGP,SAAS,GAAG7F,KAAK,GAAG,CAAC;wBAC1C,IAAIoG,YAAY,GAAGzM,SAAS,IAAI,CAACyM,YAAY,GAAGzM,SAAS,IAAI+L,QAAQ,GAAG,CAAC,EAAE;4BACzE,6JAAOpsB,MAAM,CAACiF,AAAI,EAAE;wBACtB;wBACA,6JAAOjF,MAAM,CAACmF,AAAI,EAAC0F,KAAK,CAAC6hB,OAAO,EAAE,CAAC;oBACrC,CAAC,CAAC,CACH,EACD,IAAMxT,MAAM,CAACqT,SAAS,GAAG/oB,KAAK,CAACqK,MAAM,CAAC,CACvC;gBACHhK,SAAS,GAAGwC,KAAK,GAAKimB,eAAe,CAACC,SAAS,4KAAEvrB,IAAI,CAACwG,OAAAA,AAAS,EAACnB,KAAK,CAAC,CAAC;gBACvEtC,MAAM,EAAEA,CAAA,GAAMuoB,eAAe,CAACC,SAAS,wKAAEvrB,IAAI,CAACgD,EAAI;aACnD,CAAC;QACJ,WAAOpE,2JAAAA,AAAI,EAACsE,SAAS,CAACjB,IAAI,CAAC,4KAAEjC,IAAI,CAACiD,IAAAA,AAAM,EAACiV,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;IACtD,CAAC,CAAC,CAAC;AACL,CAAC,CACF;AAGM,MAAM6T,KAAK,GAAA,WAAA,2JAYdrtB,OAAAA,AAAI,EACN,CAAC,EACD,CACEuD,IAA4B,EAC5BqW,SAAuB,KACgB;IACvC,MAAMyT,KAAK,GAAGA,CACZpmB,SAAyB,EACzBnD,KAAqB,KACsE;QAC3F,MAAM,CAACwI,KAAK,EAAEsa,SAAS,CAAC,2JAAG1mB,OAAAA,AAAI,EAAC+G,SAAS,uJAAE7H,KAAK,CAAC4E,MAAS,AAATA,EAAUF,KAAK,CAAC,uJAAE1E,KAAK,CAACwd,OAAAA,AAAU,EAAChD,SAAS,CAAC,CAAC;QAC/F,yJAAIxa,KAAK,CAACia,IAAAA,AAAO,EAAC/M,KAAK,CAAC,yJAAIlN,KAAK,CAACia,IAAAA,AAAO,EAACuN,SAAS,CAAC,EAAE;YACpD,OAAO1a,IAAI,yJAAChM,OAAAA,AAAI,EAACoM,KAAK,uJAAElN,KAAK,CAAC4E,MAAAA,AAAS,0JAAC9D,OAAAA,AAAI,EAAC0mB,SAAS,uJAAExnB,KAAK,CAAC2Z,CAAAA,AAAI,EAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QAC3E;QACA,+JAAO7Y,OAAAA,AAAI,2KACToB,IAAI,CAAC4C,IAAAA,AAAK,uJAAC9E,KAAK,AAACiK,AAAE,CAAFA,CAAGiD,KAAK,CAAC,CAAC,4KAC3BhL,IAAI,CAAC2C,KAAAA,AAAO,EAAC,IAAMopB,KAAK,sJAACjuB,KAAK,CAACqF,EAAAA,AAAK,EAAE,2JAAEvE,OAAAA,AAAI,EAAC0mB,SAAS,uJAAExnB,KAAK,CAAC2Z,CAAAA,AAAI,EAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CACzE;IACH,CAAC;IACD,MAAM7M,IAAI,IACRjF,SAAyB,GAEzB3F,IAAI,CAACsC,gLAAAA,AAAQ,EAAC;YACZC,OAAO,GAAGC,KAAqB,GAAKupB,KAAK,CAACpmB,SAAS,EAAEnD,KAAK,CAAC;YAC3DK,SAAS,wKAAE7C,IAAI,CAAC8C,EAAI;YACpBC,MAAM,EAAEA,CAAA,KAAK;gBACX,yJAAIjF,KAAK,CAACia,IAAO,AAAPA,EAAQpS,SAAS,CAAC,EAAE;oBAC5B,6KAAO3F,IAAI,CAACgD,EAAI;gBAClB;gBACA,IAAIhE,MAAM,CAACgtB,wJAAAA,AAAM,0JAACptB,OAAAA,AAAI,EAAC+G,SAAS,uJAAE7H,KAAK,CAACic,MAAS,AAATA,EAAUzB,SAAS,CAAC,CAAC,CAAC,EAAE;oBAC9D,0KAAOzY,OAAO,CAACgG,GAAAA,AAAQ,4KAAC7F,IAAI,CAAC4C,GAAAA,AAAK,uJAAC9E,KAAK,AAACiK,AAAE,CAAFA,CAAGpC,SAAS,CAAC,CAAC,wKAAE3F,IAAI,CAACgD,EAAI,CAAC;gBACrE;gBACA,0KAAOnD,OAAO,CAACgG,GAAAA,AAAQ,EACrBkmB,KAAK,sJAACjuB,KAAK,CAACqF,EAAAA,AAAK,EAAE,GAAEwC,SAAS,CAAC,wKAC/B3F,IAAI,CAACgD,EAAI,CACV;YACH;SACD,CAAC;IACJ,OAAO,IAAIvB,UAAU,CAAC7C,+JAAAA,AAAI,EAACsE,SAAS,CAACjB,IAAI,CAAC,4KAAEjC,IAAI,CAACiD,IAAAA,AAAM,EAAC2H,IAAI,sJAAC9M,KAAK,CAACqF,EAAAA,AAAK,EAAE,CAAC,CAAC,CAAC,CAAC;AAChF,CAAC,CACF;AAGM,MAAM8oB,YAAY,GAAA,WAAA,OAAGvtB,2JAAAA,AAAI,EAG9B,CAAC,EAAE,CAAUuD,IAA4B,EAAEiqB,SAAyB,KAAyC;IAC7G,MAAMzpB,IAAI,GAAGA,CACX0K,QAAuC,EACvCgf,cAAsB,6KAEtBnsB,IAAI,CAACiF,WAAAA,AAAa,EAAC;YACjB1C,OAAO,GAAG6pB,UAA0B,IAAI;gBACtC,IAAI3d,MAAyC;gBAC7C,MAAM,CAAC4d,KAAK,EAAEC,eAAe,CAAC,2JAAG1tB,OAAAA,AAAI,EACnCwtB,UAAU,uJACVtuB,KAAK,CAACyT,GAAAA,AAAM,EACV;qBAAC3S,8JAAAA,AAAI,EAACuO,QAAQ,wJAAEnO,MAAM,CAACqR,KAAAA,AAAS,EAAC,wJAAMvS,KAAK,CAACqF,GAAAA,AAAK,EAAK,CAAC,CAAC;oBAAEgpB,cAAc;iBAAU,EACnF,CAAC,CAACE,KAAK,EAAEC,eAAe,CAAC,EAAE7Y,CAAC,KAAI;oBAC9B,MAAM8Y,YAAY,IAAG3tB,8JAAAA,AAAI,EAACytB,KAAK,uJAAEvuB,KAAK,CAAC6T,GAAAA,AAAM,EAAC8B,CAAC,CAAC,CAAC;oBACjD,IACE6Y,eAAe,GAAGJ,SAAS,CAACrf,MAAM,yJAClCxO,KAAK,CAAC6S,GAAAA,AAAM,EAACuC,CAAC,0JAAE7U,OAAAA,AAAI,EAACstB,SAAS,uJAAEpuB,KAAK,CAAC8gB,MAAAA,AAAS,EAAC0N,eAAe,CAAC,CAAC,CAAC,EAClE;wBACA,IAAIA,eAAe,GAAG,CAAC,KAAKJ,SAAS,CAACrf,MAAM,EAAE;4BAC5C,IAAI4B,MAAM,KAAKnF,SAAS,EAAE;gCACxBmF,MAAM,GAAG,EAAE;4BACb;4BACAA,MAAM,CAAC2O,IAAI,CAACxe,+JAAI,AAAJA,EAAK2tB,YAAY,uJAAEzuB,KAAK,CAACiI,CAAAA,AAAI,EAACwmB,YAAY,CAAC1f,MAAM,GAAGqf,SAAS,CAACrf,MAAM,CAAC,CAAC,CAAC;4BACnF,OAAO;qLAAC/O,KAAK,CAACqF,EAAAA,AAAK,EAAK;gCAAE,CAAC;6BAAU;wBACvC;wBACA,OAAO;4BAACopB,YAAY;4BAAED,eAAe,GAAG,CAAC;yBAAU;oBACrD;oBACA,OAAO;wBAACC,YAAY;6KAAEluB,KAAK,CAAC6S,GAAAA,AAAM,EAACuC,CAAC,0JAAE7U,OAAAA,AAAI,EAACstB,SAAS,uJAAEpuB,KAAK,CAAC8gB,MAAAA,AAAS,EAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC;qBAAU;gBAC9F,CAAC,CACF,CACF;gBACD,MAAM7U,MAAM,GAAG0E,MAAM,KAAKnF,SAAS,wJAAGxL,KAAK,CAACqF,EAAAA,AAAK,EAAkB,yJAAGrF,KAAK,CAACmO,YAAAA,AAAe,EAACwC,MAAM,CAAC;gBACnG,OAAOzO,IAAI,CAAC2C,+KAAAA,AAAO,4KACjB3C,IAAI,CAAC4C,GAAAA,AAAK,EAACmH,MAAM,CAAC,EAClB,IAAMtH,IAAI,sJAAC3E,KAAK,CAACsH,OAAU,AAAVA,EAAWinB,KAAK,CAAC,GAAGrtB,MAAM,CAACmF,sJAAAA,AAAI,EAACkoB,KAAK,CAAC,yJAAGrtB,MAAM,CAACiF,AAAI,EAAE,GAAEqoB,eAAe,CAAC,CAC1F;YACH,CAAC;YACDzpB,SAAS,GAAGwC,KAAK,yJACfrG,MAAM,CAAC+E,CAAAA,AAAK,EAACoJ,QAAQ,EAAE;oBACrBrF,MAAM,EAAEA,CAAA,6KAAM9H,IAAI,CAACwG,OAAAA,AAAS,EAACnB,KAAK,CAAC;oBACnC4C,MAAM,GAAG+C,KAAK,sKACZnL,OAAO,CAACgG,GAAAA,AAAQ,4KACd7F,IAAI,CAAC4C,GAAAA,AAAK,uJAAC9E,KAAK,AAACiK,AAAE,CAAFA,CAAGiD,KAAK,CAAC,CAAC,4KAC3BhL,IAAI,CAACwG,OAAAA,AAAS,EAACnB,KAAK,CAAC;iBAE1B,CAAC;YACJtC,MAAM,GAAG8H,IAAI,yJACX7L,MAAM,CAAC+E,CAAK,AAALA,EAAMoJ,QAAQ,EAAE;oBACrBrF,MAAM,EAAEA,CAAA,6KAAM9H,IAAI,CAAC8F,KAAAA,AAAO,EAAC+E,IAAI,CAAC;oBAChC5C,MAAM,GAAG+C,KAAK,sKAAKnL,OAAO,CAACgG,GAAAA,AAAQ,4KAAC7F,IAAI,CAAC4C,GAAAA,AAAK,uJAAC9E,KAAK,AAAG,AAAFiK,CAAAA,CAAGiD,KAAK,CAAC,CAAC,4KAAEhL,IAAI,CAAC8F,KAAAA,AAAO,EAAC+E,IAAI,CAAC;iBACpF;SACJ,CAAC;IACJ,OAAO,IAAIpJ,UAAU,yJAAC7C,OAAAA,AAAI,EAACsE,SAAS,CAACjB,IAAI,CAAC,4KAAEjC,IAAI,CAACiD,IAAAA,AAAM,EAACR,IAAI,uJAACzD,MAAM,CAACiF,AAAI,EAAE,GAAE,CAAC,CAAC,CAAC,CAAC,CAAC;AACnF,CAAC,CAAC;AAGK,MAAMuoB,UAAU,IAAUvqB,IAAiC,GAChEkiB,kBAAkB,CAACliB,IAAI,qKAAEpC,OAAO,CAAC2sB,KAAAA,AAAU,EAAE,CAAC;AAGzC,MAAM1mB,OAAO,IAAOoD,KAAQ,GAAuBmT,SAAS,sJAACve,KAAQ,AAAH,AAACiK,CAAAA,CAAGmB,KAAK,CAAC,CAAC;AAG7E,MAAMe,IAAI,IAAOiL,QAAoB,GAAuBzM,OAAO,CAAC,IAAM4T,SAAS,sJAACve,KAAK,AAACiK,AAAE,CAAFA,CAAGmN,QAAQ,EAAE,CAAC,CAAC,CAAC;AAG1G,MAAMzM,OAAO,IAAa0T,MAAuC,GACtE,IAAI1a,UAAU,2KAACzB,IAAI,CAACyI,KAAAA,AAAO,EAAC,IAAMvF,SAAS,CAACiZ,MAAM,EAAE,CAAC,CAAC,CAAC;AAGlD,MAAMpW,IAAI,GAAA,WAAA,OAAGrH,2JAAI,AAAJA,EAGlB,CAAC,EAAE,CAAUuD,IAA4B,EAAEuK,CAAS,KAA4B;IAChF,IAAI,CAACiO,MAAM,CAACgS,SAAS,CAACjgB,CAAC,CAAC,EAAE;QACxB,OAAOuI,GAAG,CAAC,qJAAIlX,KAAK,CAACwtB,qBAAwB,CAAC,GAAG7e,CAAC,CAAA,mBAAA,CAAqB,CAAC,CAAC;IAC3E;IACA,MAAM5B,IAAI,GAAI4B,CAAS,8KACrBxM,IAAI,CAACsC,MAAAA,AAAQ,EAAC;YACZC,OAAO,GAAGC,KAAqB,IAAI;gBACjC,MAAMkqB,KAAK,2JAAG9tB,OAAAA,AAAI,EAAC4D,KAAK,uJAAE1E,KAAK,CAACiI,CAAAA,AAAI,EAAC6R,IAAI,CAACwN,GAAG,CAAC5Y,CAAC,EAAEiO,MAAM,CAACkS,iBAAiB,CAAC,CAAC,CAAC;gBAC5E,MAAMxf,QAAQ,GAAGyK,IAAI,CAACC,GAAG,CAAC,CAAC,EAAErL,CAAC,GAAGkgB,KAAK,CAAC7f,MAAM,CAAC;gBAC9C,MAAMiL,IAAI,GAAG3K,QAAQ,GAAG,CAAC;gBACzB,IAAI2K,IAAI,EAAE;oBACR,8JAAOlZ,QAAAA,AAAI,MAACoB,IAAI,CAAC4C,yKAAAA,AAAK,EAAC8pB,KAAK,CAAC,EAAE1sB,IAAI,CAAC2C,+KAAAA,AAAO,EAAC,IAAMiI,IAAI,CAACuC,QAAQ,CAAC,CAAC,CAAC;gBACpE;gBACA,iLAAOnN,IAAI,CAAC4C,GAAAA,AAAK,EAAC8pB,KAAK,CAAC;YAC1B,CAAC;YACD7pB,SAAS,wKAAE7C,IAAI,CAAC8C,EAAI;YACpBC,MAAM,EAAE/C,IAAI,CAAC8F,2KAAAA;SACd,CAAC;IACJ,OAAO,IAAIrE,UAAU,CACnB7C,+JAAAA,AAAI,EACFsE,SAAS,CAACjB,IAAI,CAAC,qKACfpC,OAAO,CAACuH,OAAY,AAAZA,EAAa,CAAC,GAAGoF,CAAC,GAAG5B,IAAI,CAAC4B,CAAC,CAAC,yKAAGxM,IAAI,CAACgD,EAAI,CAAC,CAClD,CACF;AACH,CAAC,CAAC;AAGK,MAAM6oB,SAAS,GAAA,WAAA,GAAGntB,+JAAAA,AAAI,EAG3B,CAAC,EAAE,CAAUuD,IAA4B,EAAEuK,CAAS,KAA4B;IAChF,IAAIA,CAAC,IAAI,CAAC,EAAE;QACV,OAAOrJ,KAAK;IACd;IACA,OAAO,IAAI1B,UAAU,CACnB7C,+JAAAA,AAAI,wJACFT,MAAM,CAAC2H,GAAO,AAAPA,EAAQ,sKAAI5F,aAAU,CAAIsM,CAAC,CAAC,CAAC,wJACpCrO,MAAM,AAAC6H,AAAG,CAAHA,EAAK6D,KAAK,IAAI;QACnB,MAAMqO,MAAM,6KAAyElY,IAAI,CAACsC,MAAAA,AAAQ,EAAC;YACjGC,OAAO,GAAGC,KAAqB,IAAI;gBACjC,KAAK,MAAM4d,OAAO,IAAI5d,KAAK,CAAE;oBAC3BqH,KAAK,CAACuO,GAAG,CAACgI,OAAO,CAAC;gBACpB;gBACA,OAAOlI,MAAM;YACf,CAAC;YACDrV,SAAS,wKAAE7C,IAAI,CAAC8C,EAAI;YACpBC,MAAM,EAAEA,CAAA,2JAAMnE,OAAAA,AAAI,4KAACoB,IAAI,CAAC4C,GAAAA,AAAK,EAACiH,KAAK,CAAC6hB,OAAO,EAAE,CAAC,EAAE7rB,OAAO,CAACgG,sKAAAA,AAAQ,wKAAC7F,IAAI,CAACgD,EAAI,CAAC;SAC5E,CAAC;QACF,+JAAOpE,OAAAA,AAAI,EAACsE,SAAS,CAACjB,IAAI,CAAC,4KAAEjC,IAAI,CAACiD,IAAM,AAANA,EAAOiV,MAAM,CAAC,CAAC;IACnD,CAAC,CAAC,iKACFrY,OAAO,CAAC+G,CAAM,CACf,CACF;AACH,CAAC,CAAC;AAGK,MAAMgmB,SAAS,GAAA,WAAA,2JAGlBluB,OAAAA,AAAI,EAAC,CAAC,EAAE,CAAUuD,IAA4B,EAAEqW,SAAuB,KAA4B;IACrG,MAAM1N,IAAI,6KAAoF5K,IAAI,CAACsC,MAAAA,AAAQ,EAAC;QAC1GC,OAAO,GAAGC,KAAqB,IAAI;YACjC,MAAMkqB,KAAK,2JAAG9tB,OAAAA,AAAI,EAAC4D,KAAK,uJAAE1E,KAAK,CAAC6nB,MAAAA,AAAS,GAAElS,CAAC,GAAK,CAAC6E,SAAS,CAAC7E,CAAC,CAAC,CAAC,CAAC;YAChE,MAAMrC,IAAI,2JAAGxS,OAAAA,AAAI,EAAC4D,KAAK,uJAAE1E,KAAK,CAAC2Z,CAAAA,AAAI,EAACiV,KAAK,CAAC7f,MAAM,CAAC,uJAAE/O,KAAK,CAACiI,CAAAA,AAAI,EAAC,CAAC,CAAC,CAAC;YACjE,yJAAIjI,KAAK,CAACia,IAAO,AAAPA,EAAQ3G,IAAI,CAAC,EAAE;gBACvB,+JAAOxS,OAAAA,AAAI,2KAACoB,IAAI,CAAC4C,IAAAA,AAAK,EAAC8pB,KAAK,CAAC,4KAAE1sB,IAAI,CAAC2C,KAAAA,AAAO,EAAC,IAAMiI,IAAI,CAAC,CAAC;YAC1D;YACA,iLAAO5K,IAAI,CAAC4C,GAAK,AAALA,0JAAMhE,OAAAA,AAAI,EAAC8tB,KAAK,uJAAE5uB,KAAK,CAAC4E,MAAAA,AAAS,EAAC0O,IAAI,CAAC,CAAC,CAAC;QACvD,CAAC;QACDvO,SAAS,wKAAE7C,IAAI,CAAC8C,EAAI;QACpBC,MAAM,wKAAE/C,IAAI,CAAC8F,KAAAA;KACd,CAAC;IACF,OAAO,IAAIrE,UAAU,yJAAC7C,OAAAA,AAAI,EAACsE,SAAS,CAACjB,IAAI,CAAC,qKAAEpC,OAAO,CAACuH,OAAAA,AAAY,EAACwD,IAAI,CAAC,CAAC,CAAC;AAC1E,CAAC,CAAC;AAGK,MAAMiiB,eAAe,GAAA,WAAA,2JAQxBnuB,OAAAA,AAAI,EACN,CAAC,EACD,CACEuD,IAA4B,EAC5BqW,SAAmD,KACf;IACpC,MAAM1N,IAAI,IACR6O,QAAqB,IAC+D;QACpF,MAAMhX,IAAI,GAAGgX,QAAQ,CAAChX,IAAI,EAAE;QAC5B,IAAIA,IAAI,CAACoI,IAAI,EAAE;YACb,iLAAO7K,IAAI,CAACiF,WAAAA,AAAa,EAAC;gBACxB1C,OAAO,GAAG6R,IAAI,GAAKxJ,IAAI,CAACwJ,IAAI,CAAClT,MAAM,CAACuY,QAAQ,CAAC,EAAE,CAAC;gBAChD5W,SAAS,wKAAE7C,IAAI,CAACwG,OAAS;gBACzBzD,MAAM,wKAAE/C,IAAI,CAAC8F,KAAAA;aACd,CAAC;QACJ;QACA,+JAAOlH,OAAI,AAAJA,EACL0Z,SAAS,CAAC7V,IAAI,CAACyG,KAAK,CAAC,wJACrB/K,MAAM,AAAC6H,AAAG,CAAHA,EAAKM,IAAI,GACdA,IAAI,6KACFtG,IAAI,CAAC4C,GAAAA,AAAK,uJAAC9E,KAAK,AAACiK,AAAE,CAAFA,CAAGtF,IAAI,CAACyG,KAAK,CAAC,CAAC,2JAChCtK,OAAAA,AAAI,4KACFoB,IAAI,CAAC4C,GAAAA,AAAK,uJAAC9E,KAAMiK,AAAE,AAAH,CAACA,CAAGtF,IAAI,CAACyG,KAAK,CAAC,CAAC,4KAChClJ,IAAI,CAAC2C,KAAO,AAAPA,EAAQ,IAAMiI,IAAI,CAAC6O,QAAQ,CAAC,CAAC,CACnC,CACJ,EACD5Z,OAAO,CAAC+G,gKAAM,CACf;IACH,CAAC;IACD,OAAO,IAAInF,UAAU,yJAAC7C,OAAAA,AAAI,EAACsE,SAAS,CAACjB,IAAI,CAAC,4KAAEjC,IAAI,CAACiD,IAAAA,AAAM,EAAC2H,IAAI,sJAAC9M,KAAK,CAACqF,EAAAA,AAAK,GAAK,CAACjC,MAAM,CAACuY,QAAQ,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;AACtG,CAAC,CACF;AAGM,MAAMkM,SAAS,GAAA,WAAA,2JAOlBjnB,OAAAA,AAAI,EAAC,CAAC,EAAE,CAAUuD,IAA4B,EAAEqW,SAAuB,KAA4B;IACrG,MAAM1N,IAAI,6KAAoF5K,IAAI,CAACsC,MAAAA,AAAQ,EAAC;QAC1GC,OAAO,EAAGC,KAAqB,IAAI;YACjC,MAAMkqB,KAAK,2JAAG9tB,OAAAA,AAAI,EAAC4D,KAAK,uJAAE1E,KAAK,CAAC6nB,MAAAA,AAAS,EAACrN,SAAS,CAAC,CAAC;YACrD,MAAMR,IAAI,GAAG4U,KAAK,CAAC7f,MAAM,KAAKrK,KAAK,CAACqK,MAAM;YAC1C,IAAIiL,IAAI,EAAE;gBACR,+JAAOlZ,OAAAA,AAAI,4KAACoB,IAAI,CAAC4C,GAAK,AAALA,EAAM8pB,KAAK,CAAC,GAAE1sB,IAAI,CAAC2C,8KAAAA,AAAO,EAAC,IAAMiI,IAAI,CAAC,CAAC;YAC1D;YACA,iLAAO5K,IAAI,CAAC4C,GAAAA,AAAK,EAAC8pB,KAAK,CAAC;QAC1B,CAAC;QACD7pB,SAAS,EAAE7C,IAAI,CAAC8C,wKAAI;QACpBC,MAAM,wKAAE/C,IAAI,CAAC8F,KAAAA;KACd,CAAC;IACF,OAAO,IAAIrE,UAAU,yJAAC7C,OAAAA,AAAI,EAACsE,SAAS,CAACjB,IAAI,CAAC,EAAEpC,OAAO,CAACuH,0KAAY,AAAZA,EAAawD,IAAI,CAAC,CAAC,CAAC;AAC1E,CAAC,CAAC;AAGK,MAAMa,GAAG,GAAA,WAAA,2JAQZ/M,OAAAA,AAAI,EACN,CAAC,EACD,CACEuD,IAA4B,EAC5BwK,CAAoD,GACfwM,mBAAmB,CAAChX,IAAI,GAAGwR,CAAC,yJAAKtV,KAAS,AAAF8K,CAAD,CAACA,AAAGwD,CAAC,CAACgH,CAAC,CAAC,EAAEA,CAAC,CAAC,CAAC,CAC5F;AAGM,MAAMqZ,OAAO,GAAA,WAAA,GAchBpuB,+JAAAA,AAAI,EACN,CAAC,EACD,CACEuD,IAA4B,EAC5BsJ,OAGC,2JAC8C3M,OAAAA,AAAI,EAACqD,IAAI,EAAE8qB,QAAQ,CAACxhB,OAAO,CAAC1I,SAAS,CAAC,EAAE4I,GAAG,CAACF,OAAO,CAACxC,SAAS,CAAC,CAAC,CACjH;AAGM,MAAMgkB,QAAQ,GAAA,WAAA,0JAQjBruB,QAAAA,AAAI,EACN,CAAC,EACD,CACEuD,IAA4B,EAC5BwK,CAAyC,GAEzCwD,QAAQ,CAAChO,IAAI,GAAG8I,KAAK,GAAKtG,UAAU,uJAACtG,MAAM,CAAC0H,IAAAA,AAAQ,EAAC4G,CAAC,CAAC1B,KAAK,CAAC,wJAAE5M,MAAM,CAAC2E,AAAI,EAACiI,KAAK,CAAC,CAAC,CAAC,CAAC,CACvF;AAGM,MAAM8Y,aAAa,GAAA,WAAA,2JAQtBnlB,OAAAA,AAAI,EACN,CAAC,EACD,CACEuD,IAA4B,EAC5BwK,CAAsD,KAClB;IACpC,MAAM7B,IAAI,IAAyF5K,IAAI,CACpGiF,oLAAa,AAAbA,EAAc;QACb1C,OAAO,GAAGyI,KAAK,6KAAKhL,IAAI,CAAC2C,KAAAA,AAAO,4KAAC3C,IAAI,CAAC4C,GAAAA,AAAK,EAACoI,KAAK,CAAC,EAAE,IAAMJ,IAAI,CAAC;QAC/D/H,SAAS,EAAGwC,KAAK,6KAAKrF,IAAI,CAACyE,SAAU,AAAVA,wJAAWtG,MAAM,CAAC0H,IAAAA,AAAQ,EAAC4G,CAAC,CAACpH,KAAK,CAAC,wJAAElH,MAAM,CAACqI,KAAAA,AAAS,EAACnB,KAAK,CAAC,CAAC,CAAC;QACzFtC,MAAM,wKAAE/C,IAAI,CAACyY,QAAAA;KACd,CAAC;IAEJ,OAAO,IAAIhX,UAAU,yJAAC7C,OAAAA,AAAI,EAACsE,SAAS,CAACjB,IAAI,CAAC,4KAAEjC,IAAI,CAACiD,IAAM,AAANA,EAAO2H,IAAI,CAAC,CAAC,CAAC;AACjE,CAAC,CACF;AAGM,MAAMoiB,OAAO,GAAA,WAAA,2JAAGtuB,OAAAA,AAAI,EASzB,CAAC,EACD,CACEuD,IAA4B,EAC5BwB,IAA4C,2JAE5C7E,OAAI,AAAJA,EACE6F,UAAU,uJAACtG,MAAU,AAAJ,AAACkG,CAAAA,CAAI;6JAACjF,KAAK,CAACmK,IAAAA,AAAO,EAAuB,CAAC,CAAC;gKAAEtL,OAASqG,AAAI,CAAL,CAACA,AAAY;KAAC,CAAC,CAAC,EACvF3B,OAAO,CAAC,CAAC,CAACkH,KAAK,EAAE+F,QAAQ,CAAC,KAAI;QAC5B,MAAM5H,KAAK,GAAGyF,WAAW,CAACC,SAAS,CAAC7D,KAAK,EAAE;YAAE8S,YAAY,EAAE;QAAC,CAAE,CAAC,CAAC;QAChE,MAAM/R,IAAI,GAAqF5K,IAAI,CAChGiF,qLAAAA,AAAa,EAAC;YACb1C,OAAO,GAAGyI,KAAqB,2JAC7BpM,OAAAA,AAAI,GACFoB,IAAI,CAACyE,iLAAU,AAAVA,uJAAWrF,KAAK,CAAC8F,EAAAA,AAAK,EAAC2E,KAAK,kKAAE/I,QAAakK,AAAK,EAACA,EAAP,CAACA,EAAW,CAAC,CAAC,CAAC,4KAC9DhL,IAAI,CAACitB,cAAAA,AAAgB,EAAC;oBACpBpqB,SAAS,EAAEA,CAAA,6KAAM7C,IAAI,CAAC2C,KAAAA,AAAO,4KAAC3C,IAAI,CAAC4C,GAAAA,AAAK,EAACoI,KAAK,CAAC,EAAE,uKAAMnL,OAAO,CAACuN,UAAAA,AAAe,EAAE,CAAC;oBACjFrE,SAAS,EAAEA,CAAA,6KAAM/I,IAAI,CAAC2C,KAAO,AAAPA,4KAAQ3C,IAAI,CAAC4C,GAAAA,AAAK,EAACoI,KAAK,CAAC,EAAE,IAAMJ,IAAI;iBAC5D,CAAC,CACiF;YACvF/H,SAAS,GAAGwC,KAA0B,2JACpCzG,OAAAA,AAAI,4KACFoB,IAAI,CAACyE,QAAAA,AAAU,uJAACrF,KAAK,CAAC8F,EAAAA,AAAK,EAAC2E,KAAK,kKAAE/I,YAAa0F,AAAD,AAAU,CAATA,CAAUnB,KAAK,CAAC,CAAC,CAAC,2KAClErF,IAAI,CAACitB,eAAAA,AAAgB,EAAC;oBACpBpqB,SAAS,EAAEA,CAAA,6KAAM7C,IAAI,CAACwG,OAAAA,AAAS,EAACnB,KAAK,CAAC;oBACtC0D,SAAS,EAAEA,CAAA,6KAAM/I,IAAI,CAACwG,OAAS,AAATA,EAAUnB,KAAK;iBACtC,CAAC,CACH;YACHtC,MAAM,EAAEA,CAAA,OACNnE,2JAAAA,AAAI,4KACFoB,IAAI,CAACyE,QAAAA,AAAU,uJAACrF,KAAK,CAAC8F,EAAAA,AAAK,EAAC2E,KAAK,8JAAE/I,MAAgB,CAAC,CAAC,IAAN,CAACyE,uKAChDvF,IAAI,CAACitB,cAAAA,AAAgB,EAAC;oBACpBpqB,SAAS,EAAEA,CAAA,yKAAM7C,IAAI,CAACgD,EAAI;oBAC1B+F,SAAS,EAAEA,CAAA,yKAAM/I,IAAI,CAACgD,EAAAA;iBACvB,CAAC;SAEP,CAAC;QACJ,+JAAOpE,OAAAA,AAAI,EACT,IAAI6C,UAAU,KAAC7C,2JAAAA,AAAI,EACjBoB,IAAI,CAACiD,8KAAAA,AAAM,EAACC,SAAS,CAACjB,IAAI,CAAC,EAAE2I,IAAI,CAAC,qKAClC/K,OAAO,CAACqL,GAAAA,AAAQ,wJAAC/M,MAAM,CAAC0H,IAAAA,AAAQ,wJAC9B1H,MAAM,CAAC2K,MAAAA,AAAU,uJAAC1J,KAAK,CAAC8F,EAAAA,AAAK,EAAC2E,KAAK,8JAAE/I,MAAgB,CAAC,CAAC,IAAN,CAACyE,qJAClDtH,QAAQ,AAAC0R,AAAK,CAALA,CAAMC,QAAQ,CAAC,CACzB,CAAC,CACH,CAAC,EACF6R,KAAK,CACHtI,OAAO,yJAACva,OAAAA,AAAI,EACV0I,GAAG,CAACU,KAAK,EAAEvE,IAAI,CAAC,EAChBtF,MAAM,CAAC+M,0JAAAA,AAAQ,wJAAC/M,MAAM,CAAC0H,IAAAA,AAAQ,uJAC7BzG,KAAK,CAAC0K,KAAAA,AAAQ,EAACD,KAAK,CAAC,yJACrB5L,QAAQ,CAAC6H,EAAAA,AAAO,EAAC8J,QAAQ,EAAE,KAAK,CAAC,CAAC,CACnC,CAAC,CACH,CAAC,CACH,CACF;IACH,CAAC,CAAC,CACH,CACJ;AAGM,MAAMsd,QAAQ,GAAA,WAAA,2JAAGxuB,OAAAA,AAAI,EAqB1B,CAAC,EACD,CACEuD,IAA4B,EAC5BsJ,OAMC,GAED4hB,cAAc,CAAClrB,IAAI,EAAE;QACnB,GAAGsJ,OAAO;QACV6hB,IAAI,GAAGpiB,KAAK,yJAAK7M,MAAM,CAAC2H,GAAAA,AAAO,EAACyF,OAAO,CAAC6hB,IAAI,CAACpiB,KAAK,CAAC;KACpD,CAAC,CACL;AAGM,MAAMmiB,cAAc,GAAA,WAAA,2JAAGzuB,OAAAA,AAAI,EAqBhC,CAAC,EACD,CACEuD,IAA4B,EAC5BsJ,OAMC,KACmC;IACpC,IAAIA,OAAO,CAAC/B,QAAQ,KAAK,SAAS,EAAE;QAClC,OAAO6jB,qBAAqB,CAACprB,IAAI,EAAEsJ,OAAO,CAAC6hB,IAAI,EAAE7hB,OAAO,CAAC+hB,KAAK,EAAE/hB,OAAO,CAACuI,QAAQ,EAAEvI,OAAO,CAACgiB,KAAK,IAAI,CAAC,CAAC;IACvG;IACA,OAAOC,mBAAmB,CAACvrB,IAAI,EAAEsJ,OAAO,CAAC6hB,IAAI,EAAE7hB,OAAO,CAAC+hB,KAAK,EAAE/hB,OAAO,CAACuI,QAAQ,EAAEvI,OAAO,CAACgiB,KAAK,IAAI,CAAC,CAAC;AACrG,CAAC,CACF;AAED,MAAMF,qBAAqB,GAAGA,CAC5BprB,IAA4B,EAC5BmrB,IAA8D,EAC9DE,KAAa,EACbxZ,QAAgC,EAChCyZ,KAAa,KACuB;IACpC,MAAM3iB,IAAI,GAAGA,CACX6iB,MAAc,EACdC,eAAuB,6KAEvB1tB,IAAI,CAACiF,WAAa,AAAbA,EAAc;YACjB1C,OAAO,GAAGC,KAAqB,2JAC7B5D,OAAAA,AAAI,EACFwuB,IAAI,CAAC5qB,KAAK,CAAC,EACXrE,MAAM,CAAC6hB,qJAAAA,AAAG,mJAACjiB,KAAK,CAAC4vB,cAAiB,CAAC,wJACnCxvB,MAAO6H,AAAG,AAAJ,CAACA,CAAI,CAAC,CAAC4nB,MAAM,EAAED,iBAAiB,CAAC,KAAI;oBACzC,MAAME,OAAO,GAAGF,iBAAiB,GAAGD,eAAe;oBACnD,MAAMI,MAAM,GAAGD,OAAO,2JAAG3vB,QAAQ,CAAC6vB,EAAAA,AAAQ,EAACja,QAAQ,CAAC;oBACpD,MAAM2W,GAAG,GAAGgD,MAAM,GAAIK,MAAM,GAAGR,KAAM;oBACrC,MAAMzV,GAAG,GAAGyV,KAAK,GAAGC,KAAK,GAAG,CAAC,GAAG9S,MAAM,CAACkS,iBAAiB,GAAGW,KAAK,GAAGC,KAAK;oBACxE,MAAMS,SAAS,GAAGvD,GAAG,GAAG,CAAC,GAAG5S,GAAG,GAAGD,IAAI,CAACwN,GAAG,CAACqF,GAAG,EAAE5S,GAAG,CAAC;oBACpD,IAAI+V,MAAM,IAAII,SAAS,EAAE;wBACvB,OAAOpvB,+JAAI,AAAJA,4KACLoB,IAAI,CAAC4C,GAAAA,AAAK,EAACJ,KAAK,CAAC,4KACjBxC,IAAI,CAAC2C,KAAAA,AAAO,EAAC,IAAMiI,IAAI,CAACojB,SAAS,GAAGJ,MAAM,EAAED,iBAAiB,CAAC,CAAC,CAChE;oBACH;oBACA,OAAO/iB,IAAI,CAAC6iB,MAAM,EAAEC,eAAe,CAAC;gBACtC,CAAC,CAAC,iKACF7tB,OAAO,CAAC+G,CAAM,CACf;YACH/D,SAAS,wKAAE7C,IAAI,CAACwG,OAAS;YACzBzD,MAAM,EAAEA,CAAA,yKAAM/C,IAAI,CAACgD,EAAAA;SACpB,CAAC;IACJ,MAAMirB,SAAS,GAAGrvB,+JAAI,AAAJA,EAChBb,KAAK,CAAC4vB,+JAAiB,wJACvBxvB,MAAM,AAAC6H,AAAG,CAAHA,CAAK2nB,iBAAiB,IAAK/iB,IAAI,CAAC0iB,KAAK,EAAEK,iBAAiB,CAAC,CAAC,iKACjE9tB,OAAO,CAAC+G,CAAM,CACf;IACD,OAAO,IAAInF,UAAU,yJAAC7C,OAAI,AAAJA,EAAKsE,SAAS,CAACjB,IAAI,CAAC,qKAAEpC,OAAO,CAACuH,OAAAA,AAAY,EAAC6mB,SAAS,CAAC,CAAC,CAAC;AAC/E,CAAC;AAED,MAAMT,mBAAmB,GAAGA,CAC1BvrB,IAA4B,EAC5BisB,MAAgE,EAChEZ,KAAa,EACbxZ,QAAgC,EAChCyZ,KAAa,KACuB;IACpC,MAAM3iB,IAAI,GAAGA,CACX6iB,MAAc,EACdC,eAAuB,6KAEvB1tB,IAAI,CAACiF,WAAAA,AAAa,EAAC;YACjB1C,OAAO,GAAGC,KAAqB,2JAC7B5D,OAAAA,AAAI,EACFsvB,MAAM,CAAC1rB,KAAK,CAAC,wJACbrE,MAAM,AAAC6hB,AAAG,CAAHA,kJAAIjiB,KAAK,CAAC4vB,cAAiB,CAAC,wJACnCxvB,MAAM,AAAC6H,AAAG,CAAHA,CAAI,CAAC,CAAC4nB,MAAM,EAAED,iBAAiB,CAAC,KAAI;oBACzC,MAAME,OAAO,GAAGF,iBAAiB,GAAGD,eAAe;oBACnD,MAAMI,MAAM,GAAGD,OAAO,GAAG3vB,QAAQ,CAAC6vB,0JAAAA,AAAQ,EAACja,QAAQ,CAAC;oBACpD,MAAM2W,GAAG,GAAGgD,MAAM,GAAIK,MAAM,GAAGR,KAAM;oBACrC,MAAMzV,GAAG,GAAGyV,KAAK,GAAGC,KAAK,GAAG,CAAC,GAAG9S,MAAM,CAACkS,iBAAiB,GAAGW,KAAK,GAAGC,KAAK;oBACxE,MAAMS,SAAS,GAAGvD,GAAG,GAAG,CAAC,GAAG5S,GAAG,GAAGD,IAAI,CAACwN,GAAG,CAACqF,GAAG,EAAE5S,GAAG,CAAC;oBACpD,MAAMyN,SAAS,GAAG0I,SAAS,GAAGJ,MAAM;oBACpC,MAAMO,UAAU,GAAG7I,SAAS,IAAI,CAAC,GAAG,CAAC,GAAG,CAACA,SAAS,GAAGgI,KAAK;oBAC1D,MAAMc,KAAK,2JAAGlwB,QAAQ,CAACmwB,AAAM,EAACzW,IAAI,CAACC,GAAG,CAAC,CAAC,EAAEsW,UAAU,2JAAGjwB,QAAQ,CAAC6vB,EAAAA,AAAQ,EAACja,QAAQ,CAAC,CAAC,CAAC;oBACpF,QAAI5V,QAAQ,CAACowB,yJAAAA,AAAW,EAACF,KAAK,sJAAElwB,OAAa,CAAL,AAAM,CAALqwB,CAAO;wBAC9C,+JAAO3vB,OAAAA,AAAI,4KACToB,IAAI,CAACyE,QAAAA,AAAU,uJAAC1G,KAAK,CAACkW,EAAAA,AAAK,EAACma,KAAK,CAAC,CAAC,qKACnCvuB,OAAO,CAACgG,GAAQ,AAARA,4KAAS7F,IAAI,CAAC4C,GAAAA,AAAK,EAACJ,KAAK,CAAC,CAAC,2KACnCxC,IAAI,CAAC2C,MAAO,AAAPA,EAAQ,IAAMiI,IAAI,CAAC0a,SAAS,EAAEqI,iBAAiB,CAAC,CAAC,CACvD;oBACH;oBACA,iLAAO3tB,IAAI,CAAC2C,KAAAA,AAAO,MACjB3C,IAAI,CAAC4C,yKAAAA,AAAK,EAACJ,KAAK,CAAC,EACjB,IAAMoI,IAAI,CAAC0a,SAAS,EAAEqI,iBAAiB,CAAC,CACzC;gBACH,CAAC,CAAC,iKACF9tB,OAAO,CAAC+G,CAAM,CACf;YACH/D,SAAS,wKAAE7C,IAAI,CAACwG,OAAS;YACzBzD,MAAM,EAAEA,CAAA,yKAAM/C,IAAI,CAACgD,EAAAA;SACpB,CAAC;IACJ,MAAMirB,SAAS,2JAAGrvB,OAAAA,AAAI,mJACpBb,KAAK,CAAC4vB,cAAiB,wJACvBxvB,MAAO6H,AAAG,AAAJ,CAACA,EAAK2nB,iBAAiB,GAAK/iB,IAAI,CAAC0iB,KAAK,EAAEK,iBAAiB,CAAC,CAAC,iKACjE9tB,OAAO,CAAC+G,CAAM,CACf;IACD,OAAO,IAAInF,UAAU,wJAAC7C,QAAI,AAAJA,EAAKsE,SAAS,CAACjB,IAAI,CAAC,qKAAEpC,OAAO,CAACuH,OAAAA,AAAY,EAAC6mB,SAAS,CAAC,CAAC,CAAC;AAC/E,CAAC;AAGM,MAAMO,IAAI,IAAIC,QAAgC,GACnDlH,kBAAkB,CAAC,KAAK,CAAC,0JAAE/nB,QAAQ,CAAO,AAANggB,EAAOiP,QAAQ,CAAC,CAAC;AAGhD,MAAM5nB,OAAO,GAAA,WAAA,2JAAGnI,OAAAA,AAAI,EAGzB,CAAC,EAAE,CAAUuD,IAA4B,EAAE6R,QAAgC,0JAC3ElV,QAAAA,AAAI,EACF8vB,MAAM,CAACzsB,IAAI,CAAC,wJACZ9D,MAAM,AAAC6H,AAAG,CAAHA,uJAAI7H,MAAM,CAACwwB,OAAAA,AAAW,EAAmB;QAC9CC,SAAS,EAAEA,CAAA,wJAAM5vB,MAAM,CAACiF,CAAAA,AAAI,EAAE;QAC9B6P;KACD,CAAC,CAAC,EACHzJ,QAAQ,CACT,CAAC;AAGG,MAAMskB,WAAW,GAAA,WAAA,2JAAGjwB,OAAI,AAAJA,EAWzB,CAAC,EACD,CACEuD,IAA4B,EAC5B8I,KAAkB,EAClB+I,QAAgC,GACAlV,+JAAAA,AAAI,EAACqD,IAAI,EAAE4sB,SAAS,CAAC/a,QAAQ,EAAEuF,QAAQ,CAACtO,KAAK,CAAC,CAAC,CAAC,CACnF;AAGM,MAAM+jB,gBAAgB,GAAA,WAAA,0JAAGpwB,QAAAA,AAAI,EAWlC,CAAC,EACD,CACEuD,IAA4B,EAC5BoD,KAA+B,EAC/ByO,QAAgC,2JAEhClV,OAAAA,AAAI,EACF8vB,MAAM,CAACzsB,IAAI,CAAC,EACZ9D,MAAM,CAAC6H,qJAAAA,AAAG,wJACR7H,MAAM,CAAC2wB,YAAAA,AAAgB,EAAwB;QAC7CF,SAAS,EAAEA,CAAA,wJAAM/wB,KAAK,CAACmI,AAAG,EAACX,KAAK,EAAE,oJAAErG,MAAM,CAACmF,AAAI,CAAC;QAChD2P;KACD,CAAC,CACH,EACDzJ,QAAQ,CACT,CACJ;AAGM,MAAMwkB,SAAS,GAAA,WAAA,OAAGnwB,2JAAAA,AAAI,EAW3B,CAAC,EACD,CACEuD,IAA4B,EAC5B6R,QAAgC,EAChCxB,IAA+B,KACU;IACzC,MAAMyc,aAAa,GAAG,qJAAIlxB,KAAK,CAACmxB,aAAgB,CAAC,gBAAgB,CAAC;IAClE,8JAAOpwB,QAAAA,AAAI,EACTqD,IAAI,EACJ6sB,gBAAgB,CAAS,yJAAMjxB,KAAK,CAACkX,AAAG,EAACga,aAAa,CAAC,EAAEjb,QAAQ,CAAC,EAClExD,cAAc,EAAEjL,KAAK,wJACnBxH,KAAK,CAACoxB,MAAAA,AAAS,EAAC5pB,KAAK,CAAC,yJACpBxH,KAAK,CAACqxB,eAAAA,AAAkB,EAAC7pB,KAAK,CAAC2P,MAAM,CAAC,IACtC3P,KAAK,CAAC2P,MAAM,CAACI,OAAO,KAAK9L,SAAS,IAClCjE,KAAK,CAAC2P,MAAM,CAACI,OAAO,KAAK,gBAAgB,yJACzCpW,MAAM,CAACmF,AAAI,EAACmO,IAAI,CAAC,yJACjBtT,MAAM,CAACiF,AAAI,EAAE,CAChB,CACF;AACH,CAAC,CACF;AAED,MAAMiK,iBAAiB,GACrB3C,OAOC,IACgD;IACjD,IAAI,OAAOA,OAAO,KAAK,QAAQ,EAAE;QAC/B,6JAAOpM,MAAM,CAACoK,GAAO,AAAPA,EAAQgC,OAAO,CAAC;IAChC,CAAC,MAAM,IAAIA,OAAO,CAACmD,QAAQ,KAAK,WAAW,EAAE;QAC3C,OAAOvP,MAAM,CAACkK,2JAAAA,AAAS,EAAC;YAAE8lB,MAAM,EAAE5jB,OAAO,CAAC4jB,MAAAA;QAAM,CAAE,CAAC;IACrD;IACA,OAAQ5jB,OAAO,CAAC/B,QAAQ;QACtB,KAAK,UAAU;YACb,WAAOrK,MAAM,CAACsK,sJAAQ,AAARA,EAAS8B,OAAO,CAAC;QACjC,KAAK,SAAS;YACZ,6JAAOpM,MAAM,CAACuK,GAAAA,AAAO,EAAC6B,OAAO,CAAC;QAChC;YACE,OAAOpM,MAAM,CAACoK,yJAAAA,AAAO,EAACgC,OAAO,CAAC;IAClC;AACF,CAAC;AAGM,MAAMqC,QAAQ,GAAA,WAAA,2JAAGlP,OAAAA,AAAI,EAsB1B,CAAC,EAAE,CACHuD,IAA4B,EAC5ByM,QAOC,IAED9P,8JAAAA,AAAI,wJACFT,MAAM,CAACiF,UAAAA,AAAc,EAAC8K,iBAAiB,CAAOQ,QAAQ,CAAC,GAAGb,MAAM,wJAAK1O,MAAM,CAAC2K,KAAAA,AAAQ,EAAC+D,MAAM,CAAC,CAAC,wJAC7F1P,MAAM,AAACsN,AAAG,CAAHA,EAAKoC,MAAM,GAAKjP,+JAAAA,AAAI,EAACqD,IAAI,EAAEsM,mBAAmB,CAACV,MAAM,CAAC,oJAAE1P,MAAM,CAACmQ,MAAU,CAAC,CAAC,CACnF,CAAC;AAGG,MAAMogB,MAAM,IACjBzsB,IAA4B,GAE5B9D,MAAM,CAAC6H,qJAAAA,AAAG,qKAACnG,OAAO,CAAC6uB,CAAAA,AAAM,EAACxrB,SAAS,CAACjB,IAAI,CAAC,CAAC,GAAGvB,IAAI,0JAC/C9B,QAAAA,AAAI,EACF8B,IAAI,wJACJvC,MAAM,CAACue,IAAAA,AAAQ,oJAAC1d,MAAM,CAACmF,AAAI,CAAC,EAC5BhG,MAAM,CAACwE,yJAAAA,AAAO,wJAACvE,MAAM,CAAC2F,CAAAA,AAAK,EAAC;YAC1BC,MAAM,EAAEA,CAAA,yJAAM7F,MAAM,CAAC2E,AAAI,wJAAC9D,MAAM,CAACiF,AAAI,EAAE,CAAC;YACxCC,OAAO,mJAAE/F,MAAM,CAAC2H,IAAAA;SACjB,CAAC,CAAC,CACJ,CAAC;AAGC,MAAMsJ,OAAO,GAAA,WAAA,2JAAG1Q,OAAI,AAAJA,GAoBpBub,IAAI,GAAKrY,QAAQ,CAACqY,IAAI,CAAC,CAAC,CAAC,CAAC,EAAE,CAC7BhY,IAA4B,EAC5BsJ,OAKC,yJAEDpN,MAAM,AAACsN,AAAG,CAAHA,uJACLtN,MAAM,CAACiF,UAAAA,AAAc,EACnBmI,OAAO,EAAE/B,QAAQ,KAAK,WAAW,wJAC/BpK,KAAK,CAACiK,MAAAA,AAAS,EAAmB,IAClCkC,OAAO,EAAE/B,QAAQ,KAAK,UAAU,wJAChCpK,KAAK,CAACqK,KAAAA,AAAQ,EAAkB8B,OAAO,CAACmD,QAAQ,IAAI,CAAC,CAAC,GACtDnD,OAAO,EAAE/B,QAAQ,KAAK,SAAS,wJAC/BpK,KAAK,CAACsK,IAAAA,AAAO,EAAkB6B,OAAO,CAACmD,QAAQ,IAAI,CAAC,CAAC,wJACrDtP,KAAK,CAACmK,IAAAA,AAAO,EAAkBgC,OAAO,EAAEmD,QAAQ,IAAI,CAAC,CAAC,GACvD7E,KAAK,wJAAKzK,KAAK,CAAC0K,KAAAA,AAAQ,EAACD,KAAK,CAAC,CACjC,GACAA,KAAK,yJAAK1L,MAAM,CAACmQ,MAAAA,AAAU,EAAC8b,kBAAkB,CAACnoB,IAAI,EAAE4H,KAAK,CAAC,CAAC,CAC9D,CAAC;AAGG,MAAMiF,iBAAiB,GAAA,WAAA,IAAGpQ,8JAAAA,AAAI,GAYlCub,IAAI,GAAKrY,QAAQ,CAACqY,IAAI,CAAC,CAAC,CAAC,CAAC,EAAE,CAC7BhY,IAA4B,EAC5BsJ,OAEC,yJAEDpN,MAAM,AAACsN,AAAG,CAAHA,KACLtN,MAAM,CAACiF,4JAAAA,AAAc,uJACnBhE,KAAK,CAACmK,IAAAA,AAAO,EAAiCgC,OAAO,EAAEmD,QAAQ,IAAI,CAAC,CAAC,GACpE7E,KAAK,GAAKzK,KAAK,CAAC0K,0JAAAA,AAAQ,EAACD,KAAK,CAAC,CACjC,GACAA,KAAK,yJAAK1L,MAAM,CAACmQ,MAAAA,AAAU,EAAC+b,0BAA0B,CAACpoB,IAAI,EAAE4H,KAAK,CAAC,CAAC,CACtE,CAAC;AAGG,MAAMulB,gBAAgB,GAAA,WAAA,2JAAG1wB,OAAAA,AAAI,GASjCub,IAAI,GAAKrY,QAAQ,CAACqY,IAAI,CAAC,CAAC,CAAC,CAAC,EAC3B,CACEhY,IAAyB,EACzBsJ,OAAgE,GAC7D8jB,uBAAuB,CAACptB,IAAI,EAAE1C,OAAO,CAAC+vB,4JAAc,EAAE/jB,OAAO,CAAC,CACpE;AAGM,MAAMgkB,sBAAsB,GAAA,WAAA,2JAAG7wB,OAAAA,AAAI,GASvCub,IAAI,GAAKrY,QAAQ,CAACqY,IAAI,CAAC,CAAC,CAAC,CAAC,EAC3B,CACEhY,IAA4B,EAC5BsJ,OAAgE,yJAC7DpN,MAAM,AAAC6H,AAAG,CAAHA,uJAAI7H,MAAM,CAAC6L,GAAAA,AAAO,EAAK,IAAGA,OAAO,GAAKqlB,uBAAuB,CAACptB,IAAI,EAAE+H,OAAO,EAAEuB,OAAO,CAAC,CAAC,CACnG;AAGM,MAAM8jB,uBAAuB,GAAA,WAAA,2JAAG3wB,OAAAA,AAAI,GAWxCub,IAAI,GAAKrY,QAAQ,CAACqY,IAAI,CAAC,CAAC,CAAC,CAAC,EAC3B,CACEhY,IAA4B,EAC5B+H,OAA4B,EAC5BuB,OAAgE,KAC3C;IACrB,MAAMikB,OAAO,0JAAGjwB,OAAO,CAACiwB,EAAAA,AAAO,EAACxlB,OAAO,CAAC;IACxC,IAAIylB,cAAc,GAA6BnmB,SAAS;IACxD,IAAI4K,KAAK,GAA4C5K,SAAS;IAC9D,MAAMiJ,KAAK,yJAAGpU,MAAM,CAACuxB,WAAAA,AAAe,EAAC,KAAK,CAAC;IAE3C,OAAO,IAAIC,cAAc,CAAI;QAC3B5f,KAAKA,EAAC6f,UAAU;YACd1b,KAAK,GAAGsb,OAAO,CAAC7F,eAAe,CAAC1nB,IAAI,GAAG+I,KAAK,IAAI;gBAC9C,IAAIA,KAAK,CAAC6B,MAAM,KAAK,CAAC,EAAE,yJAAO1O,MAAM,CAAC6E,AAAI;gBAC1C,OAAOuP,KAAK,CAACsd,QAAQ,uJAAC1xB,MAAM,CAAC8L,AAAI,EAAC,MAAK;oBACrCsI,KAAK,CAACud,WAAW,EAAE;oBACnB,KAAK,MAAMhkB,IAAI,IAAId,KAAK,CAAE;wBACxB4kB,UAAU,CAAC5b,OAAO,CAAClI,IAAI,CAAC;oBAC1B;oBACA2jB,cAAe,EAAE;oBACjBA,cAAc,GAAGnmB,SAAS;gBAC5B,CAAC,CAAC,CAAC;YACL,CAAC,CAAC,CAAC;YACH4K,KAAK,CAAC6b,WAAW,CAAEvlB,IAAI,IAAI;gBACzB,IAAI;oBACF,IAAIA,IAAI,CAACtE,IAAI,KAAK,SAAS,EAAE;wBAC3B0pB,UAAU,CAAC7kB,KAAK,sJAAClN,KAAK,CAAC8M,GAAAA,AAAM,EAACH,IAAI,CAACnF,KAAK,CAAC,CAAC;oBAC5C,CAAC,MAAM;wBACLuqB,UAAU,CAACI,KAAK,EAAE;oBACpB;gBACF,CAAC,CAAC,OAAM;gBACN,SAAA;gBAAA;YAEJ,CAAC,CAAC;QACJ,CAAC;QACDtvB,IAAIA,CAAA;YACF,OAAO,IAAIuvB,OAAO,EAAQC,OAAO,IAAI;gBACnCT,cAAc,GAAGS,OAAO;oBACxB/xB,MAAM,CAACgyB,qJAAO,AAAPA,EAAQ5d,KAAK,CAAC6d,IAAI,CAAC;YAC5B,CAAC,CAAC;QACJ,CAAC;QACDzS,MAAMA,CAAA;YACJ,IAAI,CAACzJ,KAAK,EAAE;YACZ,6JAAO/V,MAAM,CAACkyB,MAAU,AAAVA,wJAAWlyB,MAAM,CAACmM,EAAAA,AAAM,EAAC/L,KAAK,CAACiK,2JAAAA,AAAS,EAAC0L,KAAK,CAAC,CAAC,CAAC;QACjE;KACD,EAAE3I,OAAO,EAAE/B,QAAQ,CAAC;AACvB,CAAC,CACF;AAGM,MAAM8mB,SAAS,GAAA,WAAA,GAAG5xB,+JAAAA,AAAI,EAS3B,CAAC,EACD,CACEuD,IAA4B,EAC5BwB,IAAiC,KACI;IACrC,MAAM8sB,UAAU,6KAAGvwB,IAAI,CAACyI,KAAAA,AAAO,EAAC,MAAK;QACnC,MAAM9C,SAAS,GAAG;YAAEwG,GAAG,uJAAErO,KAAK,CAACqF,EAAAA,AAAK;QAAkB,CAAE;QACxD,MAAMqtB,YAAY,GAAG;YAAErkB,GAAG,EAAE;QAAK,CAAE;QACnC,MAAMsC,MAAM,6KAA4EzO,IAAI,CAACyI,KAAAA,AAAO,EAClG,MAAK;YACH,MAAM0E,QAAQ,GAAGxH,SAAS,CAACwG,GAAG;YAC9B,IAAIrO,KAAK,CAACia,yJAAAA,AAAO,EAAC5K,QAAQ,CAAC,EAAE;gBAC3B,iLAAOnN,IAAI,CAACsC,MAAAA,AAAQ,EAAC;oBACnBC,OAAO,GAAGC,KAAK,2JAAK5D,OAAAA,AAAI,MAACoB,IAAI,CAAC4C,yKAAAA,AAAK,EAACJ,KAAK,CAAC,4KAAExC,IAAI,CAAC2C,KAAAA,AAAO,EAAC,IAAM8L,MAAM,CAAC,CAAC;oBACvE5L,SAAS,wKAAE7C,IAAI,CAAC8C,EAAI;oBACpBC,MAAM,wKAAE/C,IAAI,CAACyY,QAAAA;iBACd,CAAC;YACJ;YACA9S,SAAS,CAACwG,GAAG,GAAGrO,KAAK,CAACqF,uJAAAA,AAAK,EAAkB;YAC7C,+JAAOvE,OAAAA,AAAI,qKAACiB,OAAO,CAAC6S,KAAAA,AAAU,EAACvF,QAAQ,CAAC,GAAEnN,IAAI,CAAC2C,8KAAAA,AAAO,EAAC,IAAM8L,MAAM,CAAC,CAAC;QACvE,CAAC,CACF;QACD,MAAMgiB,YAAY,IAAIzlB,KAAkC,IAAiC;YACvF,MAAMmC,QAAQ,GAAGxH,SAAS,CAACwG,GAAG;YAC9B,MAAMogB,YAAY,wJAAGzuB,KAAK,CAAC4E,MAAAA,AAAS,EAACyK,QAAQ,GAAErP,KAAK,CAACyb,uJAAAA,AAAM,EAACvO,KAAK,EAAGA,KAAK,IAAKA,KAAK,CAAC6B,MAAM,KAAK,CAAC,CAAC,CAAC;YAClGlH,SAAS,CAACwG,GAAG,GAAGogB,YAAY;YAC5B,OAAOA,YAAY;QACrB,CAAC;QACD,MAAMmE,cAAc,6KAA4E1wB,IAAI,CACjGsC,MAAAA,AAAQ,EAAC;YACRC,OAAO,GAAGC,KAAqB,6KAAKxC,IAAI,CAAC2C,KAAAA,AAAO,EAAC3C,IAAI,CAAC4C,6KAAAA,AAAK,EAACJ,KAAK,CAAC,EAAE,IAAMkuB,cAAc,CAAC;YACzF7tB,SAAS,wKAAE7C,IAAI,CAAC8C,EAAI;YACpBC,MAAM,GAAG8H,IAAI,sKACXhL,OAAO,CAACgG,GAAAA,AAAQ,4KACd7F,IAAI,CAACiK,EAAAA,AAAI,EAAC,MAAK;oBACbumB,YAAY,CAACrkB,GAAG,GAAG,IAAI;gBACzB,CAAC,CAAC,MACFnM,IAAI,CAACyY,8KAAAA,AAAU,EAAC5N,IAAI,CAAC;SAE1B,CAAC;QACJ,MAAM8lB,UAAU,2JAA2F/xB,OAAAA,AAAI,EAC7G6E,IAAI,8JACJrD,KAAK,CAAC8C,MAAS,wKACflD,IAAI,CAACqH,aAAe,4KACpBrH,IAAI,CAAC2C,KAAAA,AAAO,EAAC,CAAC,CAACwK,QAAQ,EAAEyW,CAAC,CAAC,2JACzBhlB,OAAAA,AAAI,4KACFoB,IAAI,CAAC8F,KAAAA,AAAO,EAAC;gBAAC0qB,YAAY,CAACrkB,GAAG;gBAAEskB,YAAY,CAACtjB,QAAQ,CAAC;aAAU,CAAC,MACjEnN,IAAI,CAAC2C,2KAAAA,AAAO,EAAC,CAAC,CAACkI,IAAI,EAAE+lB,YAAY,CAAC,KAAI;gBACpC,MAAMC,WAAW,GAAGhmB,IAAI,yJAAI/M,KAAK,CAACia,IAAAA,AAAO,EAAC6Y,YAAY,CAAC,yKACrD5wB,IAAI,CAACgD,EAAI,GACT2tB,UAAU;gBACZ,+JAAO/xB,OAAAA,AAAI,4KAACoB,IAAI,CAAC4C,GAAAA,AAAK,uJAAC9E,KAAK,AAACiK,AAAE,CAAFA,CAAG6b,CAAC,CAAC,CAAC,EAAE5jB,IAAI,CAAC2C,+KAAAA,AAAO,EAAC,IAAMkuB,WAAW,CAAC,CAAC;YACvE,CAAC,CAAC,CACH,CACF,CACF;QACD,+JAAOjyB,OAAAA,AAAI,EACTsE,SAAS,CAACjB,IAAI,CAAC,4KACfjC,IAAI,CAACiD,IAAAA,AAAM,EAACytB,cAAc,CAAC,EAC3B1wB,IAAI,CAACiD,8KAAAA,AAAM,EAACwL,MAAM,CAAC,qKACnB5O,OAAO,CAACuH,OAAAA,AAAY,EAACupB,UAAU,CAAC,CACjC;IACH,CAAC,CAAC;IACF,OAAO,IAAIlvB,UAAU,CAAC8uB,UAAU,CAAC;AACnC,CAAC,CACF;AAGM,MAAMO,sBAAsB,GAAA,WAAA,0JAAGpyB,QAAAA,AAAI,EASvCub,IAAI,IAAKrY,QAAQ,CAACqY,IAAI,CAAC,CAAC,CAAC,CAAC,EAC3B,CACEhY,IAA4B,EAC5B+H,OAA4B,KACR;IACpB,MAAMwlB,OAAO,0JAAGjwB,OAAO,CAACiwB,EAAAA,AAAO,EAACxlB,OAAO,CAAC;IACxC,OAAO;QACL,CAAC9I,MAAM,CAACya,aAAa,CAAA,GAAC;YACpB,IAAI8T,cAAc,GAAqDnmB,SAAS;YAChF,IAAIynB,aAAa,GAAwCznB,SAAS;YAClE,IAAI4K,KAAK,GAA4C5K,SAAS;YAC9D,MAAMiJ,KAAK,IAAGpU,MAAM,CAACuxB,gKAAAA,AAAe,EAAC,KAAK,CAAC;YAC3C,OAAO;gBACLjtB,IAAIA,CAAA;oBACF,IAAI,CAACyR,KAAK,EAAE;wBACVA,KAAK,GAAGsb,OAAO,CAAC9F,UAAU,CAACznB,IAAI,GAAGiH,KAAK,GACrCqJ,KAAK,CAACsd,QAAQ,KAAC1xB,MAAM,CAAC8L,kJAAAA,AAAI,EAAC,MAAK;gCAC9BsI,KAAK,CAACud,WAAW,EAAE;gCACnBL,cAAe,CAAC;oCAAE5kB,IAAI,EAAE,KAAK;oCAAE3B;gCAAK,CAAE,CAAC;gCACvCumB,cAAc,GAAGsB,aAAa,GAAGznB,SAAS;4BAC5C,CAAC,CAAC,CAAC,CAAC,CAAC;wBACP4K,KAAK,CAAC6b,WAAW,EAAEvlB,IAAI,IAAI;4BACzB0J,KAAK,GAAG/V,MAAM,CAACqxB,yJAAAA,AAAO,EAACjd,KAAK,CAACsd,QAAQ,uJAAC1xB,MAAM,CAAC8L,AAAI,EAAC,MAAK;gCACrD,IAAIO,IAAI,CAACtE,IAAI,KAAK,SAAS,EAAE;oCAC3B6qB,aAAc,sJAAClzB,KAAK,CAAC8M,GAAAA,AAAM,EAACH,IAAI,CAACnF,KAAK,CAAC,CAAC;gCAC1C,CAAC,MAAM;oCACLoqB,cAAe,CAAC;wCAAE5kB,IAAI,EAAE,IAAI;wCAAE3B,KAAK,EAAE,KAAK;oCAAC,CAAE,CAAC;gCAChD;gCACAumB,cAAc,GAAGsB,aAAa,GAAGznB,SAAS;4BAC5C,CAAC,CAAC,CAAC,CAAC;wBACN,CAAC,CAAC;oBACJ;oBACA,OAAO,IAAI2mB,OAAO,CAAoB,CAACC,OAAO,EAAEc,MAAM,KAAI;wBACxDvB,cAAc,GAAGS,OAAO;wBACxBa,aAAa,GAAGC,MAAM;wBACtBze,KAAK,CAAC0e,UAAU,EAAE;oBACpB,CAAC,CAAC;gBACJ,CAAC;gBACDrV,MAAMA,CAAA;oBACJ,IAAI,CAAC1H,KAAK,EAAE,OAAO+b,OAAO,CAACC,OAAO,CAAC;wBAAErlB,IAAI,EAAE,IAAI;wBAAE3B,KAAK,EAAE,KAAK;oBAAC,CAAE,CAAC;oBACjE,6JAAO/K,MAAM,CAACkyB,MAAAA,AAAU,wJAAClyB,KAAS,AAAF8K,CAAD,CAACA,qJAAG1K,KAAK,CAACiK,MAAAA,AAAS,EAAC0L,KAAK,CAAC,EAAE;wBAAErJ,IAAI,EAAE,IAAI;wBAAE3B,KAAK,EAAE,KAAK;oBAAC,CAAE,CAAC,CAAC;gBAC5F;aACD;QACH;KACD;AACH,CAAC,CACF;AAGM,MAAMgoB,eAAe,IAAUjvB,IAAyB,GAC7D6uB,sBAAsB,CAAC7uB,IAAI,qJAAE1C,OAAO,CAAC+vB,SAAc,CAAC;AAG/C,MAAM6B,qBAAqB,IAChClvB,IAA4B,yJAE5B9D,MAAU,AAAH6H,AAAD,CAACA,uJAAI7H,MAAM,CAAC6L,GAAO,AAAPA,EAAY,IAAGA,OAAO,GAAK8mB,sBAAsB,CAAC7uB,IAAI,EAAE+H,OAAO,CAAC,CAAC;AAG9E,MAAM4W,MAAM,GAAGA,CAAOve,CAAI,EAAEoK,CAA2C,GAC5E2kB,WAAW,CAAC/uB,CAAC,GAAGA,CAAC,2JAAKzD,OAAAA,AAAI,EAAC6N,CAAC,CAACpK,CAAC,CAAC,EAAErD,MAAM,CAACgH,qJAAG,AAAHA,EAAI,CAAC,CAACyN,CAAC,EAAEpR,CAAC,CAAC,GAAK;qKAACvE,KAAK,AAACiK,AAAE,CAAFA,CAAG0L,CAAC,CAAC;gBAAEpR,CAAC;aAAC,CAAC,CAAC,CAAC;AAGtE,MAAM+uB,WAAW,GAAGA,CACzB/uB,CAAI,EACJoK,CAAwD,KACpC;IACpB,MAAM7B,IAAI,IAAIvI,CAAI,yJAChBrD,MAAM,CAAC+E,CAAK,AAALA,EAAM0I,CAAC,CAACpK,CAAC,CAAC,EAAE;YACjByF,MAAM,EAAEA,CAAA,yKAAM9H,IAAI,CAACgD,EAAI;YACvBiF,MAAM,EAAEA,CAAC,CAAC+C,KAAK,EAAE3I,CAAC,CAAC,6KAAKrC,IAAI,CAAC2C,KAAAA,AAAO,4KAAC3C,IAAI,CAAC4C,GAAAA,AAAK,EAACoI,KAAK,CAAC,EAAE,IAAMJ,IAAI,CAACvI,CAAC,CAAC;SACtE,CAAC;IACJ,OAAO,IAAIZ,UAAU,2KAACzB,IAAI,CAACyI,KAAAA,AAAO,EAAC,IAAMmC,IAAI,CAACvI,CAAC,CAAC,CAAC,CAAC;AACpD,CAAC;AAGM,MAAM8Q,iBAAiB,GAAGA,CAC/B9Q,CAAI,EACJoK,CAA6E,GAE7EhE,OAAO,CAAC,MAAK;QACX,MAAMmC,IAAI,GAAIvI,CAAI,uKAChBxC,OAAO,CAAC+G,CAAAA,AAAM,wJACZzI,MAAM,AAAC6H,AAAG,CAAHA,CACLyG,CAAC,CAACpK,CAAC,CAAC,wJACJrD,MAAM,CAAC+E,CAAAA,AAAK,EAAC;gBACX+D,MAAM,EAAEA,CAAA,yKAAM9H,IAAI,CAACgD,EAAI;gBACvBiF,MAAM,EAAEA,CAAC,CAAC+C,KAAK,EAAE3I,CAAC,CAAC,GAAKrC,IAAI,CAAC2C,+KAAAA,AAAO,4KAAC3C,IAAI,CAAC4C,GAAAA,AAAK,EAACoI,KAAK,CAAC,EAAE,IAAMJ,IAAI,CAACvI,CAAC,CAAC;aACtE,CAAC,CACH,CACF;QACH,OAAO,IAAIZ,UAAU,CAACmJ,IAAI,CAACvI,CAAC,CAAC,CAAC;IAChC,CAAC,CAAC;AAGG,MAAM2Q,YAAY,GAAGA,CAC1B3Q,CAAI,EACJoK,CAAgE,GAEhE0G,iBAAiB,CAAC9Q,CAAC,GAAGA,CAAC,2JAAKzD,OAAAA,AAAI,EAAC6N,CAAC,CAACpK,CAAC,CAAC,wJAAElE,MAAU,AAAH6H,AAAD,CAACA,uJAAIhH,MAAU,AAAJ,AAACgH,CAAAA,CAAI,CAAC,CAACyN,CAAC,EAAEpR,CAAC,CAAC,GAAK;gBAACvE,KAAK,CAACiK,oJAAAA,AAAE,EAAC0L,CAAC,CAAC;gBAAEpR,CAAC;aAAC,CAAC,CAAC,CAAC,CAAC;AAE/F,MAAMgvB,KAAK,GAAA,WAAA,GAAwBvrB,OAAO,CAAC,KAAK,CAAC,CAAC;;AAO3C,MAAMc,MAAM,IACjBqL,MAAqD,GAChBtK,OAAO,CAAClD,UAAU,CAACwN,MAAM,CAAC,CAAC;AAG3D,MAAM9G,YAAY,IACvB8G,MAAqD,GACMtK,OAAO,CAACpE,MAAM,CAAC0O,MAAM,CAAC,CAAC;AAG7E,MAAMjJ,gBAAgB,IAC3ByD,CAAwE,GACnC9E,OAAO,CAACkN,UAAU,CAAE3N,KAAK,IAAKuF,CAAC,CAACvF,KAAK,CAAC,CAAC,CAAC;AAGxE,MAAMoqB,aAAa,GAAA,WAAA,IAAG5yB,8JAAAA,AAAI,EAW/B,CAAC,EACD,CACEuD,IAA4B,EAC5B4iB,GAAsB,EACtBpY,CAAkD,2JAElD7N,OAAAA,AAAI,EACFqD,IAAI,EACJuiB,eAAe,EAAE1L,OAAO,0JACtBla,QAAAA,AAAI,EACFka,OAAO,yJACP9a,MAAQknB,AAAG,CAAJ,CAACA,AAAIL,GAAG,EAAEpY,CAAC,yJAAC7N,OAAAA,AAAI,EAACka,OAAO,yJAAE9a,OAAO,CAAC4gB,IAAS,AAATA,EAAUiG,GAAG,CAAC,CAAC,CAAC,CAAC,CAC3D,CACF,CACF,CACJ;AAGM,MAAM1f,IAAI,GAAA,WAAA,2JAAGzG,OAAAA,AAAI,EAItB,CAAC,EACD,CAAUuD,IAA4B,EAAEsvB,IAAsB,2JAC5D3yB,OAAAA,AAAI,EAACqD,IAAI,EAAEuvB,UAAU,CAACrzB,MAAM,CAAC8L,sJAAAA,AAAI,EAACsnB,IAAI,CAAC,CAAC,CAAC,CAC5C;AAGM,MAAME,QAAQ,GAAGA,CACtBvc,QAAoB,EACpB9E,EAAoD,GACjDshB,cAAc,CAACthB,EAAE,CAAC,uJAACjS,MAAM,CAAC8L,AAAI,EAACiL,QAAQ,CAAC,CAAC;AAGvC,MAAMwc,cAAc,GAAA,WAAA,GAAGhzB,+JAAAA,AAAI,EAShC,CAAC,EACD,CACEuD,IAA4B,EAC5BmO,EAAsD,2JAEtDxR,OAAAA,AAAI,EACF6F,UAAU,CAACxC,IAAI,CAAC,EAChBU,OAAO,EAAE8Q,CAAC,2JAAK7U,OAAAA,AAAI,EAACwR,EAAE,CAACqD,CAAC,CAAC,GAAEzU,MAAM,CAACqR,0JAAAA,AAAS,EAAC,IAAMlN,KAAK,CAAC,CAAC,CAAC,CAC3D,CACJ;AAGM,MAAMquB,UAAU,GAAA,WAAA,2JAAG9yB,OAAAA,AAAI,EAS5B,CAAC,EACD,CACEuD,IAA4B,EAC5BgQ,MAAsC,2JACDrT,OAAAA,AAAI,EAAC6F,UAAU,CAACwN,MAAM,CAAC,EAAEtP,OAAO,EAAE2D,IAAI,GAAKA,IAAI,GAAGrE,IAAI,GAAGkB,KAAK,CAAC,CAAC,CACxG;AAGM,MAAMwuB,QAAQ,GAUjB,SAAAA,CAAA;IACF,MAAMC,SAAS,GAAG,OAAOjwB,SAAS,CAAC,CAAC,CAAC,KAAK,QAAQ;IAClD,MAAMkwB,IAAI,GAAGD,SAAS,GAAGjwB,SAAS,CAAC,CAAC,CAAC,GAAGA,SAAS,CAAC,CAAC,CAAC;IACpD,MAAM4J,OAAO,qKAAGxK,cAAc,CAAC+wB,KAAAA,AAAiB,EAACF,SAAS,GAAGjwB,SAAS,CAAC,CAAC,CAAC,GAAGA,SAAS,CAAC,CAAC,CAAC,CAAC;IACzF,IAAIiwB,SAAS,EAAE;QACb,MAAM3vB,IAAI,GAAGN,SAAS,CAAC,CAAC,CAAC;QACzB,OAAO,IAAIF,UAAU,oKAAC5B,OAAO,CAAC8xB,GAAAA,AAAQ,EAACzuB,SAAS,CAACjB,IAAI,CAAC,EAAE4vB,IAAI,EAAEtmB,OAAO,CAAC,CAAC;IACzE;IACA,OAAQtJ,IAAkC,IAAK,IAAIR,UAAU,oKAAC5B,OAAO,CAAC8xB,GAAAA,AAAQ,EAACzuB,SAAS,CAACjB,IAAI,CAAC,EAAE4vB,IAAI,EAAEtmB,OAAO,CAAC,CAAC;AACjH,CAAQ;AAGD,MAAMyU,GAAG,GAAA,WAAA,OAAGthB,2JAAAA,AAAI,EASrB,CAAC,EACD,CACEuD,IAA4B,EAC5BqQ,IAA+B,2JACY1T,OAAAA,AAAI,EAACqD,IAAI,EAAE8vB,OAAO,CAACzf,IAAI,EAAE,CAACmB,CAAC,EAAEC,EAAE,GAAK;YAACD,CAAC;YAAEC,EAAE;SAAC,CAAC,CAAC,CAC3F;AAGM,MAAMse,UAAU,GAAA,WAAA,GAAGtzB,+JAAAA,AAAI,EAW5B,CAAC,EACD,CACEuD,IAA4B,EAC5BqQ,IAA+B,2JACe1T,OAAAA,AAAI,EAACqD,IAAI,EAAE8vB,OAAO,CAACzf,IAAI,EAAE,CAACmB,CAAC,EAAEC,EAAE,GAAK,CAAC;eAAGD,CAAC;YAAEC,EAAE;SAAC,CAAC,CAAC,CACjG;AAGM,MAAMue,MAAM,GAAA,WAAA,2JAAGvzB,OAAAA,AAAI,EAiBxB,CAAC,EACD,CACEuD,IAA4B,EAC5BsJ,OAIC,GAED2mB,UAAU,CAACjwB,IAAI,EAAE;QACfigB,KAAK,EAAE3W,OAAO,CAAC2W,KAAK;QACpBP,MAAM,GAAGlO,CAAC,GAAK;gBAACA,CAAC;gBAAElI,OAAO,CAAC4mB,YAAY;aAAC;QACxCvQ,OAAO,EAAGlO,EAAE,IAAK;gBAACnI,OAAO,CAAC6mB,WAAW;gBAAE1e,EAAE;aAAC;QAC1C2e,MAAM,EAAEA,CAAC5e,CAAC,EAAEC,EAAE,GAAK;gBAACD,CAAC;gBAAEC,EAAE;aAAA;KAC1B,CAAC,CACL;AAGM,MAAM4e,UAAU,GAAA,WAAA,2JAAG5zB,OAAAA,AAAI,EAW5B,CAAC,EACD,CACEuD,IAA4B,EAC5BigB,KAAgC,EAChCkQ,WAAc,GAEdF,UAAU,CAACjwB,IAAI,EAAE;QACfigB,KAAK;QACLP,MAAM,sJAAEhjB,WAAQ;QAChBijB,OAAO,EAAEA,CAAA,GAAMwQ,WAAW;QAC1BC,MAAM,GAAG5e,CAAC,GAAKA;KAChB,CAAC,CACL;AAGM,MAAM8e,WAAW,GAAA,WAAA,2JAAG7zB,OAAAA,AAAI,EAW7B,CAAC,EACD,CACEuD,IAA4B,EAC5BigB,KAAgC,EAChCsQ,YAAgB,GAEhBN,UAAU,CAACjwB,IAAI,EAAE;QACfigB,KAAK;QACLP,MAAM,EAAEA,CAAA,GAAM6Q,YAAY;QAC1B5Q,OAAO,sJAAEjjB,WAAQ;QACjB0zB,MAAM,EAAEA,CAAC/wB,CAAC,EAAEoS,EAAE,GAAKA;KACpB,CAAC,CACL;AAGM,MAAM+e,iBAAiB,GAAA,WAAA,IAAG/zB,8JAAAA,AAAI,EAqBnC,CAAC,EACD,CACEuD,IAA0C,EAC1CsJ,OAKC,GAEDmnB,qBAAqB,CAACzwB,IAAI,EAAE;QAC1BigB,KAAK,EAAE3W,OAAO,CAAC2W,KAAK;QACpBP,MAAM,GAAGlO,CAAC,GAAK;gBAACA,CAAC;gBAAElI,OAAO,CAAC4mB,YAAY;aAAC;QACxCvQ,OAAO,GAAGlO,EAAE,GAAK;gBAACnI,OAAO,CAAC6mB,WAAW;gBAAE1e,EAAE;aAAC;QAC1C2e,MAAM,EAAEA,CAAC5e,CAAC,EAAEC,EAAE,GAAK;gBAACD,CAAC;gBAAEC,EAAE;aAAC;QAC1Bif,KAAK,EAAEpnB,OAAO,CAAConB,KAAAA;KAChB,CAAC,CACL;AAGM,MAAMC,qBAAqB,GAAA,WAAA,2JAAGl0B,OAAAA,AAAI,EAiBvC,CAAC,EACD,CACEuD,IAA0C,EAC1CsJ,OAIC,GAEDmnB,qBAAqB,CAACzwB,IAAI,EAAE;QAC1BigB,KAAK,EAAE3W,OAAO,CAAC2W,KAAK;QACpBP,MAAM,sJAAEhjB,WAAQ;QAChBijB,OAAO,EAAEA,CAAA,GAAMrW,OAAO,CAAC6mB,WAAW;QAClCC,MAAM,GAAG5e,CAAC,GAAKA,CAAC;QAChBkf,KAAK,EAAEpnB,OAAO,CAAConB,KAAAA;KAChB,CAAC,CACL;AAGM,MAAME,sBAAsB,GAAA,WAAA,2JAAGn0B,OAAAA,AAAI,EAiBxC,CAAC,EACD,CACEuD,IAA0C,EAC1CsJ,OAIC,GAEDmnB,qBAAqB,CAACzwB,IAAI,EAAE;QAC1BigB,KAAK,EAAE3W,OAAO,CAAC2W,KAAK;QACpBP,MAAM,EAAEA,CAAA,GAAMpW,OAAO,CAAC4mB,YAAY;QAClCvQ,OAAO,sJAAEjjB,WAAQ;QACjB0zB,MAAM,EAAEA,CAAC/wB,CAAC,EAAEoS,EAAE,GAAKA,EAAE;QACrBif,KAAK,EAAEpnB,OAAO,CAAConB,KAAAA;KAChB,CAAC,CACL;AAGM,MAAMD,qBAAqB,GAAA,WAAA,2JAAGh0B,OAAAA,AAAI,EAqBvC,CAAC,EACD,CACEuD,IAA0C,EAC1CsJ,OAMC,KACyC;IAC1C,MAAM7K,IAAI,GAAGA,CACX2T,KAAiE,EACjEvB,QAA0E,EAC1EC,SAA8E,KAW5E;QACF,OAAQsB,KAAK,CAACnO,IAAI;YAChB,kLAAKtF,WAAW,CAACkyB,IAAa;gBAAE;oBAC9B,+JAAOl0B,OAAAA,AAAI,EACTkU,QAAQ,MACR3U,MAAM,CAAC4F,mJAAAA,AAAK,EAAC;wBACXlB,SAAS,kJAAEvE,IAAI,CAACwE,EAAI;wBACpBiG,SAAS,GAAGgqB,SAAS,uJACnBz0B,IAAI,CAACwH,KAAAA,AAAO,EACV;qLACEhI,KAAK,CAACkI,AAAG,EAAC+sB,SAAS,EAAE,CAAC,CAAC1nB,CAAC,EAAEoI,CAAC,CAAC,GAAK;wCAACpI,CAAC;wCAAEE,OAAO,CAACoW,MAAM,CAAClO,CAAC,CAAC;qCAAC,CAAC;6MACxD7S,WAAW,CAACoyB,AAAS;6BACb;qBAEf,CAAC,CACH;gBACH;YACA,KAAKpyB,WAAW,CAACqyB,kLAAc;gBAAE;oBAC/B,+JAAOr0B,OAAAA,AAAI,EACTmU,SAAS,wJACT5U,MAAM,CAAC4F,CAAAA,AAAK,EAAC;wBACXlB,SAAS,kJAAEvE,IAAI,CAACwE,EAAI;wBACpBiG,SAAS,GAAGmqB,UAAU,uJACpB50B,IAAI,CAACwH,KAAAA,AAAO,EACV;qLACEhI,KAAK,CAAI,AAAHkI,EAAIktB,UAAU,EAAE,CAAC,CAAC7nB,CAAC,EAAEqI,EAAE,CAAC,GAAK;wCAACrI,CAAC;wCAAEE,OAAO,CAACqW,OAAO,CAAClO,EAAE,CAAC;qCAAC,CAAC;6MAC5D9S,WAAW,CAACuyB,CAAU;6BACd;qBAEf,CAAC,CACH;gBACH;YACA,KAAKvyB,WAAW,CAACwyB,gLAAY;gBAAE;oBAC7B,+JAAOx0B,OAAAA,AAAI,EACToT,MAAM,CAACc,QAAQ,CAAC,EAChB3U,MAAM,CAAC6hB,qJAAAA,AAAG,EAAChO,MAAM,CAACe,SAAS,CAAC,EAAE;wBAAEsgB,UAAU,EAAE;oBAAI,CAAE,CAAC,wJACnDl1B,MAAM,CAACspB,OAAAA,AAAW,EAAC;wBACjB5kB,SAAS,GAAGkI,KAAK,yJAAK5M,MAAM,CAAC2H,GAAAA,AAAO,sJAACxH,IAAI,CAACwE,EAAAA,AAAI,wJAAC9D,MAAM,CAAK,AAAJmF,EAAK4G,KAAK,CAAC,CAAC,CAAC;wBACnEhC,SAAS,EAAEA,CAAC,CAACuqB,UAAU,EAAEC,WAAW,CAAC,KAAI;4BACvC,0JAAIv0B,MAAM,CAAC0S,EAAM,AAANA,EAAO4hB,UAAU,CAAC,KAAIt0B,MAAM,CAAC0S,uJAAAA,AAAM,EAAC6hB,WAAW,CAAC,EAAE;gCAC3D,yJAAIz1B,KAAK,CAACia,IAAAA,AAAO,EAACub,UAAU,CAACpqB,KAAK,CAAC,yJAAIpL,KAAK,CAACia,IAAO,AAAPA,EAAQwb,WAAW,CAACrqB,KAAK,CAAC,EAAE;oCACvE,OAAOxI,IAAI,8KAACE,WAAW,AAAS,CAAR4yB,CAAU1gB,QAAQ,EAAEC,SAAS,CAAC;gCACxD;gCACA,yJAAIjV,KAAK,CAACia,IAAAA,AAAO,EAACub,UAAU,CAACpqB,KAAK,CAAC,EAAE;oCACnC,OAAOxI,IAAI,CAACE,WAAW,CAAC6yB,gLAAAA,AAAQ,EAACF,WAAW,CAACrqB,KAAK,CAAC,EAAE4J,QAAQ,EAAEC,SAAS,CAAC;gCAC3E;gCACA,yJAAIjV,KAAK,CAACia,IAAO,AAAPA,EAAQwb,WAAW,CAACrqB,KAAK,CAAC,EAAE;oCACpC,OAAOxI,IAAI,kLAACE,WAAW,CAAC8yB,AAAS,EAACJ,UAAU,CAACpqB,KAAK,CAAC,EAAE4J,QAAQ,EAAEC,SAAS,CAAC;gCAC3E;gCACA,4JAAO5U,MAAM,CAAC2H,IAAAA,AAAO,sJAACxH,IAAI,CAACwH,KAAAA,AAAO,EAAC2b,KAAK,CAAC6R,UAAU,CAACpqB,KAAK,EAAEqqB,WAAW,CAACrqB,KAAK,CAAC,CAAC,CAAC;4BACjF;4BACA,IAAIlK,MAAM,CAAC0S,wJAAAA,AAAM,EAAC4hB,UAAU,CAAC,0JAAIt0B,MAAM,CAACgtB,EAAAA,AAAM,EAACuH,WAAW,CAAC,EAAE;gCAC3D,IAAIz1B,KAAK,CAACia,yJAAAA,AAAO,EAACub,UAAU,CAACpqB,KAAK,CAAC,EAAE;oCACnC,OAAOxI,IAAI,8KAACE,WAAW,CAACoyB,AAAS,EAAElgB,QAAQ,EAAEC,SAAS,CAAC;gCACzD;gCACA,4JAAO5U,MAAM,CAAC2H,IAAAA,AAAO,sJACnBxH,IAAI,CAACwH,KAAAA,AAAO,EACV;4LACElH,OAAAA,AAAI,EAAC00B,UAAU,CAACpqB,KAAK,EAAEpL,KAAK,CAACkI,qJAAAA,AAAG,EAAC,CAAC,CAACqF,CAAC,EAAEoI,CAAC,CAAC,GAAK;4CAACpI,CAAC;4CAAEE,OAAO,CAACoW,MAAM,CAAClO,CAAC,CAAC;yCAAC,CAAC,CAAC;gNACrE7S,WAAW,CAACoyB,CAAS;iCACb,CACX,CACF;4BACH;4BACA,0JAAIh0B,MAAM,CAACgtB,EAAAA,AAAM,EAACsH,UAAU,CAAC,IAAIt0B,MAAM,CAAC0S,wJAAAA,AAAM,EAAC6hB,WAAW,CAAC,EAAE;gCAC3D,yJAAIz1B,KAAK,CAACia,IAAAA,AAAO,EAACwb,WAAW,CAACrqB,KAAK,CAAC,EAAE;oCACpC,OAAOxI,IAAI,8KAACE,WAAW,CAACuyB,CAAU,EAAErgB,QAAQ,EAAEC,SAAS,CAAC;gCAC1D;gCACA,6JAAO5U,MAAM,CAAC2H,GAAAA,AAAO,GACnBxH,IAAI,CAACwH,wJAAAA,AAAO,EACV;4LACElH,OAAAA,AAAI,EAAC20B,WAAW,CAACrqB,KAAK,uJAAEpL,KAAK,CAACkI,AAAG,EAAC,CAAC,CAACqF,CAAC,EAAEqI,EAAE,CAAC,GAAK;4CAACrI,CAAC;4CAAEE,OAAO,CAACqW,OAAO,CAAClO,EAAE,CAAC;yCAAC,CAAC,CAAC;iNACzE9S,WAAW,CAACuyB,CAAU;iCACd,CACX,CACF;4BACH;4BACA,WAAOh1B,MAAM,CAAC2H,qJAAO,AAAPA,GAAQxH,IAAI,CAACwE,qJAAAA,AAAI,wJAAwB9D,MAAM,CAACiF,AAAI,EAAE,CAAC,CAAC;wBACxE;qBACD,CAAC,CACH;gBACH;YACA,kLAAKrD,WAAW,CAAC+yB,GAAY;gBAAE;oBAC7B,OAAOx1B,MAAM,CAACspB,6JAAAA,AAAW,EAAC3U,QAAQ,EAAE;wBAClCjQ,SAAS,wJAAE7D,MAAM,CAAC+E,CAAAA,AAAK,EAAC;4BACtB+D,MAAM,EAAEA,CAAA,yJACN3J,MAAM,CAAC2H,GAAAA,AAAO,sJACZxH,IAAI,CAACwH,KAAO,AAAPA,EAAQ;4LACXlH,OAAAA,AAAI,EAACyV,KAAK,CAAC6e,UAAU,uJAAEp1B,KAAK,CAACkI,AAAG,EAAC,CAAC,CAACqF,CAAC,EAAEqI,EAAE,CAAC,GAAK;4CAACrI,CAAC;4CAAEE,OAAO,CAACqW,OAAO,CAAClO,EAAE,CAAC;yCAAC,CAAC,CAAC;iNACxE9S,WAAW,CAACuyB,CAAU;iCACvB,CAAC,CACH;4BACHlrB,MAAM,GAAG8C,KAAK,OACZ5M,MAAM,CAAC2H,qJAAAA,AAAO,sJAQZxH,IAAI,CAACwE,EAAAA,AAAI,wJAAC9D,MAAM,CAACmF,AAAI,EAAC4G,KAAK,CAAC,CAAC;yBAClC,CAAC;wBACFhC,SAAS,GAAGgqB,SAAS,wJACnBj1B,KAAK,CAACia,IAAAA,AAAO,EAACgb,SAAS,CAAC,GACtBryB,IAAI,kLAACE,WAAW,AAAC6yB,AAAQ,CAARA,CAASpf,KAAK,CAAC6e,UAAU,CAAC,EAAEpgB,QAAQ,EAAEC,SAAS,CAAC,yJACjE5U,MAAM,CAAC2H,GAAO,AAAPA,sJAAQxH,IAAI,CAACwH,KAAAA,AAAO,EAAC2b,KAAK,CAACsR,SAAS,EAAE1e,KAAK,CAAC6e,UAAU,CAAC,CAAC;qBACpE,CAAC;gBACJ;YACA,kLAAKtyB,WAAW,CAACgzB,IAAa;gBAAE;oBAC9B,6JAAOz1B,MAAM,CAACspB,OAAAA,AAAW,EAAC1U,SAAS,EAAE;wBACnClQ,SAAS,EAAE7D,MAAM,CAAC+E,uJAAAA,AAAK,EAAC;4BACtB+D,MAAM,EAAEA,CAAA,yJACN3J,MAAM,CAAC2H,GAAAA,AAAO,sJACZxH,IAAI,CAACwH,KAAAA,AAAO,EACV;wLACEhI,KAAK,CAACkI,CAAAA,AAAG,EAACqO,KAAK,CAAC0e,SAAS,EAAE,CAAC,CAAC1nB,CAAC,EAAEoI,CAAC,CAAC,GAAK;4CAACpI,CAAC;4CAAEE,OAAO,CAACoW,MAAM,CAAClO,CAAC,CAAC;yCAAC,CAAC;oCAC9D7S,WAAW,CAACoyB,6KAAS;iCACb,CACX,CACF;4BACH/qB,MAAM,GAAG8C,KAAK,yJACZ5M,MAAM,CAAC2H,GAAAA,AAAO,sJAQZxH,IAAI,CAACwE,EAAAA,AAAI,wJAAC9D,MAAM,CAACmF,AAAI,EAAC4G,KAAK,CAAC,CAAC;yBAClC,CAAC;wBACFhC,SAAS,GAAGmqB,UAAU,uJACpBp1B,KAAK,CAACia,KAAO,AAAPA,EAAQmb,UAAU,CAAC,GACvBxyB,IAAI,kLAACE,WAAW,CAAC8yB,AAAS,AAATA,EAAUrf,KAAK,CAAC0e,SAAS,CAAC,EAAEjgB,QAAQ,EAAEC,SAAS,CAAC,yJACjE5U,MAAM,CAAC2H,GAAAA,AAAO,sJAACxH,IAAI,CAACwH,KAAAA,AAAO,EAAC2b,KAAK,CAACpN,KAAK,CAAC0e,SAAS,EAAEG,UAAU,CAAC,CAAC;qBACpE,CAAC;gBACJ;QACF;IACF,CAAC;IACD,MAAMzR,KAAK,GAAGA,CACZsR,SAAuC,EACvCG,UAAyC,KAIvC;QACF,MAAMW,OAAO,GAAGA,CAAI7oB,KAAqB,EAAE0a,KAAa,GAAKA,KAAK,GAAG1a,KAAK,CAAC6B,MAAM,GAAG,CAAC;QACrF,MAAMqQ,OAAO,GAAmB,EAAE;QAClC,IAAI7I,KAAK,GAKO/K,SAAS;QACzB,IAAIwqB,SAAS,GAAG,CAAC;QACjB,IAAIC,UAAU,GAAG,CAAC;QAClB,IAAIC,SAAS,0JAAGp1B,QAAI,AAAJA,EAAKm0B,SAAS,uJAAEj1B,KAAK,CAAC8gB,MAAAA,AAAS,EAACkV,SAAS,CAAC,CAAC;QAC3D,IAAIG,UAAU,2JAAGr1B,OAAAA,AAAI,EAACs0B,UAAU,uJAAEp1B,KAAK,CAAC8gB,MAAAA,AAAS,EAACmV,UAAU,CAAC,CAAC;QAC9D,IAAIG,EAAE,GAAGF,SAAS,CAAC,CAAC,CAAC;QACrB,IAAIvgB,CAAC,GAAGugB,SAAS,CAAC,CAAC,CAAC;QACpB,IAAIG,EAAE,GAAGF,UAAU,CAAC,CAAC,CAAC;QACtB,IAAIvgB,EAAE,GAAGugB,UAAU,CAAC,CAAC,CAAC;QACtB,IAAIrpB,IAAI,GAAG,IAAI;QACf,MAAOA,IAAI,CAAE;YACX,MAAMwpB,OAAO,GAAG7oB,OAAO,CAAConB,KAAK,CAACuB,EAAE,EAAEC,EAAE,CAAC;YACrC,IAAIC,OAAO,KAAK,CAAC,EAAE;gBACjBlX,OAAO,CAACE,IAAI,CAAC;oBAAC8W,EAAE;oBAAE3oB,OAAO,CAAC8mB,MAAM,CAAC5e,CAAC,EAAEC,EAAE,CAAC;iBAAC,CAAC;gBACzC,IAAImgB,OAAO,CAACd,SAAS,EAAEe,SAAS,CAAC,IAAID,OAAO,CAACX,UAAU,EAAEa,UAAU,CAAC,EAAE;oBACpED,SAAS,GAAGA,SAAS,GAAG,CAAC;oBACzBC,UAAU,GAAGA,UAAU,GAAG,CAAC;oBAC3BC,SAAS,2JAAGp1B,OAAAA,AAAI,EAACm0B,SAAS,uJAAEj1B,KAAK,CAAC8gB,MAAAA,AAAS,EAACkV,SAAS,CAAC,CAAC;oBACvDG,UAAU,2JAAGr1B,OAAAA,AAAI,EAACs0B,UAAU,sJAAEp1B,KAAK,CAAC8gB,OAAAA,AAAS,EAACmV,UAAU,CAAC,CAAC;oBAC1DG,EAAE,GAAGF,SAAS,CAAC,CAAC,CAAC;oBACjBvgB,CAAC,GAAGugB,SAAS,CAAC,CAAC,CAAC;oBAChBG,EAAE,GAAGF,UAAU,CAAC,CAAC,CAAC;oBAClBvgB,EAAE,GAAGugB,UAAU,CAAC,CAAC,CAAC;gBACpB,CAAC,MAAM,IAAIJ,OAAO,CAACd,SAAS,EAAEe,SAAS,CAAC,EAAE;oBACxCzf,KAAK,oLAAGzT,WAAW,CAAC8yB,AAAS,0JAAC90B,OAAAA,AAAI,EAACm0B,SAAS,uJAAEj1B,KAAK,CAAC2Z,CAAAA,AAAI,EAACqc,SAAS,GAAG,CAAC,CAAC,CAAC,CAAC;oBACzElpB,IAAI,GAAG,KAAK;gBACd,CAAC,MAAM,IAAIipB,OAAO,CAACX,UAAU,EAAEa,UAAU,CAAC,EAAE;oBAC1C1f,KAAK,OAAGzT,WAAW,CAAC6yB,4KAAQ,AAARA,0JAAS70B,OAAAA,AAAI,EAACs0B,UAAU,uJAAEp1B,KAAK,CAAC2Z,CAAAA,AAAI,EAACsc,UAAU,GAAG,CAAC,CAAC,CAAC,CAAC;oBAC1EnpB,IAAI,GAAG,KAAK;gBACd,CAAC,MAAM;oBACLyJ,KAAK,gLAAGzT,WAAW,AAAS,CAAR4yB;oBACpB5oB,IAAI,GAAG,KAAK;gBACd;YACF,CAAC,MAAM,IAAIwpB,OAAO,GAAG,CAAC,EAAE;gBACtBlX,OAAO,CAACE,IAAI,CAAC;oBAAC8W,EAAE;oBAAE3oB,OAAO,CAACoW,MAAM,CAAClO,CAAC,CAAC;iBAAC,CAAC;gBACrC,IAAIogB,OAAO,CAACd,SAAS,EAAEe,SAAS,CAAC,EAAE;oBACjCA,SAAS,GAAGA,SAAS,GAAG,CAAC;oBACzBE,SAAS,2JAAGp1B,OAAAA,AAAI,EAACm0B,SAAS,MAAEj1B,KAAK,CAAC8gB,uJAAAA,AAAS,EAACkV,SAAS,CAAC,CAAC;oBACvDI,EAAE,GAAGF,SAAS,CAAC,CAAC,CAAC;oBACjBvgB,CAAC,GAAGugB,SAAS,CAAC,CAAC,CAAC;gBAClB,CAAC,MAAM;oBACL,MAAMK,YAAY,GAA4B,EAAE;oBAChDA,YAAY,CAACjX,IAAI,CAAC6W,UAAU,CAAC;oBAC7B,MAAOJ,OAAO,CAACX,UAAU,EAAEa,UAAU,CAAC,CAAE;wBACtCA,UAAU,GAAGA,UAAU,GAAG,CAAC;wBAC3BE,UAAU,2JAAGr1B,OAAAA,AAAI,EAACs0B,UAAU,GAAEp1B,KAAK,CAAC8gB,0JAAS,AAATA,EAAUmV,UAAU,CAAC,CAAC;wBAC1DM,YAAY,CAACjX,IAAI,CAAC6W,UAAU,CAAC;oBAC/B;oBACA5f,KAAK,oLAAGzT,WAAoB,AAAR6yB,AAAD,CAACA,CAAS31B,KAAK,CAACmO,iKAAAA,AAAe,EAACooB,YAAY,CAAC,CAAC;oBACjEzpB,IAAI,GAAG,KAAK;gBACd;YACF,CAAC,MAAM;gBACLsS,OAAO,CAACE,IAAI,CAAC;oBAAC+W,EAAE;oBAAE5oB,OAAO,CAACqW,OAAO,CAAClO,EAAE,CAAC;iBAAC,CAAC;gBACvC,IAAImgB,OAAO,CAACX,UAAU,EAAEa,UAAU,CAAC,EAAE;oBACnCA,UAAU,GAAGA,UAAU,GAAG,CAAC;oBAC3BE,UAAU,2JAAGr1B,OAAAA,AAAI,EAACs0B,UAAU,GAAEp1B,KAAK,CAAC8gB,0JAAAA,AAAS,EAACmV,UAAU,CAAC,CAAC;oBAC1DI,EAAE,GAAGF,UAAU,CAAC,CAAC,CAAC;oBAClBvgB,EAAE,GAAGugB,UAAU,CAAC,CAAC,CAAC;gBACpB,CAAC,MAAM;oBACL,MAAMK,WAAW,GAA2B,EAAE;oBAC9CA,WAAW,CAAClX,IAAI,CAAC4W,SAAS,CAAC;oBAC3B,MAAOH,OAAO,CAACd,SAAS,EAAEe,SAAS,CAAC,CAAE;wBACpCA,SAAS,GAAGA,SAAS,GAAG,CAAC;wBACzBE,SAAS,OAAGp1B,2JAAI,AAAJA,EAAKm0B,SAAS,uJAAEj1B,KAAK,CAAC8gB,MAAAA,AAAS,EAACkV,SAAS,CAAC,CAAC;wBACvDQ,WAAW,CAAClX,IAAI,CAAC4W,SAAS,CAAC;oBAC7B;oBACA3f,KAAK,oLAAGzT,WAAW,CAAC8yB,AAAS,EAAC51B,KAAK,CAACmO,iKAAAA,AAAe,EAACqoB,WAAW,CAAC,CAAC;oBACjE1pB,IAAI,GAAG,KAAK;gBACd;YACF;QACF;QACA,OAAO;iKAAC9M,KAAK,CAACmO,YAAAA,AAAe,EAACiR,OAAO,CAAC;YAAE7I,KAAM;SAAC;IACjD,CAAC;IACD,OAAOpB,aAAa,CAAChR,IAAI,EAAEsJ,OAAO,CAAC2W,KAAK,+KAAEthB,WAAW,AAAS,CAAR4yB,CAAU9yB,IAAI,CAAC;AACvE,CAAC,CACF;AAGM,MAAMwxB,UAAU,GAAA,WAAA,2JAAGxzB,OAAAA,AAAI,EAmB5B,CAAC,EACD,CACEuD,IAA4B,EAC5BsJ,OAKC,KACoC;IACrC,MAAM7K,IAAI,GAAGA,CACX2T,KAAqC,EACrCvB,QAA4D,EAC5DC,SAAgE,KAK9D;QACF,OAAQsB,KAAK,CAACnO,IAAI;YAChB,kLAAKtF,WAAW,CAACkyB,IAAa;gBAAE;oBAC9B,6JAAO30B,MAAM,CAACspB,OAAAA,AAAW,EAAC3U,QAAQ,EAAE;wBAClCjQ,SAAS,EAAGkI,KAAK,QAAK5M,MAAM,CAAC2H,qJAAO,AAAPA,sJAAQxH,IAAI,CAACwE,EAAAA,AAAI,EAACiI,KAAK,CAAC,CAAC;wBACtDhC,SAAS,GAAGgqB,SAAS,GACnB50B,MAAM,CAAC2H,yJAAAA,AAAO,sJAACxH,IAAI,CAACwH,KAAO,AAAPA,EAClB;qLACEhI,KAAK,CAACkI,AAAG,EAAC+sB,SAAS,EAAExnB,OAAO,CAACoW,MAAM,CAAC;6MACpC/gB,WAAW,CAACoyB,AAAS;6BACb,CACX;qBACJ,CAAC;gBACJ;YACA,kLAAKpyB,WAAW,CAACqyB,KAAc;gBAAE;oBAC/B,6JAAO90B,MAAM,CAACspB,OAAAA,AAAW,EAAC1U,SAAS,EAAE;wBACnClQ,SAAS,GAAGkI,KAAK,GAAK5M,MAAM,CAAC2H,yJAAAA,AAAO,sJAACxH,IAAI,CAACwE,EAAAA,AAAI,EAACiI,KAAK,CAAC,CAAC;wBACtDhC,SAAS,GAAGmqB,UAAU,wJACpB/0B,MAAM,CAAC2H,IAAAA,AAAO,sJAACxH,IAAI,CAACwH,KAAAA,AAAO,EACzB;qLACEhI,KAAK,CAACkI,AAAG,EAACktB,UAAU,EAAE3nB,OAAO,CAACqW,OAAO,CAAC;gCACtChhB,WAAW,CAACuyB,8KAAU;6BACd,CACX;qBACJ,CAAC;gBACJ;YACA,kLAAKvyB,WAAW,CAACwyB,GAAY;gBAAE;oBAC7B,+JAAOx0B,OAAAA,AAAI,EACToT,MAAM,CAACc,QAAQ,CAAC,EAChB3U,MAAM,CAAC6hB,qJAAAA,AAAG,EAAChO,MAAM,CAACe,SAAS,CAAC,EAAE;wBAAEsgB,UAAU,EAAE;oBAAI,CAAE,CAAC,wJACnDl1B,MAAM,CAACspB,OAAAA,AAAW,EAAC;wBACjB5kB,SAAS,GAAGkI,KAAK,yJAAK5M,MAAM,CAAC2H,GAAO,AAAPA,sJAAQxH,IAAI,CAACwE,EAAAA,AAAI,wJAAC9D,MAAM,CAACmF,AAAI,EAAC4G,KAAK,CAAC,CAAC,CAAC;wBACnEhC,SAAS,EAAEA,CAAC,CAACuqB,UAAU,EAAEC,WAAW,CAAC,KAAI;4BACvC,IAAIv0B,MAAM,CAAC0S,wJAAAA,AAAM,EAAC4hB,UAAU,CAAC,0JAAIt0B,MAAM,CAAC0S,EAAM,AAANA,EAAO6hB,WAAW,CAAC,EAAE;gCAC3D,wJAAIz1B,KAAK,CAACia,KAAAA,AAAO,EAACub,UAAU,CAACpqB,KAAK,CAAC,yJAAIpL,KAAK,CAACia,IAAAA,AAAO,EAACwb,WAAW,CAACrqB,KAAK,CAAC,EAAE;oCACvE,OAAOxI,IAAI,CAACE,WAAW,CAAC4yB,4KAAQ,EAAE1gB,QAAQ,EAAEC,SAAS,CAAC;gCACxD;gCACA,yJAAIjV,KAAK,CAACia,IAAAA,AAAO,EAACub,UAAU,CAACpqB,KAAK,CAAC,EAAE;oCACnC,OAAOxI,IAAI,kLAACE,WAAW,AAAC6yB,AAAQ,CAARA,CAASF,WAAW,CAACrqB,KAAK,CAAC,EAAE4J,QAAQ,EAAEC,SAAS,CAAC;gCAC3E;gCACA,yJAAIjV,KAAK,CAACia,IAAAA,AAAO,EAACwb,WAAW,CAACrqB,KAAK,CAAC,EAAE;oCACpC,OAAOxI,IAAI,kLAACE,WAAW,CAAU,AAAT8yB,EAAUJ,UAAU,CAACpqB,KAAK,CAAC,EAAE4J,QAAQ,EAAEC,SAAS,CAAC;gCAC3E;gCACA,6JAAO5U,MAAM,CAAC2H,GAAAA,AAAO,sJAACxH,IAAI,CAACwH,KAAAA,AAAO,EAACka,GAAG,CAACsT,UAAU,CAACpqB,KAAK,EAAEqqB,WAAW,CAACrqB,KAAK,EAAEqC,OAAO,CAAC8mB,MAAM,CAAC,CAAC,CAAC;4BAC/F;4BACA,0JAAIrzB,MAAM,CAAC0S,EAAAA,AAAM,EAAC4hB,UAAU,CAAC,yJAAIt0B,MAAM,CAACgtB,GAAM,AAANA,EAAOuH,WAAW,CAAC,EAAE;gCAC3D,6JAAOp1B,MAAM,CAAC2H,GAAAA,AAAO,GAACxH,IAAI,CAACwH,wJAAAA,AAAO,EAChC;yLACEhI,KAAK,CAACkI,AAAG,EAACstB,UAAU,CAACpqB,KAAK,EAAEqC,OAAO,CAACoW,MAAM,CAAC;iNAC3C/gB,WAAW,CAACoyB,AAAS;iCACb,CACX,CAAC;4BACJ;4BACA,IAAIh0B,MAAM,CAACgtB,wJAAAA,AAAM,EAACsH,UAAU,CAAC,0JAAIt0B,MAAM,CAAC0S,EAAAA,AAAM,EAAC6hB,WAAW,CAAC,EAAE;gCAC3D,6JAAOp1B,MAAM,CAAC2H,GAAAA,AAAO,sJAACxH,IAAI,CAACwH,KAAAA,AAAO,EAChC;qCACEhI,KAAK,CAACkI,oJAAAA,AAAG,EAACutB,WAAW,CAACrqB,KAAK,EAAEqC,OAAO,CAACqW,OAAO,CAAC;iNAC7ChhB,WAAW,CAACuyB,CAAU;iCACd,CACX,CAAC;4BACJ;4BACA,6JAAOh1B,MAAM,CAAC2H,GAAAA,AAAO,MAACxH,IAAI,CAACwE,kJAAAA,AAAI,wJAAwB9D,MAAM,CAACiF,AAAI,EAAE,CAAC,CAAC;wBACxE;qBACD,CAAC,CACH;gBACH;YACA,kLAAKrD,WAAW,CAAC+yB,GAAY;gBAAE;oBAC7B,6JAAOx1B,MAAM,CAACspB,OAAAA,AAAW,EAAC3U,QAAQ,EAAE;wBAClCjQ,SAAS,GAAE7D,MAAM,CAAC+E,sJAAAA,AAAK,EAAC;4BACtB+D,MAAM,EAAEA,CAAA,yJACN3J,MAAM,CAAC2H,GAAAA,AAAO,sJAACxH,IAAI,CAACwH,KAAAA,AAAO,EACzB;oCACEhI,KAAK,CAACkI,qJAAG,AAAHA,EAAIqO,KAAK,CAAC6e,UAAU,EAAE3nB,OAAO,CAACqW,OAAO,CAAC;iNAC5ChhB,WAAW,CAACuyB,CAAU;iCACd,CACX,CAAC;4BACJlrB,MAAM,GAAG8C,KAAK,yJACZ5M,MAAM,CAAC2H,GAAAA,AAAO,EAGZxH,IAAI,CAACwE,sJAAI,AAAJA,MAAK9D,MAAM,CAACmF,kJAAI,AAAJA,EAAK4G,KAAK,CAAC,CAAC;yBAElC,CAAC;wBACFhC,SAAS,GAAGgqB,SAAS,IAAI;4BACvB,yJAAIj1B,KAAK,CAACia,IAAAA,AAAO,EAACgb,SAAS,CAAC,EAAE;gCAC5B,OAAOryB,IAAI,CAACE,WAAW,CAAC6yB,gLAAAA,AAAQ,EAACpf,KAAK,CAAC6e,UAAU,CAAC,EAAEpgB,QAAQ,EAAEC,SAAS,CAAC;4BAC1E;4BACA,yJAAIjV,KAAK,CAACia,IAAAA,AAAO,EAAC1D,KAAK,CAAC6e,UAAU,CAAC,EAAE;gCACnC,OAAOxyB,IAAI,kLAACE,WAAW,CAAC8yB,AAAS,EAACX,SAAS,CAAC,EAAEjgB,QAAQ,EAAEC,SAAS,CAAC;4BACpE;4BACA,6JAAO5U,MAAM,CAAC2H,GAAAA,AAAO,sJAACxH,IAAI,CAACwH,KAAAA,AAAO,EAACka,GAAG,CAAC+S,SAAS,EAAE1e,KAAK,CAAC6e,UAAU,EAAE3nB,OAAO,CAAC8mB,MAAM,CAAC,CAAC,CAAC;wBACvF;qBACD,CAAC;gBACJ;YACA,kLAAKzxB,WAAW,CAACgzB,IAAa;gBAAE;oBAC9B,6JAAOz1B,MAAM,CAACspB,OAAAA,AAAW,EAAC1U,SAAS,EAAE;wBACnClQ,SAAS,wJAAE7D,MAAM,CAAC+E,CAAAA,AAAK,EAAC;4BACtB+D,MAAM,EAAEA,CAAA,yJACN3J,MAAM,CAAC2H,GAAAA,AAAO,sJACZxH,IAAI,CAACwH,KAAAA,AAAO,EACV;yLACEhI,KAAK,CAACkI,AAAG,EAACqO,KAAK,CAAC0e,SAAS,EAAExnB,OAAO,CAACoW,MAAM,CAAC;iNAC1C/gB,WAAW,CAAU,AAAToyB;iCACJ,CACX,CACF;4BACH/qB,MAAM,GAAG8C,KAAK,yJACZ5M,MAAM,CAAC2H,GAAAA,AAAO,sJAGZxH,IAAI,CAACwE,EAAAA,AAAI,uJAAC9D,MAAM,CAACmF,CAAAA,AAAI,EAAC4G,KAAK,CAAC,CAAC;yBAElC,CAAC;wBACFhC,SAAS,GAAGmqB,UAAU,IAAI;4BACxB,yJAAIp1B,KAAK,CAACia,IAAAA,AAAO,EAACmb,UAAU,CAAC,EAAE;gCAC7B,OAAOxyB,IAAI,kLACTE,WAAW,CAAC8yB,AAAS,EAACrf,KAAK,CAAC0e,SAAS,CAAC,EACtCjgB,QAAQ,EACRC,SAAS,CACV;4BACH;4BACA,yJAAIjV,KAAK,CAACia,IAAO,AAAPA,EAAQ1D,KAAK,CAAC0e,SAAS,CAAC,EAAE;gCAClC,OAAOryB,IAAI,kLACTE,WAAW,AAAC6yB,AAAQ,CAARA,CAASP,UAAU,CAAC,EAChCpgB,QAAQ,EACRC,SAAS,CACV;4BACH;4BACA,6JAAO5U,MAAM,CAAC2H,GAAO,AAAPA,sJAAQxH,IAAI,CAACwH,KAAAA,AAAO,EAACka,GAAG,CAAC3L,KAAK,CAAC0e,SAAS,EAAEG,UAAU,EAAE3nB,OAAO,CAAC8mB,MAAM,CAAC,CAAC,CAAC;wBACvF;qBACD,CAAC;gBACJ;QACF;IACF,CAAC;IACD,MAAMrS,GAAG,GAAGA,CACV+S,SAAyB,EACzBG,UAA2B,EAC3BzmB,CAAuB,KACuC;QAC9D,MAAM,CAAC1C,MAAM,EAAE4O,MAAM,CAAC,GAAG4b,SAAS,CAACxB,SAAS,EAAEG,UAAU,EAAEzmB,CAAC,CAAC;QAC5D,OAAQkM,MAAM,CAACzS,IAAI;YACjB,KAAK,MAAM;gBAAE;oBACX,KAAIpI,KAAK,CAACia,wJAAAA,AAAO,EAACY,MAAM,CAACzQ,IAAI,CAAC,EAAE;wBAC9B,OAAO;4BAAC6B,MAAM;yMAAEnJ,WAAW,AAAS,CAAR4yB;yBAAkB;oBAChD;oBACA,OAAO;wBAACzpB,MAAM;yMAAEnJ,WAAW,CAAU,AAAT8yB,EAAU/a,MAAM,CAACzQ,IAAI,CAAC;qBAAU;gBAC9D;YACA,KAAK,OAAO;gBAAE;oBACZ,yJAAIpK,KAAK,CAACia,IAAAA,AAAO,EAACY,MAAM,CAAC3Q,KAAK,CAAC,EAAE;wBAC/B,OAAO;4BAAC+B,MAAM;yMAAEnJ,WAAW,AAAS,CAAR4yB;yBAAkB;oBAChD;oBACA,OAAO;wBAACzpB,MAAM;yMAAEnJ,WAAW,AAAC6yB,AAAQ,CAARA,CAAS9a,MAAM,CAAC3Q,KAAK,CAAC;qBAAU;gBAC9D;QACF;IACF,CAAC;IACD,OAAOiL,aAAa,CAAChR,IAAI,EAAEsJ,OAAO,CAAC2W,KAAK,+KAAEthB,WAAW,AAAS,CAAR4yB,CAAU9yB,IAAI,CAAC;AACvE,CAAC,CACF;AAGM,MAAM8zB,SAAS,GAAA,WAAA,2JAQlB91B,OAAI,AAAJA,EACF,CAAC,EACD,CACEwJ,IAA+B,EAC/BF,KAAgC,GACcpJ,+JAAAA,AAAI,EAACsJ,IAAI,EAAEusB,aAAa,CAACzsB,KAAK,EAAE,CAACyL,CAAC,EAAEC,EAAE,GAAK;YAACD,CAAC;YAAEC,EAAE;SAAC,CAAC,CAAC,CACrG;AAEM,MAAMghB,YAAY,GAAGA,CAC1B,GAAGphB,OAAU,KAMX;IACF,IAAIA,OAAO,CAACzG,MAAM,KAAK,CAAC,EAAE;QACxB,OAAO1J,KAAK;IACd,CAAC,MAAM,IAAImQ,OAAO,CAACzG,MAAM,KAAK,CAAC,EAAE;QAC/B,OAAO7G,GAAG,CAACsN,OAAO,CAAC,CAAC,CAAE,GAAGtC,CAAC,GAAK;gBAACA,CAAC;aAAC,CAAQ;IAC5C;IACA,MAAM,CAACmH,IAAI,EAAE,GAAGwc,IAAI,CAAC,GAAGrhB,OAAO;IAC/B,OAAOmhB,aAAa,CAClBtc,IAAI,EACJuc,YAAY,CAAC,GAAGC,IAAI,CAAC,EACrB,CAACC,KAAK,EAAEC,MAAM,GAAK;YAACD,KAAK,EAAE;eAAGC,MAAM;SAAC,CAC/B;AACV,CAAC;AAGM,MAAMJ,aAAa,GAAA,WAAA,2JAUtB/1B,OAAAA,AAAI,EACN,CAAC,EACD,CACEwJ,IAA+B,EAC/BF,KAAgC,EAChCyE,CAA6B,KACS;IACtC,MAAMqoB,YAAY,IAChBp0B,IAA2D,IAE3D9B,8JAAAA,AAAI,EAAC8B,IAAI,wJAAEvC,MAAM,CAACwE,GAAO,AAAPA,GAASqI,KAAK,wJAAKlN,KAAK,CAACia,IAAAA,AAAO,EAAC/M,KAAK,CAAC,GAAG8pB,YAAY,CAACp0B,IAAI,CAAC,GAAGvC,MAAM,CAAC2H,yJAAAA,AAAO,EAACkF,KAAK,CAAC,CAAC,CAAC;IAC1G,+JAAOpM,OAAI,AAAJA,EACL8vB,MAAM,CAACxmB,IAAI,CAAC,wJACZ/J,MAAM,AAAC6H,AAAG,CAAHA,CAAI8uB,YAAY,CAAC,wJACxB32B,MAAM,AAAC6hB,AAAG,CAAHA,yJAAIphB,OAAI,AAAJA,EAAK8vB,MAAM,CAAC1mB,KAAK,CAAC,uJAAE7J,MAAM,CAAC6H,AAAG,EAAC8uB,YAAY,CAAC,CAAC,CAAC,wJACzD32B,MAAM,CAACwE,GAAAA,AAAO,EAAC,CAAC,CAACuF,IAAI,EAAEF,KAAK,CAAC,2JAC3BpJ,OAAAA,AAAI,EACFwa,gBAAgB,KACdjb,MAAM,CAACiK,sJAAAA,AAAQ,EAACF,IAAI,EAAEF,KAAK,EAAE;YAC3BM,UAAU,EAAEA,CAAC2X,QAAQ,EAAE8U,UAAU,2JAC/Bn2B,OAAAA,AAAI,GACFT,MAAM,CAACsK,wJAAAA,AAAO,EAAC,IAAMwX,QAAQ,CAAC,wJAC9B9hB,MAAM,CAAC4zB,GAAAA,AAAO,sJAACxzB,KAAK,CAAC8J,EAAAA,AAAI,EAAC0sB,UAAU,CAAC,EAAE,CAACC,CAAC,EAAEtd,CAAC,GAAK;wBAACsd,CAAC;wBAAEtd,CAAC;wBAAE,IAAI;qBAAU,CAAC,CACxE;YACHhP,WAAW,EAAEA,CAACwX,SAAS,EAAE+U,SAAS,IAChCr2B,8JAAI,AAAJA,wJACET,MAAM,CAACsK,GAAAA,AAAO,EAAC,IAAMyX,SAAS,CAAC,wJAC/B/hB,MAAM,CAAC4zB,GAAAA,AAAO,uJAACxzB,KAAK,CAAC8J,CAAAA,AAAI,EAAC4sB,SAAS,CAAC,EAAE,CAACD,CAAC,EAAEtd,CAAC,GAAK;wBAACA,CAAC;wBAAEsd,CAAC;wBAAE,KAAK;qBAAU,CAAC;SAE5E,CAAC,CACH,EACDryB,OAAO,CAAC,CAAC,CAACqyB,CAAC,EAAEtd,CAAC,EAAEwd,SAAS,CAAC,GACxBt2B,+JAAI,AAAJA,EACE6F,UAAU,oJACRnF,GAAG,CAACgF,GAAAA,AAAI,EAAC;oKAACxG,KAAK,CAACq3B,QAAAA,AAAU,EAACH,CAAC,CAAC;qKAAEl3B,KAAK,CAACq3B,OAAAA,AAAU,EAACzd,CAAC,CAAC;aAAU,CAAC,CAC9D,EACD/U,OAAO,CAAEyyB,MAAM,IACbx2B,+JAAI,AAAJA,EACEyd,SAAS,CACP6Y,SAAS,2JACPt2B,OAAAA,AAAI,EAAC8Y,CAAC,sJAAE5Z,KAAK,CAACkI,CAAAA,AAAG,GAAE0N,EAAE,GAAKjH,CAAC,sJAAC3O,KAAK,CAACq3B,OAAU,AAAVA,EAAWH,CAAC,CAAC,EAAEthB,EAAE,CAAC,CAAC,CAAC,OACtD9U,2JAAAA,AAAI,EAACo2B,CAAC,uJAAEl3B,KAAK,CAACkI,AAAG,GAAEyN,CAAC,GAAKhH,CAAC,CAACgH,CAAC,uJAAE3V,KAAK,CAACq3B,OAAAA,AAAU,EAACzd,CAAC,CAAC,CAAC,CAAC,CAAC,CACvD,EACDtE,MAAM,EACJxU,8JAAI,AAAJA,EACEkd,kBAAkB,CAAC5T,IAAI,CAAC,EACxB6Z,WAAW,CAACjG,kBAAkB,CAAC9T,KAAK,CAAC,CAAC,EACtCiR,mBAAmB,uJAAC7a,MAAM,CAAC2F,CAAK,AAALA,EAAM;oBAC/BC,MAAM,GAAG+uB,SAAS,2JAChBn0B,OAAAA,AAAI,oJACFU,GAAG,CAAC+1B,MAAAA,AAAM,EAACD,MAAM,EAAE,CAAC,CAAC9zB,CAAC,EAAEg0B,WAAW,CAAC,GAClC;wLACE12B,OAAAA,AAAI,EAACm0B,SAAS,uJAAEj1B,KAAK,CAAI,AAAHkI,GAAKyN,CAAC,GAAKhH,CAAC,CAACgH,CAAC,EAAE6hB,WAAW,CAAC,CAAC,CAAC;gCACpD;yLAACx3B,KAAK,CAACq3B,OAAAA,AAAU,EAACpC,SAAS,CAAC;oCAAEuC,WAAW;iCAAU;6BAC3C,CAAC,CACd;oBACHpxB,OAAO,GAAGgvB,UAAU,OAClBt0B,2JAAAA,AAAI,qJACFU,GAAG,CAAC+1B,KAAAA,AAAM,EAACD,MAAM,EAAE,CAAC,CAACG,UAAU,EAAEj0B,CAAC,CAAC,GACjC;gCACE1C,+JAAAA,AAAI,EAACs0B,UAAU,uJAAEp1B,KAAK,CAACkI,AAAG,GAAE0N,EAAE,GAAKjH,CAAC,CAAC8oB,UAAU,EAAE7hB,EAAE,CAAC,CAAC,CAAC;gCACtD;oCAAC6hB,UAAU;yLAAEz3B,KAAK,CAACq3B,OAAAA,AAAU,EAACjC,UAAU,CAAC;iCAAU;6BAC3C,CAAC;iBAElB,CAAC,CAAC,EACHvwB,OAAO,CAAC0Z,SAAS,CAAC,CACnB,CACF,CACF,CACF,CACF,CACF,EACDqS,MAAM,CACP,CACF,EACDrkB,QAAQ,CACT;AACH,CAAC,CACF;AAGM,MAAM0gB,OAAO,GAAA,WAAA,2JAQhBrsB,OAAAA,AAAI,EACN,CAAC,EACD,CACEwJ,IAA+B,EAC/BF,KAAgC,OAEhCpJ,2JAAAA,AAAI,EACFsJ,IAAI,EACJstB,aAAa,CAACxtB,KAAK,EAAE,CAACE,IAAI,EAAEF,KAAK,KAAI;QACnC,IAAIE,IAAI,CAAC2E,MAAM,GAAG7E,KAAK,CAAC6E,MAAM,EAAE;YAC9B,OAAO;wKACLjO,OAAI,AAAJA,EAAKsJ,IAAI,uJAAEpK,KAAK,CAACiI,CAAAA,AAAI,EAACiC,KAAK,CAAC6E,MAAM,CAAC,CAAC;gBACpCzO,MAAM,CAAC8J,sJAAAA,AAAI,0JAACtJ,OAAAA,AAAI,EAACsJ,IAAI,uJAAEpK,KAAK,CAACiI,CAAAA,AAAI,EAACiC,KAAK,CAAC6E,MAAM,CAAC,CAAC,CAAC;aACzC;QACZ;QACA,OAAO;YACL3E,IAAI;kKACJ9J,MAAM,CAAC4J,CAAAA,AAAK,0JAACpJ,OAAAA,AAAI,EAACoJ,KAAK,EAAElK,KAAK,CAAC2Z,sJAAAA,AAAI,EAACvP,IAAI,CAAC2E,MAAM,CAAC,CAAC,CAAC;SACnD;IACH,CAAC,CAAC,CACH,CACJ;AAGM,MAAMhH,QAAQ,GAAA,WAAA,0JAQjBnH,QAAAA,AAAI,EACN,CAAC,EACD,CACEwJ,IAA+B,EAC/BF,KAAgC,2JAEhCpJ,OAAAA,AAAI,EACFsJ,IAAI,EACJstB,aAAa,CAACxtB,KAAK,EAAE,CAACE,IAAI,EAAEF,KAAK,KAAI;QACnC,IAAIE,IAAI,CAAC2E,MAAM,GAAG7E,KAAK,CAAC6E,MAAM,EAAE;YAC9B,OAAO;gBACL7E,KAAK;qKACL5J,MAAM,CAAC8J,CAAAA,AAAI,0JAACtJ,OAAAA,AAAI,EAACsJ,IAAI,uJAAEpK,KAAK,CAACiI,CAAAA,AAAI,EAACiC,KAAK,CAAC6E,MAAM,CAAC,CAAC,CAAC;aACzC;QACZ;QACA,OAAO;oKACLjO,OAAAA,AAAI,EAACoJ,KAAK,uJAAElK,KAAK,CAACiI,CAAAA,AAAI,EAACmC,IAAI,CAAC2E,MAAM,CAAC,CAAC;aACpCzO,MAAM,CAAC4J,sJAAAA,AAAK,0JAACpJ,OAAAA,AAAI,EAACoJ,KAAK,uJAAElK,KAAK,CAAC2Z,CAAAA,AAAI,EAACvP,IAAI,CAAC2E,MAAM,CAAC,CAAC,CAAC;SACnD;IACH,CAAC,CAAC,CACH,CACJ;AAGM,MAAMklB,OAAO,GAAA,WAAA,OAUhBrzB,2JAAI,AAAJA,EACF,CAAC,EACD,CACEwJ,IAA+B,EAC/BF,KAAgC,EAChCyE,CAA6B,2JAE7B7N,OAAAA,AAAI,EAACsJ,IAAI,EAAEstB,aAAa,CAACxtB,KAAK,EAAE,CAAC+qB,SAAS,EAAEG,UAAU,GAAKqB,SAAS,CAACxB,SAAS,EAAEG,UAAU,EAAEzmB,CAAC,CAAC,CAAC,CAAC,CACnG;AAGM,MAAM+oB,aAAa,GAAA,WAAA,2JAAG92B,OAAAA,AAAI,EAgB/B,CAAC,EAAE,CACHuD,IAA4B,EAC5BqQ,IAA+B,EAC/B7F,CAG+E,KAC1C;IACrC,MAAM/L,IAAI,GAAGA,CACX2T,KAA2C,EAC3CvB,QAA4D,EAC5DC,SAAgE,KAK9D;QACF,OAAQsB,KAAK,CAACnO,IAAI;YAChB,KAAKrF,cAAc,CAACuyB,gLAAY;gBAAE;oBAChC,+JAAOx0B,OAAAA,AAAI,EACToT,MAAM,CAACc,QAAQ,CAAC,uJAChB3U,MAAM,CAAI,AAAH6hB,EAAIhO,MAAM,CAACe,SAAS,CAAC,EAAE;wBAAEsgB,UAAU,EAAE;oBAAI,CAAE,CAAC,wJACnDl1B,MAAM,CAACspB,OAAW,AAAXA,EAAY;wBACjB5kB,SAAS,EAAGkI,KAAK,0JAAK5M,MAAM,CAAC2H,GAAAA,AAAO,sJAACxH,IAAI,CAACwE,EAAAA,AAAI,wJAAC9D,MAAM,CAACmF,AAAI,EAAC4G,KAAK,CAAC,CAAC,CAAC;wBACnEhC,SAAS,EAAEA,CAAC,CAACuqB,UAAU,EAAEC,WAAW,CAAC,KAAI;4BACvC,0JAAIv0B,MAAM,CAAC0S,EAAAA,AAAM,EAAC4hB,UAAU,CAAC,0JAAIt0B,MAAM,CAAC0S,EAAAA,AAAM,EAAC6hB,WAAW,CAAC,EAAE;gCAC3D,yJAAIz1B,KAAK,CAACia,IAAAA,AAAO,EAACub,UAAU,CAACpqB,KAAK,CAAC,IAAIpL,KAAK,CAACia,yJAAAA,AAAO,EAACwb,WAAW,CAACrqB,KAAK,CAAC,EAAE;oCACvE,OAAOxI,IAAI,iLAACG,WAAuB,EAAEiS,CAAX,CAAC0gB,MAAkB,EAAEzgB,SAAS,CAAC;gCAC3D;gCACA,yJAAIjV,KAAK,CAACia,IAAO,AAAPA,EAAQub,UAAU,CAACpqB,KAAK,CAAC,EAAE;oCACnC,OAAOxI,IAAI,qLAACG,WAAe4yB,AAAQ,EAACF,CAAV,CAACE,SAAoB,CAACvqB,KAAK,CAAC,EAAE4J,QAAQ,EAAEC,SAAS,CAAC;gCAC9E;gCACA,yJAAIjV,KAAK,CAACia,IAAO,AAAPA,EAAQwb,WAAW,CAACrqB,KAAK,CAAC,EAAE;oCACpC,OAAOxI,IAAI,qLAACG,YAAe6yB,AAAS,EAAV,AAAWJ,CAAVI,SAAoB,CAACxqB,KAAK,CAAC,EAAE4J,QAAQ,EAAEC,SAAS,CAAC;gCAC9E;gCACA,6JAAO5U,MAAM,CAAC2H,GAAO,AAAPA,GAAQxH,IAAI,CAACwH,wJAAAA,AAAO,EAACka,GAAG,CAACsT,UAAU,CAACpqB,KAAK,EAAEqqB,WAAW,CAACrqB,KAAK,CAAC,CAAC,CAAC;4BAC/E;4BACA,6JAAO/K,MAAM,CAAC2H,GAAAA,AAAO,sJAACxH,IAAI,CAACwE,EAAI,AAAJA,EAAK9D,MAAM,CAACiF,sJAAAA,AAAI,EAAE,CAAC,CAAC;wBACjD;qBACD,CAAC,CACH;gBACH;YACA,qLAAKpD,cAAc,CAAC8yB,AAAY;gBAAE;oBAChC,6JAAOx1B,MAAM,CAACspB,OAAAA,AAAW,EAAC3U,QAAQ,EAAE;wBAClCjQ,SAAS,GAAGkI,KAAK,OAAK5M,MAAM,CAAC2H,qJAAAA,AAAO,sJAACxH,IAAI,CAACwE,EAAI,AAAJA,EAAKiI,KAAK,CAAC,CAAC;wBACtDhC,SAAS,GAAGgqB,SAAS,IAAI;4BACvB,IAAIj1B,KAAK,CAACia,yJAAAA,AAAO,EAACgb,SAAS,CAAC,EAAE;gCAC5B,OAAOryB,IAAI,qLAACG,WAAe4yB,AAAQ,EAACpf,CAAV,CAACof,GAAc,CAACP,UAAU,CAAC,EAAEpgB,QAAQ,EAAEC,SAAS,CAAC;4BAC7E;4BACA,wJAAIjV,KAAK,CAACia,KAAAA,AAAO,EAAC1D,KAAK,CAAC6e,UAAU,CAAC,EAAE;gCACnC,OAAOxyB,IAAI,qLAACG,YAAe6yB,AAAS,EAAV,AAAWX,CAAVW,QAAmB,CAAC,EAAE5gB,QAAQ,EAAEC,SAAS,CAAC;4BACvE;4BACA,6JAAO5U,MAAM,CAAC2H,GAAAA,AAAO,sJAACxH,IAAI,CAACwH,KAAO,AAAPA,EAAQka,GAAG,CAAC+S,SAAS,EAAE1e,KAAK,CAAC6e,UAAU,CAAC,CAAC,CAAC;wBACvE;qBACD,CAAC;gBACJ;YACA,qLAAKryB,cAAc,CAAC+yB,CAAa;gBAAE;oBACjC,6JAAOz1B,MAAM,CAACspB,OAAAA,AAAW,EAAC1U,SAAS,EAAE;wBACnClQ,SAAS,GAAGkI,KAAK,wJAAK5M,MAAM,CAAC2H,IAAAA,AAAO,sJAACxH,IAAI,CAACwE,EAAAA,AAAI,EAACiI,KAAK,CAAC,CAAC;wBACtDhC,SAAS,GAAGmqB,UAAU,IAAI;4BACxB,QAAIp1B,KAAK,CAACia,qJAAAA,AAAO,EAACmb,UAAU,CAAC,EAAE;gCAC7B,OAAOxyB,IAAI,qLAACG,YAAe6yB,AAAS,EAAV,AAAWrf,CAAVqf,IAAe,CAACX,SAAS,CAAC,EAAEjgB,QAAQ,EAAEC,SAAS,CAAC;4BAC7E;4BACA,yJAAIjV,KAAK,CAACia,IAAAA,AAAO,EAAC1D,KAAK,CAAC0e,SAAS,CAAC,EAAE;gCAClC,OAAOryB,IAAI,qLAACG,WAAe4yB,AAAQ,EAACP,CAAV,CAACO,QAAmB,CAAC,EAAE3gB,QAAQ,EAAEC,SAAS,CAAC;4BACvE;4BACA,QAAO5U,MAAM,CAAC2H,wJAAAA,AAAO,sJAACxH,IAAI,CAACwH,KAAAA,AAAO,EAACka,GAAG,CAAC3L,KAAK,CAAC0e,SAAS,EAAEG,UAAU,CAAC,CAAC,CAAC;wBACvE;qBACD,CAAC;gBACJ;QACF;IACF,CAAC;IACD,MAAMlT,GAAG,GAAGA,CACV+S,SAAyB,EACzBG,UAA2B,KACyC;QACpE,MAAM,CAACnpB,MAAM,EAAE4O,MAAM,CAAC,GAAGlM,CAAC,CAACsmB,SAAS,EAAEG,UAAU,CAAC;QACjD,OAAQva,MAAM,CAACzS,IAAI;YACjB,KAAK,MAAM;gBAAE;oBACX,yJAAIpI,KAAK,CAACia,IAAO,AAAPA,EAAQY,MAAM,CAACzQ,IAAI,CAAC,EAAE;wBAC9B,OAAO;4BAAC6B,MAAM;2MAAElJ,YAAuB,EAAT,CAAC2yB;yBAAkB;oBACnD;oBACA,OAAO;wBAACzpB,MAAM;4MAAElJ,YAAe6yB,AAAS,EAAV,AAAW/a,CAAV+a,KAAgB,CAACxrB,IAAI,CAAC;qBAAU;gBACjE;YACA,KAAK,OAAO;gBAAE;oBACZ,yJAAIpK,KAAK,CAACia,IAAO,AAAPA,EAAQY,MAAM,CAAC3Q,KAAK,CAAC,EAAE;wBAC/B,OAAO;4BAAC+B,MAAM;4MAAElJ,WAAuB,GAAT,CAAC2yB;yBAAkB;oBACnD;oBACA,OAAO;wBAACzpB,MAAM;wBAAElJ,cAAc,CAAC4yB,gLAAAA,AAAQ,EAAC9a,MAAM,CAAC3Q,KAAK,CAAC;qBAAU;gBACjE;QACF;IACF,CAAC;IACD,+JAAOpJ,OAAI,AAAJA,EACLqD,IAAI,EACJgR,aAAa,CAACX,IAAI,iLAAEzR,YAAuB,EAAT,AAAWH,CAAV8yB,GAAc,CAAC,CACnD;AACH,CAAC,CAAC;AAGK,MAAMiC,YAAY,IAAaxzB,IAA4B,2JAChErD,OAAAA,AAAI,EAACqD,IAAI,EAAE4e,QAAQ,CAAC,CAAC,EAAE,CAAC6E,KAAK,EAAEjS,CAAC,GAAK;YAACiS,KAAK,GAAG,CAAC;YAAE;gBAACjS,CAAC;gBAAEiS,KAAK;aAAC;SAAC,CAAC,CAAC;AAGzD,MAAMgQ,WAAW,IACtBzzB,IAA4B,IACkB;IAC9C,MAAM8M,OAAO,IACXqC,IAAsB,4KAEtBpR,IAAI,CAACiF,YAAAA,AAAa,EAAC;YACjB1C,OAAO,GAAGC,KAAqB,IAAI;gBACjC,MAAM,CAAC6O,OAAO,EAAErG,KAAK,CAAC,OAAGlN,KAAK,CAAC+iB,sJAAAA,AAAQ,EACrCre,KAAK,EACL4O,IAAI,EACJ,CAACukB,IAAI,EAAEC,IAAI,GAAK;8KAAC52B,MAAM,CAACmF,AAAI,EAACyxB,IAAI,CAAC;gLAAEh3B,OAAAA,AAAI,EAAC+2B,IAAI,EAAE32B,MAAM,CAACgH,qJAAAA,AAAG,GAAEyN,CAAC,GAAK;gCAACA,CAAC;gCAAEmiB,IAAI;6BAAU,CAAC,CAAC;qBAAU,CAChG;gBACD,MAAM7rB,MAAM,OAAGjM,KAAK,CAAC+F,uJAAAA,AAAS,EAC5BmH,KAAK,GACJwG,MAAM,yJACLxS,MAAM,CAAC0S,EAAAA,AAAM,EAACF,MAAM,CAAC,IACnBxS,MAAM,CAACmF,qJAAAA,AAAI,EAAC;wBAACqN,MAAM,CAACtI,KAAK,CAAC,CAAC,CAAC;8KAAElK,MAAM,CAAK,AAAJmF,EAAKqN,MAAM,CAACtI,KAAK,CAAC,CAAC,CAAC,CAAC;qBAAU,CAAC,yJACrElK,MAAM,CAACiF,AAAI,EAAE,CAClB;gBACD,OAAOjE,IAAI,CAAC2C,+KAAO,AAAPA,4KACV3C,IAAI,CAAC4C,GAAAA,AAAK,EAACmH,MAAM,CAAC,EAClB,IAAMgF,OAAO,CAACsC,OAAO,CAAC,CACvB;YACH,CAAC;YACDxO,SAAS,wKAAE7C,IAAI,CAACwG,OAAS;YACzBzD,MAAM,EAAEA,CAAA,IACN/D,MAAM,CAAC+E,sJAAAA,AAAK,EAACqN,IAAI,EAAE;oBACjBtJ,MAAM,EAAEA,CAAA,yKAAM9H,IAAI,CAACgD,EAAI;oBACvBiF,MAAM,GAAGiB,KAAK,sKACZrJ,OAAO,CAACgG,GAAAA,AAAQ,EACd7F,IAAI,CAAC4C,6KAAAA,AAAK,uJAAC9E,KAAK,AAACiK,AAAE,CAAFA,CAAmC;4BAACmB,KAAK;kLAAElK,MAAM,CAACiF,AAAI,EAAE;yBAAC,CAAC,CAAC,wKAC5EjE,IAAI,CAACgD,EAAI;iBAEd;SACJ,CAAC;IACJ,OAAO,IAAIvB,UAAU,CAAC7C,+JAAAA,AAAI,EAACsE,SAAS,CAACjB,IAAI,CAAC,qKAAEpC,OAAO,CAACuH,OAAAA,AAAY,EAAC2H,OAAO,uJAAC/P,MAAM,CAAK,AAAJiF,EAAM,CAAC,CAAC,CAAC,CAAC;AAC5F,CAAC;AAGM,MAAM4xB,eAAe,IAC1B5zB,IAA4B,2JAE5BrD,OAAAA,AAAI,EACFqD,IAAI,EACJ4e,QAAQ,sJACN7hB,MAAM,CAACiF,CAAAA,AAAI,EAAE,GACb,CAAC0xB,IAAI,EAAEC,IAAI,GAAK;kKAAC52B,MAAM,CAACmF,AAAI,EAACyxB,IAAI,CAAC;YAAE;gBAACD,IAAI;gBAAEC,IAAI;aAAC;SAAC,CAClD,CACF;AAGI,MAAME,sBAAsB,IACjC7zB,IAA4B,2JAE5BrD,OAAAA,AAAI,EACF82B,WAAW,CAACG,eAAe,CAAC5zB,IAAI,CAAC,CAAC,EAClC+D,GAAG,CAAC,CAAC,CAAC,CAAC2vB,IAAI,EAAEC,IAAI,CAAC,EAAEnzB,IAAI,CAAC,GAAK;YAACkzB,IAAI;YAAEC,IAAI;oKAAEh3B,OAAI,AAAJA,EAAK6D,IAAI,wJAAEzD,MAAM,AAACgH,AAAG,CAAHA,EAAKwH,KAAK,GAAKA,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;SAAC,CAAC,CACzF;AAEH,cAAA,GACA,MAAM+mB,SAAS,GAAGA,CAChBrsB,IAAoB,EACpBF,KAAqB,EACrByE,CAAoB,KAC+C;IACnE,IAAIvE,IAAI,CAAC2E,MAAM,GAAG7E,KAAK,CAAC6E,MAAM,EAAE;QAC9B,OAAO;oKACLjO,OAAAA,AAAI,EAACsJ,IAAI,EAAEpK,KAAK,CAACiI,sJAAAA,AAAI,EAACiC,KAAK,CAAC6E,MAAM,CAAC,uJAAE/O,KAAK,CAACi0B,IAAAA,AAAO,EAAC/pB,KAAK,EAAEyE,CAAC,CAAC,CAAC;kKAC7DrO,MAAM,CAAK,AAAJ8J,MAAKtJ,2JAAI,AAAJA,EAAKsJ,IAAI,uJAAEpK,KAAK,CAAC2Z,CAAAA,AAAI,EAACzP,KAAK,CAAC6E,MAAM,CAAC,CAAC,CAAC;SAClD;IACH;IACA,OAAO;gKACLjO,OAAAA,AAAI,EAACsJ,IAAI,GAAEpK,KAAK,CAACi0B,wJAAAA,AAAO,0JAACnzB,OAAAA,AAAI,EAACoJ,KAAK,uJAAElK,KAAK,CAACiI,CAAI,AAAJA,EAAKmC,IAAI,CAAC2E,MAAM,CAAC,CAAC,EAAEJ,CAAC,CAAC,CAAC;SAClErO,MAAM,CAAC4J,sJAAAA,AAAK,0JAACpJ,OAAAA,AAAI,EAACoJ,KAAK,uJAAElK,KAAK,CAAC2Z,CAAAA,AAAI,EAACvP,IAAI,CAAC2E,MAAM,CAAC,CAAC,CAAC;KACnD;AACH,CAAC;AAKM,MAAMkpB,EAAE,GAAA,WAAA,GAAsBjwB,OAAO,CAAC,CAAA,CAAE,CAAC;AAGzC,MAAMkwB,IAAI,GAAA,WAAA,2JAAGt3B,OAAAA,AAAI,GA0BrBub,IAAI,GAAK,OAAOA,IAAI,CAAC,CAAC,CAAC,KAAK,QAAQ,EAAE,CACvChY,IAA4B,EAC5B4iB,GAAwB,EACxBpY,CAAqC,EACrClB,OAGC,GAED5I,OAAO,CAACV,IAAI,EAAGoJ,CAAC,IACdrF,GAAG,CACDyG,CAAC,CAACpB,CAAC,CAAC,GACHoI,CAAC,GAAA,CAAM;gBAAE,GAAGpI,CAAC;gBAAE,CAACwZ,GAAG,CAAA,EAAGpR;YAAC,CAA2D,EACpF,EAAElI,OAAO,CAAC,CAAC;AAGT,MAAM0qB,MAAM,GAAA,WAAA,yKAGfh2B,SAAWg2B,AAAM,CAAP,CAAiCjwB,AAAhCiwB,GAAmC,CAAC;AAG5C,MAAMC,IAAI,GAAA,WAAA,yKAYbj2B,OAAWi2B,AAAI,EAA0BlwB,CAA/B,CAACkwB,CAAiC,CAAC;AAK1C,MAAMC,eAAe,IAC1Bl0B,IAA4F,IACrD;IACvC,OAAO,IAAIR,UAAU,CAACQ,IAAI,CAAC;AAC7B,CAAC;AAOM,MAAMm0B,UAAU,GAAA,WAAA,IAAG13B,8JAAAA,AAAI,GAG3Bub,IAAI,GAAKrY,QAAQ,CAACqY,IAAI,CAAC,CAAC,CAAC,CAAC,EAAE,CAAChY,IAAI,EAAEo0B,QAAQ,GAAG,OAAO,GACtD5tB,OAAO,CAAC,MAAK;QACX,MAAM6tB,OAAO,GAAG,IAAIC,WAAW,CAACF,QAAQ,CAAC;QACzC,OAAOrwB,GAAG,CAAC/D,IAAI,EAAGI,CAAC,IAAKi0B,OAAO,CAACE,MAAM,CAACn0B,CAAC,CAAC,CAAC;IAC5C,CAAC,CAAC,CAAC;AAGE,MAAMo0B,UAAU,IAAUx0B,IAAiC,GAChEwG,OAAO,CAAC,MAAK;QACX,MAAMiuB,OAAO,GAAG,IAAIC,WAAW,EAAE;QACjC,OAAO3wB,GAAG,CAAC/D,IAAI,GAAGI,CAAC,GAAKq0B,OAAO,CAACE,MAAM,CAACv0B,CAAC,CAAC,CAAC;IAC5C,CAAC,CAAC;AAGG,MAAMw0B,iBAAiB,GAAGA,CAC/BhR,MAA+B,EAC/BiR,IAAY,EACZvrB,OAKa,GAEbC,SAAS,EAAKlL,IAAI,yJAChBnC,MAAM,CAACiF,UAAAA,AAAc,GACnBjF,MAAM,CAAC8L,qJAAAA,AAAI,EAAC,IAAM4b,MAAM,CAACkR,gBAAgB,CAACD,IAAI,EAAEx2B,IAAI,CAAC02B,MAAa,EAAEzrB,OAAO,CAAC,CAAC,EAC7E,IAAMpN,MAAM,CAAC8L,sJAAAA,AAAI,EAAC,IAAM4b,MAAM,CAACoR,mBAAmB,CAACH,IAAI,EAAEx2B,IAAI,CAAC02B,MAAM,EAAEzrB,OAAO,CAAC,CAAC,CAChF,EAAE;QAAEnC,UAAU,EAAE,OAAOmC,OAAO,KAAK,QAAQ,GAAGA,OAAO,CAACnC,UAAU,GAAGE;IAAS,CAAE,CAAC","ignoreList":[0],"debugId":null}}]
}